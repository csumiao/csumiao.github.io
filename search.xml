<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EventLoop和线程模型</title>
      <link href="posts/EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>posts/EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Netty-Reactor-模型之单线程模型"><a href="#Netty-Reactor-模型之单线程模型" class="headerlink" title="Netty Reactor 模型之单线程模型"></a>Netty Reactor 模型之单线程模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不同的线程模式，对于程序的性能差别是很大的，目前存在的线程模式主要有两种，分别是<strong>传统堵塞 I/O 服务模型</strong>和 <strong>Reactor 模型</strong>。其中又根据 Reactor 的数量和处理资源池线程的数量不同具体分为以下几种模型，具体如下：</p><ol><li>单 Reactor 单线程；</li><li>单 Reactor 多线程；</li><li>主从 Reactor 多线程。</li></ol><p>本节内容，主要讲解<strong>传统堵塞 I/O 模型</strong>和<strong>单 Reactor 单线程模型</strong>的核心原理。</p><h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><p>学习 Reactor 模型的好处在于可以知道传统的 I/O 的性能瓶颈在哪里，应该如何去提升性能。Reactor 模型只是纯理论上的东西，不涉及具体代码，并且它并不是只是针对 Netty 的一种理论，而是针对涉及 IO、涉及通信都需要去了解的理论方面的知识。包括常见知名的中间件 Redis、Nginx 等也都是基于这些线程模型去进行优化升级。</p><h2 id="传统堵塞-I-O-模型"><a href="#传统堵塞-I-O-模型" class="headerlink" title="传统堵塞 I/O 模型"></a>传统堵塞 I/O 模型</h2><h3 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h3><p><img src="https://s2.loli.net/2021/12/24/IKGlpFwuC12n6VR.png" alt="图片描述"></p><p>上图是传统堵塞模型的模型图，其特点如下所示：</p><ol><li>每个客户端连接服务端时，服务端都会为客户端开辟一个线程专门处理其对应的业务请求；</li><li>每个线程独立完成其对应的客户端业务，读取数据、处理数据、响应数据，线程之间互不干扰；</li><li>如果某个客户端长时间没有请求数据时，那么服务端也不会释放线程，而是线程处于堵塞状态。</li></ol><p>Socket 编程就是传统 I/O 堵塞模型，其缺点也非常的明显，具体如下：</p><ol><li>如果客户端数量很大的情况，会为每个客户端都创建独立子线程，那么将消耗服务器大量的资源，增加 CPU 的工作压力，子线程虽然能提高处理速度，但是使用不合理反而降低服务器的性能；</li><li>如果某个客户端没有请求时，它还占用了服务器的资源，负责处理它业务的线程没有得到释放，而是一直堵塞于 <strong>read()</strong> 方法，直到下一次的请求进来。</li></ol><h3 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h3><blockquote><p>思考：针对传统的 I/O 模型的两个缺点，应该如何优化呢？</p></blockquote><p>主要从两个方面进行改造，具体如下：</p><ol><li><strong>I/O 多路复用：</strong> 它是操作系统级别的机制，大概原理是客户端连接时直接注册到操作系统的内核，当某个连接有新的数据可以处理时，操作系统通知应用程序，应用程序从堵塞状态切换到读取状态，开始进行业务处理。这种模型也叫反应器模型、分发者模式（Dispatcher）、通知这模式（notifier）。如果所有客户端都没有数据可处理时，应用程序只需要堵塞一个地方即可，相比<strong>传统 I/O 模型</strong>堵塞于各个线程的 <strong>read()</strong> 方法，这种模型的性能提高了很多；</li><li><strong>线程池复用线程资源：</strong> 应用程序读取数据时，通过线程池创建子线程去处理业务、响应业务，处理完成之后自动释放线程，这样的好处在于 1）无需针对每个客户端独立创建子线程；2）子线程处理完成之后自动释放资源，而不是占着资源不释放，增加 CPU 的开销。</li></ol><p><strong>架构图如下所示：</strong></p><p><img src="https://s2.loli.net/2021/12/24/BPDcs4A3SHEReNf.png" alt="图片描述"></p><p><strong>以上架构图分析：</strong></p><ol><li>多路复用器专门负责客户端请求的监听、读取数据、分发数据，但是不负责具体的业务处理；</li><li>业务处理是非常的复杂且耗时的，直接丢给线程池去负责处理；</li><li>整个架构的堵塞点在多路复用器，线程池则不会堵塞，如果没用客户端事件时，线程池可以释放去做别的事情；</li><li>通过以上的改造，那么整体的架构的性能就会得到不少提升。</li></ol><h2 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h2><p>单 Reactor 单线程模型，和上面的模型优化思路是类似的，具体如下：</p><p><img src="http://img.mukewang.com/wiki/5f365f4a09114ba710130524.jpg" alt="图片描述"></p><p><strong>架构图说明</strong></p><ol><li>Select 是 I/O 多路复用模型的标准网络编程 API，可以实现应用程序通过一个堵塞对象监听多路连接请求。Reactor 对象通过 Select 监听客户端请求事件，收到事件之后通过 Dispatch 进行分发；</li><li>如果事件类型是连接请求事件，则由 Acceptor 处理连接请求；</li><li>如果事件类型是普通业务（比如：客户端发送业务请求），则创建 Handler 来读取数据、业务处理、响应数据。</li></ol><p>这种模式架构简单，但是存在以下缺点，具体如下：</p><ol><li>如果客户端的连接数量很多的情况下，将无法支撑，因为负责处理客户端请求的 Reactor 只有一个；</li><li>负责处理业务的 Handler 只有一个，也就是说只有一个子线程负责处理具体业务，无法很好的利用多核 CPU 的性能；</li><li>如果线程出现问题，比如：意外终止、进入死循环，那么整个系统的通讯功能将会收到影响，造成通讯故障。</li></ol><p>单 Reactor 单线程模型，一般适用于客户端数量比较少，业务处理复杂度很低，处理起来速度非常快的情况，因此真实业务场景不太建议使用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节主要掌握的知识点</p><ol><li>常见的线程模型主要分为传统的 IO 模型和 Reactor 模型；</li><li>Reactor 模型又细分单 Reactor 单线程模型、单 Reactor 多线程模型、主从多线程模型；</li><li>传统 IO 模型的缺点是什么，应该如何去优化；</li><li>单 Reactor 单线程的模型原理是什么，有什么优缺点。</li></ol><h1 id="Netty-Reactor-模型之多线程模型"><a href="#Netty-Reactor-模型之多线程模型" class="headerlink" title="Netty Reactor 模型之多线程模型"></a>Netty Reactor 模型之多线程模型</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>回顾上节，我们了解了什么是传统堵塞 I/O 模型，什么是单 Reactor 单线程模型，以及它们的缺点，本节内容主要是针对单 Reactor 单线程模型的缺点进行升级，让它的性能得到进一步的提高。</p><h2 id="如何进行优化"><a href="#如何进行优化" class="headerlink" title="如何进行优化"></a>如何进行优化</h2><blockquote><p>首先，我们思考一下单 Reactor 单线程的性能瓶颈在哪里？</p></blockquote><p>主要有以下两个方面的性能上的缺点：</p><ol><li>整个流程处理都是单线程，包括：监听客户端连接、分发客户端请求、处理客户端请求及响应，整个流程非常的复杂和耗时，只有一个线程的话，如果客户端数量比较多，那么将处理不过来；</li><li>客户端的监听、请求分发和业务处理耦合一起，业务处理将是一个未知的东西，如果这个业务很复杂需要连接数据库，并且操作好几张表，那么可能将会耗时相对的长，那么将会影响其他的客户端请求。</li></ol><p>针对单 Reactor 单线程的两个缺点，本节我们主要针对<strong>第二个缺点</strong>来进行改造，其实一般提到线程模型的概念，一般都喜欢结合生活当中的<strong>饭店经营模式</strong>这个俗套来进行说明，可以加深同学们的印象。</p><ol><li><strong>单 Reactor 单线程模型：</strong> 好比一个小饭馆，老板既要招待客人又要炒菜，老板服务效率既然很低，挣的钱既然不会太多；</li><li><strong>单 Reactor 多线程模型：</strong> 老板专门招待客人，并且把客人的点菜传达给后厨，后厨有多个厨师负责炒菜，这样的话，炒菜的速度既然提高，客人也会觉得满意；</li><li><strong>主从多线程模式：</strong> 虽然有多个厨师负责炒菜，但是前台只要一个人在忙活，即使后厨炒菜速度很快，那么给客户上菜的效率也会受到影响，如果客户爆满的话，服务员只能累死的份了，那怎么办呢？增加服务员的人数不就解决问题了。</li></ol><h2 id="单-Reactor-多线程模型"><a href="#单-Reactor-多线程模型" class="headerlink" title="单 Reactor 多线程模型"></a>单 Reactor 多线程模型</h2><p><img src="https://s2.loli.net/2021/12/24/qtTJNFsUrfR8ou7.png" alt="图片描述"></p><p><strong>架构图说明：</strong></p><ol><li>Reactor 通过 Select 监听客户端请求事件，收到事件之后它本身不负责处理，而是把事件转发出去；</li><li>如果是建立连接请求，则由 Acceptor 进行处理；</li><li>如果不是建立连接请求，则转发给 Handler 负责处理；</li><li>Handler 也不负责处理具体的业务，而是通过 read () 方法读取数据，然后再次分发给线程池去进行处理；</li><li>线程池会分配一个子线程去处理具体的业务，处理完成之后把结果返回给 Handler，并释放连接给连接池。</li></ol><p><strong>模式的优点：</strong></p><ol><li>可以充分的利用多核 CPU 的资源，提高处理任务的性能；</li><li>把业务处理从整个模型中剥离并丢给线程池去处理，避免某个业务处理或者某次业务处理太慢导致其他业务处理受到影响；</li><li>相比传统 I/O 堵塞模型，如果一旦没有客户端发起请求，那么线程池将不会处于堵塞状态，而是释放并且可以处理其他的业务，对于性能调优来说，最宝贵的就是线程资源，一旦线程资源得不到释放，整个应用将会卡掉。</li></ol><p><strong>模式的缺点：</strong></p><ol><li>多线程之间的数据共享和访问比较复杂，比如：Handler 给 Worker 线程分发数据；</li><li>Reactor 处理所有事件的监听、转发、响应，都是单线程，在高并发的情况下，负责处理业务的 Worker 可能正常，但是 Reactor 就会容易遇到性能瓶颈；</li><li>Reactor 如果一旦出现故障，那么整个通讯就会故障。</li></ol><p>通过以上的分析，其实也是不推荐使用这种模式，除非客户端数量比较少，类似局域网内部的项目，但是我们还是需要了解整个模型是如何演变过来的，而不是一上来就讲解最好的那个方案。只有把整个演变过程了解了，我们才能更好的了解整个线程模型可能存在的性能瓶颈在哪里。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本节核心掌握的知识点</p><ol><li>了解单 Reactor 单线程的弊端在哪里；</li><li>通过线程池的方式去解决单 Reactor 单线程存在的缺点；</li><li>通过饭馆经营的案例来讲解几种 Reactor 线程模型的概念，让大家更加容易理解；</li><li>介绍了什么是单 Reactor 多线程模型，以及它的优缺点是什么。</li></ol><h1 id="Netty-Reactor-模型之主从多线程模型"><a href="#Netty-Reactor-模型之主从多线程模型" class="headerlink" title="Netty Reactor 模型之主从多线程模型"></a>Netty Reactor 模型之主从多线程模型</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>通过上节的分析，我们知道<strong>单 Reactor 多线程模型</strong>它的性能瓶颈在于单个 Reactor，本节主要讲解如何进行优化单个 Reactor 带来的性能瓶颈问题。</p><h2 id="单-Reactor-性能瓶颈"><a href="#单-Reactor-性能瓶颈" class="headerlink" title="单 Reactor 性能瓶颈"></a>单 Reactor 性能瓶颈</h2><p>单 Reactor 主要存在的性能瓶颈如下：</p><ol><li><strong>压力问题：</strong> 客户端数量比较多的情况，单个 Reactor 负责监听和转发，那么 Reactor 压力非常的大；</li><li><strong>单点故障问题：</strong> 如果 Reactor 发生故障，则即使后面的 Handler 和 Worker 正常工作，但是整个应用程序无法正常对外提供服务。</li></ol><h2 id="如何进行优化-1"><a href="#如何进行优化-1" class="headerlink" title="如何进行优化"></a>如何进行优化</h2><blockquote><p>思考：如何解决单 Reactor 性能问题呢？</p></blockquote><ol><li><strong>以 Tomcat 作为案例来进行分析：</strong><br>1.1 <strong>问题：</strong> 我们平时把项目打包成 war 部署到单个 Tomcat 来进行运行，在并发量很小的情况下是正常运行的，但是一旦并发量达到 1k 以上，单个 Tomcat 就会很吃力了，那怎么办呢？<br>1.2 <strong>解决：</strong> 很简单，只需要在 Tomcat 前面加 Nginx 做负载转发，这样的话，多个 Tomcat 同时对外提供服务，不但整体的性能得到提高，即使其中一个 Tomcat 宕机，但是整个 Tomcat 集群还是能正常对外提供服务。</li><li><strong>生活中饭馆的案例进行说明：</strong><br>还是以<strong>饭馆经营模型</strong>说明，方便大家更好的理解。<br>2.1 一个饭馆只有一个老板，老板即兼职服务员和厨师的工作，整体效率很低，这就是单 Reactor 单线程模型；<br>2.2 一个负责迎接客户、点菜、上菜的服务员（Reactor 线程），几个厨师负责炒菜（Worker 线程），厨师轻松了，但是服务员依然忙不过来，这就是单 Reactor 多线程模型；<br>2.3 一个负责迎接在门口迎接小妹妹（好比：Reactor 主线程），几个专门负责点菜和上菜的服务员（好比：Reactor 从线程），几个负责炒菜厨师（Worker 线程），那么每个岗位都会很轻松，并且还能服务更多的客户进行就餐，这就是主从 Reactor 多线程模型。</li></ol><p>其实，Reactor 模型也是类似道理，哪个环节性能存在瓶颈，那么将其功能再细分，并且增加执行数量（<strong>集群</strong>）即可。</p><h2 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h2><p><img src="https://s2.loli.net/2021/12/24/2gnby9ZqGzwMtk7.png" alt="图片描述"></p><p><strong>架构图分析：</strong></p><ol><li>主要分为三个模块，分别为 Reactor 主线程、Reactor 子线程、Worker 线程池。其中 Reactor 主线程可以对应多个 Reactor 子线程，也就是说，一个 MainReactor 对应多个 SubReactor；</li><li>Reactor 主线程的 MainReactor 对象通过 Select 监听客户端连接事件，收到事件之后，通过 Acceptor 处理连接事件；</li><li>当 Acceptor 处理连接事件之后，MainReactor 将连接事件分配给 Reactor 子线程的 SubReactor 进行处理；</li><li>SubReactor 将连接加入到连接队列进行监听，并且创建 Handler 处理对应的事件。一旦有新的事件（非连接）则分配给 Handler 进行处理；</li><li>Handler 通过 read () 方法读取数据，并且分发给 Worker 线程池去做业务处理；</li><li>Worker 线程池分配线程去处理业务，处理完成之后把结果返回给 Handler；</li><li>Handler 收到 Worker 线程返回的结果之后，再通过 send () 方法返回给客户端。</li></ol><p><strong>方案的优点：</strong></p><ol><li>责任明确，单一功能拆分的更细，Reactor 主线程负责接收请求，不负责处理请求；Reactor 子线程负责处理请求。并发量很高的情况，可以减轻单个 Reactor 的压力，并且提高处理速度；</li><li>Reactor 子线程只负责读取数据和响应数据，耗时的业务处理则丢给 Worker 线程池去处理。这种通过把完整任务层层分发下去，每个组件需要处理的内容就会变的很简单，处理起来效率自然会很高。</li></ol><p><strong>方案的缺点：</strong></p><ol><li>编程复杂度非常的高；</li><li>即使一个 Reactor 主线程对应多个 Reactor 子线程，Reactor 主线程还是会存在单节点故障问题，不过真实业务场景当中，如果考虑单节点故障问题的话，一般都是通过分布式集群（Netty 集群）的方式去解决，而不是靠单节点的线程模型去解决，这里大家了解一下即可。</li></ol><p>总的来说，主从多线程模型是应用比较多的一种线程模型，包括 Nginx 主从 Reactor 多线程模型、Memcached 主从多线程模型、Netty 主从多线程模型等知名开源框架的。</p><h2 id="模型对比"><a href="#模型对比" class="headerlink" title="模型对比"></a>模型对比</h2><p>Reactor 模型和传统的 IO 模型对比</p><table><thead><tr><th align="left"></th><th align="left">传统 IO 模型</th><th align="left">Reactor 模型</th></tr></thead><tbody><tr><td align="left">线程分配</td><td align="left">为每个客户端都分配独立的线程，该线程负责全部的工作（包括：监听、读取、处理、响应）</td><td align="left">统一的监听客户端请求，并且把功能细分，并且分配给不同的子线程去处理</td></tr><tr><td align="left">堵塞点</td><td align="left">在每个子线程的 read () 方法进行堵塞</td><td align="left">只在 select () 堵塞，select () 是所有客户端共用的入口点</td></tr><tr><td align="left">整体性能</td><td align="left">并发量相对有限</td><td align="left">可以处理高并发</td></tr></tbody></table><p>Reactor 的整体优点如下：</p><ol><li>性能好，Reactor 本身虽然是同步的，但是是非堵塞的，可以快速的响应；</li><li>扩展性好，可以根据 CPU 的核数来调整 Reactor 的实例个数，充分的利用 CPU 资源；</li><li>复用性好，它是一种思想，可以灵活的运用到不同的中间件、底层框架上。</li></ol><p>三种 Reactor 线程模型对比</p><table><thead><tr><th align="left"></th><th align="left">单 Reactor 单线程</th><th align="left">单 Reactor 多线程</th><th align="left">主从多线程</th></tr></thead><tbody><tr><td align="left">功能</td><td align="left">一个线程负责所有业务</td><td align="left">一个线程服务监听、事件处理、转发，多个线程负责逻辑处理</td><td align="left">一个线程负责监听，多个线程负责事件处理、转发，多个线程负责逻辑处理</td></tr><tr><td align="left">线程</td><td align="left">一个线程</td><td align="left">一个线程，一个线程组</td><td align="left">一个线程，两个线程组</td></tr><tr><td align="left">性能</td><td align="left">低</td><td align="left">中</td><td align="left">高</td></tr><tr><td align="left">高可用</td><td align="left">否</td><td align="left">否</td><td align="left">是</td></tr></tbody></table><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>通过这几个小节的讲解，相信大家对 Reactor 线程模型都已经有了一定的了解了，其实我们只需要了解这几种模型的架构思想即可。Reactor 它是一种思想，而并非是 Netty 所特有的，常见的中间件 Nginx、Redis 等底层通讯也都是基于 Reactor 思想去实现。只有把 Reactor 模型理解了，后期在阅读源码时才能更好的理解 Netty。</p><h1 id="Netty-线程模型"><a href="#Netty-线程模型" class="headerlink" title="Netty 线程模型"></a>Netty 线程模型</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>前面几节分别讲解了 Reactor 的三种线程模型，都知道主从 Reactor 多线程模型的性能非常的好，那么 Netty 是否就是使用<strong>主从 Reactor 多线程模型</strong>呢？其实 Netty 线程模型是基于<strong>主从 Reactor 多线程模型</strong>做了一定的改造，Netty 的线程模型要比 Reactor 主从多线程模型还要复杂。本节主要是通过图解的方式逐步分析 Netty 线程模型的原理。</p><h2 id="Netty-模型介绍"><a href="#Netty-模型介绍" class="headerlink" title="Netty 模型介绍"></a>Netty 模型介绍</h2><h3 id="模型介绍-1"><a href="#模型介绍-1" class="headerlink" title="模型介绍"></a>模型介绍</h3><p><img src="https://s2.loli.net/2021/12/24/6O5VTqSDsfd3PuE.png" alt="图片描述"></p><p><strong>Netty 模型架构说明：</strong></p><ol><li>Netty 抽象出两个线程池，分别是 BossGroup 和 WorkerGroup，BossGroup 专门负责接受客户端的连接，Worker 请求处理；</li><li>BossGroup 和 WorkerGroup 类型默认使用的是 NioEventLoopGroup；</li><li>NioEventLoopGroup 是一个定时任务线程池，NioEventLoop 是真正工作的线程；</li><li>每个 BossGroup 的 NioEventLoop 分别循环执行三个步骤<br>4.1 每个 NioEventLoop 都有一个 Selector，并且不断轮询 accept 事件；<br>4.2 处理 accept 事件，与客户端建立连接，生成 NioSocketChannel，并且将其注册到某个 WorkerGroup 下的 NioEventLoop 上的 Selector 上；<br>4.3 处理任务队列中的任务，即 runAllTasks。</li><li>每个 WorkerGroup 的 NioEventLoop 分别循环执行三个步骤<br>5.1 轮询 read 和 write 事件；<br>5.2 处理 I/O 事件，即 read，write 事件，并在其对应的 NioSocketChannel 处理；<br>5.3 处理任务队列的任务，即 runAllTasks。</li></ol><h3 id="核心概念理解"><a href="#核心概念理解" class="headerlink" title="核心概念理解"></a>核心概念理解</h3><blockquote><p><strong>Tips:</strong> 额外知识点补充，这里提前剧透一下 Channel、ChannelPipeline、ChannelHanlder 之间的关系</p></blockquote><ol><li>每个客户端连接进来的时候，服务端都会建立一个 Channel；</li><li>为每个 Channel 绑定一个 NioEventLoop 线程，该线程主要负责处理该 Channel 的业务，一个 Channel 对应一个 NioEventLoop，但是一个 NioEventLoop 可以同时服务多个 Channel；</li><li>为每个 Channel 绑定一个 ChannelPipeline，它是一个业务管道，专门负责管理业务链，也就是 ChannelHandler；</li><li>WorkerGroup 的核心方法是 runAllTasks ()，它主要是触发 NioEventLoop 去处理对应的 Channel 里面的 ChannelPipeline 里面的 ChannelHandler 里面的业务逻辑。</li></ol><h2 id="Netty-模型配置"><a href="#Netty-模型配置" class="headerlink" title="Netty 模型配置"></a>Netty 模型配置</h2><h3 id="单线程配置"><a href="#单线程配置" class="headerlink" title="单线程配置"></a>单线程配置</h3><p>在 ServerBootstrap 调用方法 group 的时候，传递的参数是同一个线程组，且在构造线程组的时候，构造参数为 1。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerNetty</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap bootstrap=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup group=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        group=<span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);<span class="comment">//线程数量为 1</span></span><br><span class="line">        bootstrap.group(group,group);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多线程配置"><a href="#多线程配置" class="headerlink" title="多线程配置"></a>多线程配置</h3><p>在 ServerBootstrap 调用方法 group 的时候，传递的参数是两个不同的线程组，负责监听的 acceptor 线程组的线程数为 1，负责处理客户端线程组的线程数大于 1。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerNetty</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap bootstrap=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup acceptorGroup=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup clientGroup=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        acceptorGroup=<span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);<span class="comment">//线程数量为 1</span></span><br><span class="line">        clientGroup=<span class="keyword">new</span> NioEventLoopGroup();<span class="comment">//默认是 cpu 的核心数</span></span><br><span class="line">        bootstrap.group(acceptorGroup,clientGroup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="主从多线程配置"><a href="#主从多线程配置" class="headerlink" title="主从多线程配置"></a>主从多线程配置</h3><p>在 ServerBootstrap 调用方法 group 的时候，传递的参数是两个不同的线程组，负责监听的 acceptor 线程组的线程数大于 1，负责处理客户端线程组的线程数大于 1。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerNetty</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap bootstrap=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup acceptorGroup=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup clientGroup=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        acceptorGroup=<span class="keyword">new</span> NioEventLoopGroup();<span class="comment">//默认是 cpu 的核心数</span></span><br><span class="line">        clientGroup=<span class="keyword">new</span> NioEventLoopGroup();<span class="comment">//默认是 cpu 的核心数</span></span><br><span class="line">        bootstrap.group(acceptorGroup,clientGroup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="自定义任务队列"><a href="#自定义任务队列" class="headerlink" title="自定义任务队列"></a>自定义任务队列</h2><p>通常情况下，任务队列中常见的任务主要有以下几种类型：</p><ol><li>用户自定义的异步任务，比如：依赖线程池去异步某个任务等；</li><li>用户自定义的定时任务，比如：依赖定时线程池去定义每隔 n 秒执行某个任务等；</li><li>非当前 reactor 线程调用 channel 的各种方法。</li></ol><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>其实跟我们平时使用线程池没有什么区别，只不过调用的是底层 Netty 线程组。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 reactor 线程的异步任务</span></span><br><span class="line">ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程池去实现异步任务</span></span><br><span class="line">ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>其实类似我们平时使用的定时任务线程池（如：ScheduledThreadPool），只不过是调用底层 Netty 线程组。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 reactor 线程实现的定时任务</span></span><br><span class="line">ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程池去实现定时任务</span></span><br><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">ses.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i:&quot;</span> + temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ol><li>当前 reactor 线程调用当前 eventLoop 执行任务，直接执行，否则，添加到任务队列稍后执行；</li><li>netty 内部的任务分为普通任务和定时任务，分别落地到 MpscQueue 和 PriorityQueue；</li><li>netty 每次执行任务循环之前，会将已经到期的定时任务从 PriorityQueue 转移到 MpscQueue；</li><li>netty 每隔 64 个任务检查一下是否该退出任务循环。</li></ol><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>本节主要掌握的核心知识点</p><ol><li>Netty 的模型的理解，以及每个 NioEventLoop 所执行的三个核心操作，分别是①轮询出 IO 事件；②处理 IO 事件；③处理任务队列；</li><li>了解 Channel、ChannelPipeline、ChannelHandler 之间的关系，以及 NioEventLoop 主要负责处理每个 Channel 的业务逻辑；</li><li>Netty 如何配置三种 Reactor 模型；</li><li>如何使用内置的 NioEventLoop 执行自定义的异步任务和定时任务。</li></ol><h1 id="Netty-EventLoop-事件循环机制"><a href="#Netty-EventLoop-事件循环机制" class="headerlink" title="Netty EventLoop 事件循环机制"></a>Netty EventLoop 事件循环机制</h1><h2 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h2><p>前面几节主要讲解了 Netty 的几种线程模型，基本上都是理论上的东西，那么 Netty 是如何去实现这些线程模型的呢？答案：核心是 EventLoop，今天我们主要介绍 EventLoop 是如何来实现线程模型的。</p><h2 id="什么是-EventLoop"><a href="#什么是-EventLoop" class="headerlink" title="什么是 EventLoop"></a>什么是 EventLoop</h2><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventLoop</span> <span class="keyword">extends</span> <span class="title">OrderedEventExecutor</span>, <span class="title">EventLoopGroup</span> </span>&#123;</span><br><span class="line">    <span class="function">EventLoopGroup <span class="title">parent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventLoopGroup</span> <span class="keyword">extends</span> <span class="title">EventExecutorGroup</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventExecutorGroup</span> <span class="keyword">extends</span> <span class="title">ScheduledExecutorService</span>, <span class="title">Iterable</span>&lt;<span class="title">EventExecutor</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面的简单源码，我们发现 EventLoopGroup 就是一个线程池，它是继承 Java 并发包下的定时线程池，而 EventLoop 则是线程池里面的一个子线程。</p><p>通过源码查看它们之间的关系，具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventLoopGroup</span> <span class="keyword">extends</span> <span class="title">EventExecutorGroup</span> </span>&#123;</span><br><span class="line">    <span class="function">EventLoop <span class="title">next</span><span class="params">()</span></span>;<span class="comment">//返回线程组里面的一个线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventLoop</span> <span class="keyword">extends</span> <span class="title">OrderedEventExecutor</span>, <span class="title">EventLoopGroup</span> </span>&#123;</span><br><span class="line">    <span class="function">EventLoopGroup <span class="title">parent</span><span class="params">()</span></span>;<span class="comment">//关联该线程所属的线程组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过以上简单的分析，我们需要掌握的知识点是，Netty 是通过线程池去实现 Reactor 线程模型的，而线程池并不是使用 Java 内置的线程池，而是继承它们并且进行了一定的扩展。就是 EventLoopGroup 和 EventLoop。</p><h2 id="EventLoop-的架构图"><a href="#EventLoop-的架构图" class="headerlink" title="EventLoop 的架构图"></a>EventLoop 的架构图</h2><p>EventLoop 整体的类 UML 关系图还是比较复杂的，Netty 底层主要是以 NIO 为主，因此核心掌握 NioEventLoop 和 NioEventLoopGroup 两个类的结构即可。</p><p><strong>NioEventLoopGroup 关系图：</strong><br><img src="https://s2.loli.net/2021/12/24/OeIdrDZgX2TGmF5.png" alt="图片描述"></p><p>以上的架构图，我们主要关心 <code>NioEventLoopGroup</code>-&gt;<code>MultithreadEventLoopGroup</code>-&gt;<code>EventLoopGroup</code>，其实这种是比较典型的接口、抽象类、实现类的模式。</p><p><strong>NioEventLoop 关系图</strong><br><img src="https://s2.loli.net/2021/12/24/ZFK7DWLNfOpgv8P.png" alt="图片描述"></p><p>以上的架构图，我们主要关心的是 <code>NioEventLoop</code>-&gt;<code>SingleThreadEventLoop</code>-&gt;<code>EventLoop</code>，它也是典型的接口、抽象类、实现类的模式。</p><h2 id="EventLoop-的核心原理"><a href="#EventLoop-的核心原理" class="headerlink" title="EventLoop 的核心原理"></a>EventLoop 的核心原理</h2><p>下面，我们将通过源码的方式介绍 EventLoop 在 Netty 当中是如何运行的。<br>首先，我们需要了解 EventLoop 三个核心步骤，如下图所示：<br><img src="https://s2.loli.net/2021/12/24/W6Tye7m8IkXSwYA.png" alt="图片描述"></p><h3 id="EventLoop-的核心作用"><a href="#EventLoop-的核心作用" class="headerlink" title="EventLoop 的核心作用"></a>EventLoop 的核心作用</h3><p>EventLoop 的核心作用是，一定客户端连接进来，则服务端给其分配一个 Channel（连接通道），并且会给 Channel 分配一个 EventLoop 和 ChannelPipeline。其中，EventLoop 主要负责该 Channel 相关的业务逻辑处理的，ChannelPipeline 则负责管理业务逻辑（双向链表）。ChannelPipleline 下一个章节会详细讲解。</p><p>EventLoop 的核心功能是处理 Channel 相关的业务逻辑，它里面其实是一个死循环，重复做着 3 个事件，分别是</p><ol><li>监控端口；</li><li>处理端口事件，将其分发；</li><li>处理队列事件。</li></ol><blockquote><p>核心结论：每个 EventLoop 可以被绑定到多个 Channel 身上，但是一个 Channel 有且仅有一个 EventLoop 与之进行对应。</p></blockquote><h3 id="NioEventLoop-初始化流程"><a href="#NioEventLoop-初始化流程" class="headerlink" title="NioEventLoop 初始化流程"></a>NioEventLoop 初始化流程</h3><p>这里，我们将通过核心源码来梳理一下 <code>NioEventLoopGroup</code> 的初始化流程，也就是线程池的初始化。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">serverBootstrap</span><br><span class="line">    .group(bossGroup, workerGroup);</span><br><span class="line"><span class="comment">//省略其它代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>第一步：</strong> 进入 NioEventLoopGroup 构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventLoopGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造函数一直跟进</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> nThreads, Executor executor, </span></span></span><br><span class="line"><span class="function"><span class="params">        SelectorProvider selectorProvider, </span></span></span><br><span class="line"><span class="function"><span class="params">        SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用父类的构造函数，点进去，查看源码</span></span><br><span class="line">        <span class="keyword">super</span>(nThreads, executor, </span><br><span class="line">              <span class="keyword">new</span> Object[]&#123;selectorProvider, selectStrategyFactory, </span><br><span class="line">                           RejectedExecutionHandlers.reject()&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>第二步：</strong> MultithreadEventLoopGroup 构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventExecutorGroup</span> <span class="keyword">implements</span> <span class="title">EventLoopGroup</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用父类的构造函数，点进去，查看源码</span></span><br><span class="line">        <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>第三步：</strong> MultithreadEventExecutorGroup 构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadEventExecutorGroup</span> <span class="keyword">extends</span> <span class="title">AbstractEventExecutorGroup</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//点击跟进</span></span><br><span class="line">        <span class="keyword">this</span>(nThreads, </span><br><span class="line">             (Executor)(threadFactory == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> ThreadPerTaskExecutor(threadFactory)), </span><br><span class="line">             args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//核心，在这里进行 “线程组” 初始化工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] children;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略了其它代码，只保留核心部分</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建一个数组，长度是 nThreads</span></span><br><span class="line"><span class="keyword">this</span>.children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line">        <span class="comment">//2.数组初始化值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; ++i) &#123;</span><br><span class="line">            <span class="comment">//通过 this.newChild() 来创建具体“线程”</span></span><br><span class="line">            <span class="keyword">this</span>.children[i] = <span class="keyword">this</span>.newChild((Executor)executor, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//newChild 是一个抽象类，由子类去进行实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> EventExecutor <span class="title">newChild</span><span class="params">(Executor var1, Object... var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>第四步：</strong> 由子类 NioEventLoopGroup 去实现 newChild () 抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventLoopGroup</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个 NioEventLoop</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, </span><br><span class="line">                                (SelectorProvider)args[<span class="number">0</span>], </span><br><span class="line">                                ((SelectStrategyFactory)args[<span class="number">1</span>]).newSelectStrategy(), </span><br><span class="line">                                (RejectedExecutionHandler)args[<span class="number">2</span>]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，我们终于看到 NioEventLoop 的身影了，在 newChild () 去进行初始化工作。</p><h3 id="NioEventLoop-执行流程"><a href="#NioEventLoop-执行流程" class="headerlink" title="NioEventLoop 执行流程"></a>NioEventLoop 执行流程</h3><p>上面讲解了 NioEventLoop 的初始化流程，那么它到底在什么时候开始执行的呢？</p><p>源码入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.bind(<span class="number">80</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>第一步：</strong> 抽象类 AbstractBootstrap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.validate();</span><br><span class="line">        <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;localAddress&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//继续跟进</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.doBind(localAddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//继续跟进</span></span><br><span class="line">        <span class="keyword">final</span> ChannelFuture regFuture = <span class="keyword">this</span>.initAndRegister();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//继续跟进</span></span><br><span class="line">        <span class="keyword">this</span>.init(channel);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>第二步：</strong> 实现类 ServerBootstrap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">ServerBootstrap</span>, <span class="title">ServerChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.把 ChannelHandler 添加到 ChannelPipeline 里，组成一条双向业务链表</span></span><br><span class="line">        p.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">//1.1.管道</span></span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                <span class="comment">//1.2.添加到管道</span></span><br><span class="line">                ChannelHandler handler = ServerBootstrap.<span class="keyword">this</span>.config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;handler&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//1.3.执行线程池的 “execute()”，核心入口</span></span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pipeline.addLast(</span><br><span class="line">                            <span class="keyword">new</span> ChannelHandler[]&#123;</span><br><span class="line">                                <span class="keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(</span><br><span class="line">                                    currentChildGroup, </span><br><span class="line">                                    currentChildHandler, </span><br><span class="line">                                    currentChildOptions, </span><br><span class="line">                                    currentChildAttrs)</span><br><span class="line">                            &#125;</span><br><span class="line">                        );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里是在 init () 方法里面进行一序列的初始化工作，并且执行上面初始化好的 NioEventLoop 的 execute () 方法。</p><p><strong>第三步：</strong> 执行 SingleThreadEventExecutor 的 execute () 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadEventExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractScheduledEventExecutor</span> <span class="keyword">implements</span> <span class="title">OrderedEventExecutor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//是否是当前线程</span></span><br><span class="line"><span class="keyword">boolean</span> inEventLoop = <span class="keyword">this</span>.inEventLoop();</span><br><span class="line"><span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">            <span class="comment">//如果是当前线程，则添加任务到队列</span></span><br><span class="line"><span class="keyword">this</span>.addTask(task);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是当前线程，则先启动线程</span></span><br><span class="line"><span class="keyword">this</span>.startThread();</span><br><span class="line">            <span class="comment">//把任务添加到任务队列</span></span><br><span class="line"><span class="keyword">this</span>.addTask(task);</span><br><span class="line">            <span class="comment">//如果线程已经关闭并且该任务已经被移除了</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isShutdown() &amp;&amp; <span class="keyword">this</span>.removeTask(task)) &#123;</span><br><span class="line">                <span class="comment">//执行拒绝策略</span></span><br><span class="line">reject();</span><br><span class="line">&#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doStartThread();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//执行 run() 方法</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>第四步：</strong> 子类 NioEventLoop 实现抽象方法 run ()，这里是 run () 方法是一个死循环，并且执行三个核心事件，分别是 “监听端口”、“处理端口事件”、“处理队列事件”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoop</span> <span class="keyword">extends</span> <span class="title">SingleThreadEventLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>run () 方法里面核心执行了 <code>this.processSelectedKeys()</code> 和 <code>this.runAllTasks()</code>。</p><h3 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h3><p>每次执行 execute () 时，都是向队列里面添加任务，当第一次添加时则先启动线程，并且执行子类 NioEventLoop 的 run () 方法。而该 run () 是整个 EventLoop 的核心，主要的核心功能如下：</p><ol><li><code>this.select()</code>，该方法是一个堵塞方法，主要是监听客户端事件；</li><li><code>this.processSelectedKeys()</code>，该方法获取监听到的客户端事件，并将其进行分发；</li><li><code>this.runAllTasks()</code>，执行队列里面的任务。</li></ol><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>本节主要是讲解 EventLoop，它是 Netty 的线程模型的核心，Netty 已经帮我们进行了高度的封装，不需要懂得其原理也不会影响 Netty 的使用，但是如果能了解其核心原理，可以让我们更加深刻的理解 Netty 是如何运转的。</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty 入门案例</title>
      <link href="posts/Netty%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"/>
      <url>posts/Netty%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Netty-入门案例"><a href="#Netty-入门案例" class="headerlink" title="Netty 入门案例"></a>Netty 入门案例</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要是使用 Netty 来开发服务端和客户端，Netty 的开发模式基本上都是<strong>主启动类</strong> + <strong>自定义业务 Handler</strong>，Netty 是基于责任链的模式来管理自定义部分的 Handler，带大家感受一下 Netty 的开发。</p><p><strong>需求：</strong> 本节主要通过 Netty 来实现我们的第一个 Demo，主要功能是分别建立两个项目（客户端和服务端），客户端向服务端发送 <code>Hello World</code>，服务端接受到数据之后打印到控制台，并且给客户端响应。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>第一步：</strong> 使用 Maven 构建工程，项目结构如下：</p><p><img src="https://s2.loli.net/2021/12/24/wUdE1vioG72z4B9.png" alt="图片描述"></p><p><strong>第二步：</strong> <code>netty-demo-client</code> 和 <code>netty-demo-server</code> 两个工程的 pom.xml 导入 Netty 坐标，Netty 主流有三个版本，分别是 3.x、4.x、5.x，一般主流都是使用 4.x 版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">代码块123456</span><br></pre></td></tr></table></figure><p><strong>第三步：</strong> netty-demo-client 工程相关类</p><p>建立两个类，分别是客户端启动类 <code>NettyClient.java</code> 和业务处理类 <code>NettyClientHandler.java</code>。</p><p><img src="https://s2.loli.net/2021/12/24/qJDMpyQVrYH9PRG.png" alt="图片描述"></p><p><strong>第四步：</strong> netty-demo-server 工程相关类</p><p>建立两个类，分别是服务端启动类 <code>NettyServer.java</code> 和业务处理类 <code>NettyServerHandler.java</code></p><p><img src="https://s2.loli.net/2021/12/24/uglz1eIsNQvGMFY.png" alt="图片描述"></p><h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><p>客户端和服务端通信流程图如下图所示：<br><img src="https://s2.loli.net/2021/12/24/PTBaluxngROKck2.png" alt="图片描述"><br><strong>核心步骤说明：</strong></p><ol><li>在 NettyClientHandler 的 channelActive () 方法往服务端发送消息；</li><li>在 NettyServerHandler 的 channelRead () 方法接受消息，并且响应消息给客户端；</li><li>在 NettyClientHandler 的 channelRead () 方法接受服务端的响应消息。</li></ol><h2 id="如何自定义-Handler"><a href="#如何自定义-Handler" class="headerlink" title="如何自定义 Handler"></a>如何自定义 Handler</h2><p>在 Netty 的开发当中，最核心就是自定义 Handler，通常根据不同的业务定义不同的 Handler。自定义 Handler 一般分为三个核心步骤：</p><p>​        1.需要继承 <code>ChannelInboundHandlerAdapter</code> 类；</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="comment">//业务处理   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        2.重写几个核心的方法，其中 channelRead () 是业务逻辑编写，使用最多；</p><table><thead><tr><th align="left">方法名称</th><th align="left">触发时机</th><th align="left">常见业务场景</th></tr></thead><tbody><tr><td align="left">channelActive</td><td align="left">连接就绪时触发</td><td align="left">连接时进行登录认证</td></tr><tr><td align="left">channelRead</td><td align="left">通道有数据可读取时触发</td><td align="left">读取数据并且做处理，这个是用的最多的方法</td></tr><tr><td align="left">channelInactive</td><td align="left">连接断开时触发</td><td align="left">连接断开，删除服务端对于的 Session 关系；也可以在这里实现断开重新</td></tr><tr><td align="left">exceptionCaught</td><td align="left">发生异常时触发</td><td align="left">发生日常时，做日志记录</td></tr></tbody></table><p>​        3.把 Handler 添加到 Pipeline 管道里面</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自定义业务 Handler</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> TestHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><h3 id="服务端启动类"><a href="#服务端启动类" class="headerlink" title="服务端启动类"></a>服务端启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程组-主要是监听客户端请求</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//线程组-主要是处理具体业务</span></span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="comment">//启动类</span></span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        serverBootstrap</span><br><span class="line">            <span class="comment">//指定线程组</span></span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">            <span class="comment">//指定 NIO 模式</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">            <span class="comment">//双向链表管理</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//责任链，指定自定义处理业务的 Handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//绑定端口号</span></span><br><span class="line">        serverBootstrap.bind(<span class="number">80</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>以上都是模板代码，需要变动的是根据不同的业务自定义对应的 Handler，并且在 initChannel () 添加逻辑处理器；</li><li>根据实际情况指定 bind () 方法的端口号，注意的是端口号不能和其它端口号冲突；</li><li>这里大家先熟练掌握模板代码的编写，后面章节会讲解 NioEventLoopGroup、Pipeline 等核心组件的原理。</li></ol><h3 id="自定义-Handler"><a href="#自定义-Handler" class="headerlink" title="自定义 Handler"></a>自定义 Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接受客户端端响应时触发该事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//转换为 ByteBuf 缓冲区（底层是 byte[] 数组）</span></span><br><span class="line">        ByteBuf buffer=(ByteBuf)msg;</span><br><span class="line">        <span class="comment">//定义一个 byte[] 数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[buffer.readableBytes()];</span><br><span class="line">        <span class="comment">//缓冲区把数据写到 byte[] 数组</span></span><br><span class="line">        buffer.readBytes(bytes);</span><br><span class="line">        <span class="comment">//把 byte[] 转换字符串</span></span><br><span class="line">        String req=<span class="keyword">new</span> String(bytes,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端请求：&quot;</span>+req);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//给客户端响应信息&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line">        String res=res + <span class="string">&quot;&gt;&gt;&gt;&gt;Client&quot;</span>;</span><br><span class="line">        <span class="comment">//把字符串转换 ByteBuf</span></span><br><span class="line">        ByteBuf buf=getByteBuf(ctx,res);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//把 ByteBuf 写到通道并且刷新</span></span><br><span class="line">        ctx.writeAndFlush(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ByteBuf <span class="title">getByteBuf</span><span class="params">(ChannelHandlerContext ctx,String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取二进制抽象 ByteBuf</span></span><br><span class="line">        ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 2. 准备数据，指定字符串的字符集为 utf-8</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes(Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        <span class="comment">// 3. 填充数据到 ByteBuf</span></span><br><span class="line">        buffer.writeBytes(bytes);</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>这个逻辑处理器继承自 ChannelInboundHandlerAdapter，然后覆盖了 channelRead () 方法；</li><li>channelRead () 方法，接受客户端请求数据时会触发该方法，一般是用来处理具体的业务；</li><li>Netty 是面向 ByteBuf 通讯的，接受数据和响应数据都需要转换 ByteBuf，ByteBuf 的 API 后面再详细讲解，这里我们需要知道的是常见创建 ByteBuf 有常见两种方式，①通过 Unpooled 非池化工具类来操作；②通过 <code>ctx.alloc().buffer()</code> 来获取。最后我们调用 <code>ctx.channel().writeAndFlush()</code> 把数据写到服务端。</li></ol><h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><h3 id="客户端启动类"><a href="#客户端启动类" class="headerlink" title="客户端启动类"></a>客户端启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap</span><br><span class="line">                <span class="comment">// 1.指定线程模型</span></span><br><span class="line">                .group(workerGroup)</span><br><span class="line">                <span class="comment">// 2.指定 IO 类型为 NIO</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">// 3.IO 处理逻辑</span></span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//自定义业务 Handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 4.建立连接</span></span><br><span class="line">        ChannelFuture future=bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">80</span>).sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>以上都是模板代码，需要变动的是根据不同的业务自定义对应的 Handler，并且在 initChannel () 添加逻辑处理器；</li><li>connect () 方法，指定对应服务端 ip 和 port。</li></ol><h3 id="自定义-Handler-1"><a href="#自定义-Handler-1" class="headerlink" title="自定义 Handler"></a>自定义 Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//客户端连接成功之后触发该事件，只会触发一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;Hello World&quot;</span>.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受服务端响应时触发该事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buffer=(ByteBuf)msg;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[buffer.readableBytes()];</span><br><span class="line">        buffer.readBytes(bytes);</span><br><span class="line">        String res=<span class="keyword">new</span> String(bytes,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端响应：&quot;</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>这个逻辑处理器继承自 ChannelInboundHandlerAdapter，然后覆盖了 channelActive () 和 channelRead () 方法；</li><li>channelActive ()，这个方法会在客户端连接建立成功之后被调用，可以在这个方法里面，做一些初始化的工作，该方法仅被调用一次；</li><li>channelRead 方法，在接受客户端响应时触发，会触发多次。</li></ol><h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p>服务端打印：</p><p><img src="https://s2.loli.net/2021/12/24/mT1bDvjf9aAOSR5.png" alt="图片描述"></p><p>客户端打印：</p><p><img src="https://s2.loli.net/2021/12/24/koMihO8FGpaq2DX.png" alt="图片描述"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过以上的代码，我们主要实现了客户端和服务端之间的通讯，需要掌握以下关键点：</p><ol><li>客户端和服务端的启动类代码，这个基本上是固定写法；</li><li>掌握 Handler 的作用以及如何自定义，几个核心方法的触发时机以及常见的应用场景；</li><li>和传统的 socket 编程不同的是，Netty 里面数据是以 ByteBuf 为单位的。</li></ol><h1 id="Bootstrap-客户端端启动类"><a href="#Bootstrap-客户端端启动类" class="headerlink" title="Bootstrap 客户端端启动类"></a>Bootstrap 客户端端启动类</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>之前的Netty入门案例，其中无论是客户端还是服务端的代码编写，都是分为 2 个核心步骤，分别是：启动类模板代码 + 自定义业务 Handler，其中 Handler 可以根据不同的业务定义多个。</p><p>本节主要介绍 Bootstrap 客户端启动类的代码含义。</p><h2 id="Bootstrap-流程"><a href="#Bootstrap-流程" class="headerlink" title="Bootstrap 流程"></a>Bootstrap 流程</h2><p>客户端启动类的写法都是固定模板的写法，需要掌握几个核心的流程，有助于理解模板代码，具体如下：</p><ol><li><strong>指定线程模型：</strong> 通过<code>.group(group)</code> 给引导类配置线程组，这个引导类的线程模型也就定型了。每个通道，也就是 Channel 都需要绑定一个线程，该线程是线程池分配的线程，专门负责处理相关 Handler；</li><li><strong>指定 IO 模型：</strong> 我们通过<code>.channel(NioServerSocketChannel.class)</code> 来指定 NIO 模型。如果指定 IO 模型为 BIO，那么这里配置上 <code>OioServerSocketChannel.class</code> 类型即可，通常都是使用 NIO，因为 Netty 的优势就在于 NIO；</li><li><strong>指定处理逻辑器：</strong> 通过 childHandler () 方法，给这个引导类创建一个 ChannelInitializer，这里主要就是管理自定义 Handler，最终把这些 Handler 组装成一条双向链表，Channel 有事件时则触发链表进行业务处理逻辑；</li><li><strong>连接服务端：</strong>，调用 connect () 连接服务端，需要传递两个参数，分别是服务端的 IP 地址和端口号。</li></ol><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">group()</td><td align="left">指定线程模型</td></tr><tr><td align="left">channel()</td><td align="left">指定 IO 模型</td></tr><tr><td align="left">attr()</td><td align="left">给客户端 Channel 设置自定义属性</td></tr><tr><td align="left">handler()</td><td align="left">给客户端 Channel 指定处理逻辑 Handler</td></tr><tr><td align="left">option()</td><td align="left">给客户端 Channel 设置底层 TCP 的属性</td></tr><tr><td align="left">connect()</td><td align="left">连接服务端，返回 ChannelFuture</td></tr></tbody></table><p>需要指定每个方法的功能是什么，下面将讲解其具体使用。</p><p><img src="https://s2.loli.net/2021/12/24/gsl2mRe6YE8h4iZ.png" alt="图片描述"></p><h2 id="核心方法详解"><a href="#核心方法详解" class="headerlink" title="核心方法详解"></a>核心方法详解</h2><h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p>connect () 用来连接服务端，常见的运用场景主要有三点，分别是①监听连接结果；②失败重连；③断开重连。</p><h4 id="连接监听"><a href="#连接监听" class="headerlink" title="连接监听"></a>连接监听</h4><p>connect () 方法返回的是 ChannelFuture，也就是说不需要等待连接成功或失败才往下执行代码，后期可以监听连接结果。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.连接Netty服务端</span></span><br><span class="line">ChannelFuture future=bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.监听连接结果</span></span><br><span class="line">future.addListener(future -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;连接失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结，这种模式的好处是，连接是异步的，无需等待连接响应代码才会往下执行。</p><h4 id="失败重连"><a href="#失败重连" class="headerlink" title="失败重连"></a>失败重连</h4><p>在网络情况差的情况下，客户端第一次连接可能会连接失败，这个时候我们可能会尝试重新连接，具体实现如下：</p><p><strong>方案一：</strong> 通过 ChannelFuture 的返回状态来监听连接是否成功。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Bootstrap bootstrap, String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    bootstrap.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;连接失败，开始重连&quot;</span>);</span><br><span class="line">            <span class="comment">//递归调用连接方法</span></span><br><span class="line">            connect(bootstrap, host, port);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方案二：</strong> 避免短时间内频繁的请求连接，可以使用定时线程池来每隔 n 秒重连一次。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Bootstrap bootstrap, String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    bootstrap.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取EventLoopGroup</span></span><br><span class="line">            EventLoopGroup thread=bootstrap.config().group();</span><br><span class="line">            <span class="comment">//每隔5秒钟重连一次</span></span><br><span class="line">            thread.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    connect(bootstrap, host, port)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong><br><code>bootstrap.config().group()</code> 获取的 EventLoopGroup，它是一个线程池，线程池里面有一个叫定时线程池。</p><h3 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h3><p>attr () 方法可以给客户端 Channel 初始属性，也就是 NioSocketChannel 绑定自定义属性，然后我们可以通过 <code>channel.attr()</code> 取出这个属性。其实就是给 NioSocketChannel 维护一个 map。</p><p>给 Channel 绑定属性。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略其它代码，只保留核心部分</span></span><br><span class="line">bootstrap.attr(AttributeKey.newInstance(<span class="string">&quot;token&quot;</span>), <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p>取出 Channel 所绑定的属性。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//客户端启动的时候，触发事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取Channel的绑定的属性值</span></span><br><span class="line">        AttributeKey&lt;String&gt; key=AttributeKey.valueOf(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        String value=ctx.channel().attr(key).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过以上代码，我们介绍了 attr () 如何绑定属性和取出属性。</p><h3 id="option"><a href="#option" class="headerlink" title="option()"></a>option()</h3><p>可以通过 option () 方法可以给连接设置一些 TCP 底层相关的属性，以下是常见的三种 TCP 属性设置。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略其它代码，只保留核心部分</span></span><br><span class="line">bootstrap</span><br><span class="line">        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">        .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">        .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li><code>ChannelOption.CONNECT_TIMEOUT_MILLIS</code> 表示连接的超时时间，超过这个时间还是建立不上的话则代表连接失败；</li><li><code>ChannelOption.SO_KEEPALIVE</code> 表示是否开启 TCP 底层心跳机制，true 为开启；</li><li><code>ChannelOption.TCP_NODELAY</code> 表示是否开始 Nagle 算法，true 表示关闭，false 表示开启，通俗地说，如果要求高实时性，有数据发送时就马上发送，就设置为 true 关闭，如果需要减少发送次数减少网络交互，就设置为 false 开启。</li></ol><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本节的学习，主要介绍了 Netty 客户端启动类 Bootstrap 的使用讲解，需要掌握的核心知识点如下：</p><ol><li>了解 Bootstrap 的核心步骤，分别是是①指定线程模型；②指定 IO 模型；③指定业务逻辑处理器；④连接服务器；</li><li>掌握 Bootstrap 的几个核心方法的功能及用法。</li></ol><h1 id="ServerBootstrap-服务端启动类"><a href="#ServerBootstrap-服务端启动类" class="headerlink" title="ServerBootstrap 服务端启动类"></a>ServerBootstrap 服务端启动类</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲解服务端主启动类 ServerBootstrap 的核心 API 的使用。</p><h2 id="ServerBootstrap-流程"><a href="#ServerBootstrap-流程" class="headerlink" title="ServerBootstrap 流程"></a>ServerBootstrap 流程</h2><p>ServerBootstrap 的用法基本上都是固定的，一般对于新接触 Netty 的同学来说，会觉得这些模板代码比较多，难以理解。我们主要记住几个核心配置即可。</p><ol><li><strong>指定线程模型：</strong> 通过<code>.group(bossGroup, workerGroup)</code> 给引导类配置两大线程组，这个引导类的线程模型也就定型了。其中 bossGroup 表示监听端口，accept 新连接的线程组；workerGroup 表示处理每一条连接的数据读写的线程组；</li><li><strong>指定 IO 模型：</strong> 通过<code>.channel(NioServerSocketChannel.class)</code> 来指定 NIO 模型。如果指定 IO 模型为 BIO，那么这里配置上 <code>OioServerSocketChannel.class</code> 类型即可，通常都是使用 NIO，因为 Netty 的优势就在于 NIO；</li><li><strong>指定处理逻辑：</strong> 通过 childHandler () 方法，给这个引导类创建一个 ChannelInitializer，这里主要就是定义后续每条连接的数据读写，业务处理逻辑；</li><li><strong>绑定端口号：</strong> 调用 bind (80)，端口号自定义，不要和其他应用的端口号有冲突即可。</li></ol><h2 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h2><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">group()</td><td align="left">用来指定线程模型</td></tr><tr><td align="left">channel()</td><td align="left">用来指定 IO 模型</td></tr><tr><td align="left">handler()</td><td align="left">用来指定服务端通道需要处理的业务逻辑（了解）</td></tr><tr><td align="left">childHandler()</td><td align="left">用来指定客户端通道需要处理的业务逻辑（掌握）</td></tr><tr><td align="left">attr()</td><td align="left">给服务端通道绑定自定义属性（了解）</td></tr><tr><td align="left">childAttr()</td><td align="left">给客户端通道绑定自定义属性（掌握）</td></tr><tr><td align="left">option()</td><td align="left">给服务端通道设置配置（了解）</td></tr><tr><td align="left">childOption()</td><td align="left">给客户端通道设置配置（了解）</td></tr><tr><td align="left">bind()</td><td align="left">用来绑定端口号</td></tr></tbody></table><blockquote><p>说明：客户端和服务端连接之后，会维持一个 Channel 通道，可以给其指定逻辑处理器和属性配置；当然，服务端启动的时候它也是一个特殊的 Channel 通道。</p></blockquote><p>在开发当中，需要我们去自定义的方法主要是 childHandler () 和 childAttr () 这两个。childHandler () 用来绑定业务逻辑器，childAttr () 用来设置 Channel 属性。比如：绑定用户身份信息。其它方法的使用相对固定，了解即可。</p><p><img src="https://s2.loli.net/2021/12/24/CNQU4i8EO9kFxdp.png" alt="图片描述"></p><h2 id="核心方法详解-1"><a href="#核心方法详解-1" class="headerlink" title="核心方法详解"></a>核心方法详解</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>bind () 主要用来绑定本地端口号。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future=serverBootstrap.bind(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">future.addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> Void&gt; future)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;端口绑定成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;端口绑定失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码升级，如果绑定的端口已经存在，则端口号递增。当然，实际情况很少会去递增端口号，一般都是上线之前确定端口号，否则客户端不知道端口号，无法连接。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ServerBootstrap serverBootstrap, <span class="keyword">final</span> <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    ChannelFuture future=serverBootstrap.bind(port);</span><br><span class="line">    future.addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> Void&gt; future)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;端口[&quot;</span> + port + <span class="string">&quot;]绑定成功!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;端口[&quot;</span> + port + <span class="string">&quot;]绑定失败!&quot;</span>);</span><br><span class="line">                <span class="comment">//递归重新绑定端口号</span></span><br><span class="line">                bind(serverBootstrap, port + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="attr-1"><a href="#attr-1" class="headerlink" title="attr()"></a>attr()</h3><p>attr () 方法可以给服务端的 channel，也就是 <code>NioServerSocketChannel</code> 指定一些自定义属性，可以通过 <code>channel.attr()</code> 取出这个属性。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略了其它模板代码</span></span><br><span class="line">serverBootstrap.attr(AttributeKey.newInstance(<span class="string">&quot;serverName&quot;</span>), <span class="string">&quot;nettyServer&quot;</span>)</span><br></pre></td></tr></table></figure><p>总结，一般来说 attr () 运用的比较少，了解即可。</p><h3 id="childAttr"><a href="#childAttr" class="headerlink" title="childAttr()"></a>childAttr()</h3><p>childAttr 可以给每一条连接指定自定义属性，可以通过 <code>channel.attr()</code> 取出该属性。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略了其它模板代码</span></span><br><span class="line">serverBootstrap.childAttr(AttributeKey.newInstance(<span class="string">&quot;clientKey&quot;</span>), <span class="string">&quot;clientValue&quot;</span>)</span><br></pre></td></tr></table></figure><p>总结，常见的运用场景，客户端登录成功之后，给其对应的 Channel 绑定标识，下次只需要判断该 Channel 是否有标识即可知道其是否已经登录。</p><h2 id="handler"><a href="#handler" class="headerlink" title="handler()"></a>handler()</h2><p>handler () 用于指定在服务端启动过程中的一些逻辑。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略了其它模板代码</span></span><br><span class="line">serverBootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;NioServerSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioServerSocketChannel ch)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结，可以在服务端启动的过程中做一些初始化方面的工作，比如，读取数据库的配置数据放到缓存当中，这个作为了解即可。</p><h3 id="childHandler"><a href="#childHandler" class="headerlink" title="childHandler()"></a>childHandler()</h3><p>childHandler () 用于指定处理新连接数据的读写处理逻辑。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略了其它模板代码</span></span><br><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//责任链，指定自定义处理业务的 Handler</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结，这个是核心，主要管理业务逻辑处理双向链表，后面会具体讲解</p><h3 id="option-1"><a href="#option-1" class="headerlink" title="option()"></a>option()</h3><p>option () 给服务端 channel 设置一些属性，最常见的就是 so_backlog。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略了其它模板代码</span></span><br><span class="line">serverBootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>表示系统用于临时存放已完成三次握手的请求的队列的最大长度，如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数。其实，客户端请求在服务端也是排队执行的，服务端的两大线程组分别监听客户端连接和处理客户端连接，一旦并发量很高的时候，服务端处理不过来，则会把等待处理的请求放入到临时队列里面，这个跟 Java 线程池的思想是一样的。</p><h3 id="childOption"><a href="#childOption" class="headerlink" title="childOption()"></a>childOption()</h3><p>childOption () 给每条连接设置一些 TCP 底层相关的属性。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略了其它模板代码</span></span><br><span class="line">serverBootstrap</span><br><span class="line">        .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">        .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">代码块<span class="number">1234</span></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li><code>ChannelOption.SO_KEEPALIVE</code> 表示是否开启 TCP 底层心跳机制，true 为开启；</li><li><code>ChannelOption.TCP_NODELAY</code> 表示是否开启 Nagle 算法，true 表示关闭，false 表示开启，通俗地说，如果要求高实时性，有数据发送时就马上发送，就关闭，如果需要减少发送次数减少网络交互，就开启。</li></ol><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>本节学习的核心知识点掌握，具体如下：</p><ol><li>四个核心流程，分别是①设置线程组；②设置 IO 模型；③指定连接读写处理逻辑；④绑定端口号；</li><li>核心方法的使用场景，重点掌握①bind ()；②childAttr ()；③childHandler ()；④childOption () 的使用。</li></ol><h1 id="ChannelFuture-异步监听"><a href="#ChannelFuture-异步监听" class="headerlink" title="ChannelFuture 异步监听"></a>ChannelFuture 异步监听</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲解 ChannelFuture ，它的作用是用来保存 Channel 异步操作的结果，可以看作是一个异步操作结果的占位符。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在 Netty 中所有的 IO 操作都是异步的，不能立刻得到 IO 操作的执行结果，但是可以通过注册一个监听器来监听其执行结果。在 Java 的并发编程当中可以通过 Future 来进行异步结果的监听，但是在 Netty 当中是通过 ChannelFuture 来实现异步结果的监听。通过注册一个监听的方式进行监听，当操作执行成功或者失败时监听会自动触发注册的监听事件。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>ChannelFuture 在开发当中经常需要用到，可以用来监听客户端连接服务端的结果反馈，Netty 是异步操作，无法知道什么时候执行完成，因此可以通过 ChannelFuture 来进行执行结果的监听。在 Netty 当中 Bind 、Write 、Connect 等操作会简单的返回一个 ChannelFuture。</p><h2 id="核心方法-2"><a href="#核心方法-2" class="headerlink" title="核心方法"></a>核心方法</h2><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">addListener</td><td align="left">注册监听器，当操作已完成 (isDone 方法返回完成)，将会通知指定的监听器；如果 Future 对象已完成，则通知指定的监听器</td></tr><tr><td align="left">2</td><td align="left">removeListener</td><td align="left">移除监听器</td></tr><tr><td align="left">3</td><td align="left">sync</td><td align="left">等待异步操作执行完毕</td></tr><tr><td align="left">4</td><td align="left">await</td><td align="left">等待异步操作执行完毕</td></tr><tr><td align="left">5</td><td align="left">isDone</td><td align="left">判断当前操作是否完成</td></tr><tr><td align="left">6</td><td align="left">isSuccess</td><td align="left">判断已完成的当前操作是否成功</td></tr><tr><td align="left">7</td><td align="left">isCancellable</td><td align="left">判断已完成的当前操作是否被取消</td></tr><tr><td align="left">8</td><td align="left">cause</td><td align="left">获取已完成的当前操作失败的原因</td></tr></tbody></table><p>sync () 和 await () 都是等待异步操作执行完成，那么它们有什么区别呢？</p><ol><li>sync () 会抛出异常，建议使用 sync ()；</li><li>await () 不会抛出异常，主线程无法捕捉子线程执行抛出的异常。</li></ol><h2 id="深入了解-ChannelFuture"><a href="#深入了解-ChannelFuture" class="headerlink" title="深入了解 ChannelFuture"></a>深入了解 ChannelFuture</h2><h3 id="生命周期说明"><a href="#生命周期说明" class="headerlink" title="生命周期说明"></a>生命周期说明</h3><p>Future 可以通过四个核心方法来判断任务的执行情况。</p><table><thead><tr><th align="left">状态</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">isDone()</td><td align="left">任务是否执行完成，无论成功还是失败</td></tr><tr><td align="left">isSuccess()</td><td align="left">任务是否执行采购</td></tr><tr><td align="left">isCancelled()</td><td align="left">任务是否被取消</td></tr><tr><td align="left">cause()</td><td align="left">获取执行异常信息</td></tr></tbody></table><p>执行过程状态的改变说明</p><p>当一个异步任务操作开始的时候，一个新的 future 对象就会被创建。在开始的时候该 future 是处于未完成的状态，也就是说，isDone ()=false、isSuccess ()=false、isCancelled ()=false；只要该任务中任何一种状态结束了，无论是说成功、失败、或者被取消，那么整个 Future 就会被标记为<strong>已完成</strong>。注意的是，如果执行失败那么 cause () 方法会返回异常信息的内容。</p><p><img src="https://s2.loli.net/2021/12/24/blQkcn5Ui3aVK1x.png" alt="图片描述"></p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture channelFuture=bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">80</span>);</span><br><span class="line">channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(future.isDone())&#123;</span><br><span class="line">            <span class="keyword">if</span>(future.isSuccess())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行成功...&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(future.isCancelled())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务被取消...&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(future.cause()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行出错：&quot;</span>+future.cause().getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ChannelFuture-父接口说明"><a href="#ChannelFuture-父接口说明" class="headerlink" title="ChannelFuture 父接口说明"></a>ChannelFuture 父接口说明</h3><p>ChannelFuture 的类继承结构，具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面的继承关系，我们可以清晰的知道 ChannelFuture 其实最顶层的接口是来自 java 并发包的 Future，java 并发包下的 Future 需要手工检查执行结果是否已经完成，非常的繁琐，因此 Netty 把它进行了封装和完善，变成了自动的监听，用起来变的非常的简单。</p><p>java 并发包下的 Future 主要存在以下几个缺陷：</p><ol><li>只允许手动通过 get () 来检查对应的操作是否已经完成，它是堵塞直到子线程完成执行并且返回结果；</li><li>只有 isDone () 方法判断一个异步操作是否完成，但是对于完成的定义过于模糊，JDK 文档指出正常终止、抛出异常、用户取消都会使 isDone () 方法返回真。并不能很好的区分到底是哪种状态。</li></ol><p>get () 方法是堵塞的，必须等待<strong>子线程</strong>执行完成才能往下执行。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义一个子线程，实现 Callable 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;子线程休眠之前&quot;</span>);</span><br><span class="line">    <span class="comment">//休眠5秒</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;子线程休眠之后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.调用子线程处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ThreadTest t=<span class="keyword">new</span> ThreadTest();</span><br><span class="line">    FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(t);</span><br><span class="line">    <span class="comment">//2.1.开始执行子线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(future).start();</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//2.2.手工返回结果</span></span><br><span class="line">    <span class="keyword">int</span> result=future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;执行结果：&quot;</span>+result);</span><br><span class="line">    <span class="comment">//2.3.操作数据库</span></span><br><span class="line">    userDao.updateStatus(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;子线程休眠之前</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;子线程休眠之后</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;执行结果：<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结论总结：</p><ol><li>说明了 Java 并发包的 Future 要想获取异步执行结果，必须手工调用 get () 方法，此时虽然能获取执行结果，但是无法知道执行结果是成功还是失败；</li><li>使用 get () 获取执行结果，但是 get () 后面的业务则被堵塞，直到后面执行完毕才会往下执行，失去了异步操作提高执行效率的意义了。</li></ol><h2 id="ChannelFuture-原理"><a href="#ChannelFuture-原理" class="headerlink" title="ChannelFuture 原理"></a>ChannelFuture 原理</h2><h3 id="线程堵塞"><a href="#线程堵塞" class="headerlink" title="线程堵塞"></a>线程堵塞</h3><blockquote><p>思考：sync () 和 await () 方法如何同步等待执行完成并获取执行结果的呢？</p></blockquote><p>源码分析如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">short</span> waiters;<span class="comment">//计数器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//1.判断是否执行完成，如果执行完成则返回</span></span><br><span class="line">    <span class="keyword">if</span> (isDone()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.线程是否已经中断，如果中断则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.检查死锁</span></span><br><span class="line">    checkDeadLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.同步代码块-&gt;while循环不断的监听执行结果</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">            incWaiters();<span class="comment">//waiters递增</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();<span class="comment">//JDK 的 Object 方法，线程等待【核心】</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                decWaiters();<span class="comment">//waiters 递减</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递增函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (waiters == Short.MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;too many waiters: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ++waiters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递减函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    --waiters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过以上代码，我们发现 await () 的核心其实就是调用 Object 的 wait () 方法进行线程休眠，普通的 Java 多线程知识点。</p><h3 id="线程唤醒"><a href="#线程唤醒" class="headerlink" title="线程唤醒"></a>线程唤醒</h3><blockquote><p>思考：当前线程休眠了，那么什么时候进行唤醒呢？</p></blockquote><p>源码分析如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.setSuccess0 赋值操作</span></span><br><span class="line">    <span class="keyword">if</span> (setSuccess0(result)) &#123;</span><br><span class="line">        <span class="comment">//2.通知执行监听器</span></span><br><span class="line">        notifyListeners();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;complete already: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setSuccess0</span><span class="params">(V result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续进入方法</span></span><br><span class="line">    <span class="keyword">return</span> setValue0(result == <span class="keyword">null</span> ? SUCCESS : result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setValue0</span><span class="params">(Object objResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, objResult) ||</span><br><span class="line">        RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, UNCANCELLABLE, objResult)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//继续进入方法</span></span><br><span class="line">        checkNotifyWaiters();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkNotifyWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (waiters &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//核心：唤醒之前休眠的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源码分析总结：</p><ol><li>堵塞的核心是通过 Object.wait () 方法进行休眠当前线程，普通的 Java 多线程知识；</li><li>执行完成之后给不同状态（setSuccess、setFailure）赋值的时候唤醒休眠的线程；</li><li>唤醒线程之后调用监听器的方法 <code>l.operationComplete(future);</code></li></ol><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>通过本节的学习，我们需要掌握以下几个核心知识点：</p><ol><li>掌握异步的概念，传统 I/O 是同步堵塞的，执行 I/O 操作后线程会被阻塞住，直到操作完成；异步处理的好处是不会造成线程阻塞，可以通过 Future 来监听异步执行的结果；</li><li>ChannelFuture 的几种状态，以及它的值变化时机；</li><li>ChannelFuture 的堵塞和唤醒源码分析。</li></ol><h1 id="Netty-核心组件"><a href="#Netty-核心组件" class="headerlink" title="Netty 核心组件"></a>Netty 核心组件</h1><h2 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h2><p>本节我们主要从整体上了解 Netty 有哪些核心组件，很多同学学习完 Netty 虽然会使用，但是只知道如何自定义 Handler 而已，根本不清楚 Netty 有哪些核心的组件。</p><p>本节的主要目的是，从整体上概括 Netty 的核心组件，有助于深入了解 Netty 以及关于 Netty 的面试。</p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>Netty 的核心模块组件主要分为以下：</p><table><thead><tr><th align="left">组件模块</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Boostrap</td><td align="left">Bootstrap 其实就是启动的意思，主要用来配置 Netty 的相关配置，串联各个组件，针对客户端。</td></tr><tr><td align="left">ServerBootstrap</td><td align="left">同上，只是它是针对服务端。</td></tr><tr><td align="left">线程模型</td><td align="left">了解 Reactor 线程模型。</td></tr><tr><td align="left">EventLoopGroup</td><td align="left">是一组 EventLoop 的抽象，可以简单理解就是线程池，一般分为 BossEventLoopGroup 和 WorkerEventLoopGroup。</td></tr><tr><td align="left">ChannelFuture</td><td align="left">Netty 的所有 IO 操作都是异步的，通过注册监听器来监听执行结果的返回。</td></tr><tr><td align="left">Channel</td><td align="left">Netty 的网络通信组件，客户端和服务端建立连接之后会维持一个 Channel。</td></tr><tr><td align="left">ChannelHandlerContext</td><td align="left">保存 Channel 对于的上下文，同时关联一个 ChannelHandler 对象。</td></tr><tr><td align="left">ChannelHandler</td><td align="left">自定义业务 Handler 需要实现它或它的子类，提供了一套生命周期的方法。</td></tr><tr><td align="left">ChannelPipeline</td><td align="left">ChannelPipeline 可认为是一个管道，是管理业务 Handler，通俗理解是保存 ChannelHandler 的 List 集合。</td></tr><tr><td align="left">ByteBuf</td><td align="left">ByteBuf 是一个字节容器，提供了常见 api。Netty 是面向 ByteBuf 来传输数据的。</td></tr><tr><td align="left">编码和解码</td><td align="left">Netty 内置了常见编解码器，我们也可以自定义自己的编解码器。并且可以把编解码器封装成独立的 Handler，简化繁琐的流程。</td></tr><tr><td align="left">拆包和粘包问题</td><td align="left">了解为什么会出现拆包和粘包问题，如何去解决它，以及 Netty 内置了常见的拆包器。</td></tr></tbody></table><p>总结，以上组件（或者知识点）是 Netty 知识体系里面的核心，并且也是面试当中经常问的内容，有的只需要配置一下即可，很少需要我们去管（如：EventLoopGroup）；有的需要我们去自定义扩展。</p><p><strong>核心组件架构图：</strong><br><img src="https://s2.loli.net/2021/12/24/PkAcj3dK9mHEzXw.png" alt="图片描述"></p><p>在真实开发当中，需要我们去解决的问题，主要如下：</p><ol><li>使用 ChannelPipeline 管理自定义 ChannelHandler；</li><li>业务实体和 ByteBuf 之间的转换；</li><li>借助第三方序列化技术、自定义通信协议规则、反射等，自定义编码和解码器，使用通用实体；</li><li>如何解决拆包和粘包问题，其发生的原因是什么，如果解决。</li></ol><h2 id="组件详解"><a href="#组件详解" class="headerlink" title="组件详解"></a>组件详解</h2><p>Netty 的它优势在于，它是配置化的开发，仅仅靠简单的配置，背后就能实现很复杂的逻辑。但是通常情况下我们很难去了解其背后的原理。下面我们主要挑选开发当中比较常见的组件进行讲解。</p><h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><p>ChannelHandler 是一个接口，处理 IO 事件，可以简单的理解它是一个链表当中的一个节点，它的 UML 图如下所示：<br><img src="https://s2.loli.net/2021/12/24/Ohl3Cnws1Grj7Pp.png" alt="图片描述"></p><p><strong>ChannelHandler 架构图说明：</strong></p><ol><li>ChannelHandler 两个子接口，分别是 ChannelInboundHandler 和 ChannelOutboundHandler；其中 ChannelInboundHandler 主要用于处理入站的 I/O 事件；ChannelOutboundHandler 用于处理出站的 I/O 事件；</li><li>ChannelInboundHandler 的实现类 ChannelInboundHandlerAdapter 处理入站 I/O 事件；</li><li>ChannelOutboundHandler 的实现类 ChannelOutboundHandlerAdapter 处理出站 I/O 事件；</li></ol><p>在开发当中，<code>ChannelInboundHandlerAdapter</code> 是使用最多的，其它很少直接使用。值得注意的是 I/O 入站和出站的执行顺序，这个跟 SpringMVC 的拦截器的执行顺序一样。</p><h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h3><p>ChannelPipeline 是一个比较核心的知识点，它底层设计是采用<strong>责任链设计模式</strong>，主要作用是管理 Handler 双向链表，包括入站和出站，主要是拦截 inboud 和 outbound 事件，然后每个 handler 节点负责处理具体逻辑。<br><img src="https://s2.loli.net/2021/12/24/2UAQcS1EVftlLih.png" alt="图片描述"></p><p><strong>关系梳理：</strong></p><ol><li>一个客户端对应一个 Channel；</li><li>一个 Channel 对应一个 ChannelPipeline；</li><li>一个 ChannelPipeline 又维护了一个双向链表，其中链表的节点是 <code>ChannelHandlerContext</code>；</li><li>一个 <code>ChannelHandlerContext</code> 则关联一个 <code>ChannelHandler</code>（自定义 Handler）；</li><li>ChannelHandler 则是自定义 Handler 的一个顶级抽象接口。</li></ol><p><strong>入站和出站的顺序：</strong></p><ol><li><strong>入站：</strong> 事件会从链表的头部一直往后执行，<code>ChannelInboundHandlerAdapter</code> 子类会被触发；</li><li><strong>出站：</strong> 事件会从链表的尾部一直往前执行，<code>ChannelOutboundHandlerAdapter</code> 子类会被触发。</li></ol><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>本节内容，主要让大家从整体上了解 Netty 有哪些核心的组件构成，每个主要的作用是什么，主要是方便后面章节深入学习。其中，核心掌握 ChannelHandler 和 ChannelPipeline 这两个组件，平时开发当中涉及比较多的就是这两个组件。</p><ol><li>掌握 ChannelHandler 的 UML 架构关系；</li><li>掌握入站和出站分别继承 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter；</li><li>掌握 ChannelPipeline 和 ChannelHandler 之间的关系；</li><li>掌握入站和出站的执行顺序。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty 心跳检测</title>
      <link href="posts/Netty%20%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/"/>
      <url>posts/Netty%20%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Netty-心跳检测"><a href="#Netty-心跳检测" class="headerlink" title="Netty 心跳检测"></a>Netty 心跳检测</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节，我们主要讲解心跳机制 heartbeat，Netty 给我们提供了三个 Handler，分别是 <code>IdleStateHandler</code>、<code>ReadTimeoutHandler</code>、<code>WriteTimeoutHandler</code>，主要目的是检查对方是否有效，也就是说对方是否还在线。</p><h2 id="为什么需要心跳机制"><a href="#为什么需要心跳机制" class="headerlink" title="为什么需要心跳机制"></a>为什么需要心跳机制</h2><p><strong>了解 TCP：</strong> TCP 协议适用于客户端数量相对比较少，并且通信频繁的业务场景；Http 协议则适用于客户端数量比较大的业务场景。因为 Http 是短连接，请求完成即会释放连接资源，不再占用服务器资源，但是，TCP 则不会，连接成功，则可以多次请求，不会释放，除非特殊原因导致连接断开。</p><p><strong>面临问题：</strong> 既然长连接是不会释放连接资源，那么如果很多客户端只是完成了连接，但是并没有实际的业务请求操作，那么服务器的资源还是被占用，导致服务器性能下降。</p><p><strong>解决办法：</strong> 把那些长期占用连接资源，但是并没有实际业务操作的连接断开掉，等它们需要做业务操作的时候，再重连服务器。这样可以达到即使释放没用的资源，提高服务器的性能。</p><p>总结，心跳机制主要有以下两个方面的作用</p><ol><li>定时剔除哪些没用的连接，减轻服务端的压力；</li><li>适用于中间件（比如：RPC 框架），服务端规定时间内没用收到客户端的心跳数据，则可以认为其宕机，服务端剔除对于的映射关系。</li></ol><p><img src="https://s2.loli.net/2021/12/24/LHCX8mcSj7R5Jik.png" alt="图片描述"></p><h2 id="三个核心类讲解"><a href="#三个核心类讲解" class="headerlink" title="三个核心类讲解"></a>三个核心类讲解</h2><p>为了实现以上需求，Netty 给我们提供了几个特殊的 Handler 类。</p><table><thead><tr><th align="left">名称</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">IdleStateHandler</td><td align="left">当连接空闲时间（读或写）太长时，将触发 IdleStateEvent 事件，可以通过 ChannelInboundHandler 中重写 userEventTrigged 方法来处理该事件。</td></tr><tr><td align="left">ReadTimeoutHandler</td><td align="left">如果在指定的时间之内没有发生读事件，就会抛出这个异常，并且自动关闭连接。可以在 exectionCaught 方法中处理这个异常。</td></tr><tr><td align="left">WriteTimeoutHandler</td><td align="left">如果在指定的时间之内没有发生写事件，抛出次异常，并且关闭连接。可以在 exectionCaught 方法中处理这个异常。</td></tr></tbody></table><p>IdleStateHandler 构造函数说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* readerIdleTimeSeconds 读事件空闲时间，如果为0则表示禁用</span></span><br><span class="line"><span class="comment">* writerIdleTimeSeconds 写事件空闲时间，如果为0则表示禁用</span></span><br><span class="line"><span class="comment">* allIdleTimeSeconds 读写事件空闲时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">int</span> readerIdleTimeSeconds, <span class="keyword">int</span> writerIdleTimeSeconds, <span class="keyword">int</span> allIdleTimeSeconds)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：都是利用定时器调度任务完成。 IdleStateHandler 超时调用 handler 的 userEventTriggered 方法。ReadTimeOutHandler 超时抛出异常，调用 handler 的 exceptionCaught 方法，并且会关闭 channel。</p><h2 id="案例测试"><a href="#案例测试" class="headerlink" title="案例测试"></a>案例测试</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5秒钟没有读事件，则断开连接</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> ReadTimeoutHandler(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line"><span class="comment">//5秒钟没有写事件，则断开连接</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> WriteTimeoutHandler(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line"><span class="comment">//解码器</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line"><span class="comment">//编码器</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line"><span class="comment">//业务Handler</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> HeartBeanHandler());</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeanHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRead&gt;&gt;&gt;&quot;</span>+msg+<span class="string">&quot;&gt;&gt;&gt;&quot;</span>+ LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exceptionCaught&gt;&gt;&gt;&quot;</span>+cause.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端 1"></a>客户端 1</h3><p>实例：延迟 1 秒钟，每个 15 秒钟往服务端发送一次 <code>hello world</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channelFuture.channel().eventLoop().scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        channelFuture.channel().writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">15</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>服务端执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channelRead&gt;&gt;&gt;hello world&gt;&gt;&gt;<span class="number">2020</span>-<span class="number">07</span>-26T15:<span class="number">16</span>:<span class="number">08.893</span></span><br><span class="line">exceptionCaught&gt;&gt;&gt;<span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>客户端执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端关闭了</span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>客户端每隔 15 秒发送一次数据；</li><li>服务端如果 5 秒之内没有读写事件，则自动断开连接；</li><li>从时间设置上来看，客户端每次发送数据都是超时了，因此，连接会被断开。</li></ol><h3 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端 2"></a>客户端 2</h3><p>实例：延迟 1 秒钟，每个 3 秒钟往服务端发送一次 <code>hello world</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channelFuture.channel().eventLoop().scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        channelFuture.channel().writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>服务端执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channelRead&gt;&gt;&gt;hello world&gt;&gt;&gt;<span class="number">2020</span>-<span class="number">07</span>-26T15:<span class="number">15</span>:<span class="number">10.889</span></span><br><span class="line">channelRead&gt;&gt;&gt;hello world&gt;&gt;&gt;<span class="number">2020</span>-<span class="number">07</span>-26T15:<span class="number">15</span>:<span class="number">13.892</span></span><br><span class="line">channelRead&gt;&gt;&gt;hello world&gt;&gt;&gt;<span class="number">2020</span>-<span class="number">07</span>-26T15:<span class="number">15</span>:<span class="number">16.893</span></span><br><span class="line">channelRead&gt;&gt;&gt;hello world&gt;&gt;&gt;<span class="number">2020</span>-<span class="number">07</span>-26T15:<span class="number">15</span>:<span class="number">19.894</span></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>客户端每隔 3 秒发送一次数据；</li><li>服务端如果 5 秒之内没有读写事件，则自动断开；</li><li>从时间设置上来看，客户端每次发送数据的时间都在超时时间范围之内，因此，连接不会被断开。</li></ol><h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><p>ReadTimeoutHandler 和 WriteTimeoutHandler 既可以用于客户端，也可以用于服务端，或者两边同时使用。常见的业务场景如下所示：</p><p><strong>场景一：</strong> 如果是服务端往客户端推送消息（消息推送），则 WriteTimeoutHandler 用于服务端，ReadTimeoutHandler 用于客户端；<br><strong>场景二：</strong> 如果是客户端主动发起请求的业务（比如：IM），则 WriteTimeoutHandler 用于客户端，ReadTimeoutHandler 用于服务端。</p><h3 id="IdleStateHandler-的使用"><a href="#IdleStateHandler-的使用" class="headerlink" title="IdleStateHandler 的使用"></a>IdleStateHandler 的使用</h3><p>实例：管道中添加 IdleStateHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空闲检测</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">60</span>,<span class="number">45</span>,<span class="number">20</span>,TimeUnit.SECONDS));</span><br><span class="line"><span class="comment">// 业务Handler</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> HeartBeatHandler());</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节主要掌握的知识点</p><ol><li>为什么需要做心跳检测，以及它的常见作用，分别是：主动剔除无用连接减轻服务端压力、用于中间件的心跳检测；</li><li>Netty 提了三个核心类，分别是 <code>IdleStateHandler</code>、<code>ReadTimeoutHandler</code>、<code>WriteTimeoutHandler</code>，它们的作用以及使用方法。</li></ol><h1 id="Netty-断开重连"><a href="#Netty-断开重连" class="headerlink" title="Netty 断开重连"></a>Netty 断开重连</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>上节，我们主要讲解了 Netty 的心跳检测机制，其中核心目的是提高性能。本节我们主要讲解的是 Netty 长连接的稳定性。</p><h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><p>TCP 协议下，数据是可以双向传递，其实也就是全双工协议，通俗点来说就是长连接，只要客户端和服务端连接之后，双方可以正常通行，那么长连接是否存在什么不稳定性呢？</p><p>在长连接情况下，通常面临的情况就是网络问题，网络抖动造成的连接假死，举个例子：其实客户端和服务端的 TCP 连接已经断开，但是双方没有监听到，认为该连接仍然是有效的。</p><p>这样的问题会导致以下几个后果，如下所示：</p><ol><li>客户端往服务端发送消息时，由于连接已经断开，会导致请求超时，影响用户体验；</li><li>服务端往客户端推送消息时，由于连接已经断开，导致连接推送失败；</li><li>每条连接都消耗 cpu 和内存资源，大量的假死会导致服务器资源消耗，导致服务器卡顿甚至宕机。</li></ol><h2 id="连接面临问题及解决方案"><a href="#连接面临问题及解决方案" class="headerlink" title="连接面临问题及解决方案"></a>连接面临问题及解决方案</h2><p><img src="https://s2.loli.net/2021/12/24/nZfXKmJOpPlQeVI.png" alt="图片描述"></p><h2 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h2><h3 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h3><p>连接已经断开，但是程序没有捕捉的到，认为连接还存在，产生的原因大致如下：</p><ol><li>应用程序内部线程堵塞，导致数据读写也会堵塞；</li><li>网络抖动，数据丢包等，发送方一种发送不出数据，接收方也收不到数据，连接就一直的耗着；</li><li>公网相对内网来说不是很稳定，受到的干扰更多，故障的概率也会增大。</li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>问题：</strong> 服务端 5 秒钟没用读取数据事件，那么是否一定是假死呢？</p><p><strong>回答：</strong> 不一定，主要有两种情况，①连接假死；②连接空闲。</p><p><strong>针对连接假死的解决方案</strong></p><p>主要是通过心跳检测去监控，如果指定时间之内，服务端没有收到客户端的数据，则主动断开连接，杜绝了连接假死现象。</p><p><strong>针对连接空闲状态的解决方案</strong></p><p><strong>情况一：</strong> 如果对通信的实时性要求不高，并且对性能要求很高的情况，可以直接断开连接，等待有需要的时候，再重新连接（这个是上节已经讲解过了，适合客户端主动的业务场景，比如：IM）；<br><strong>情况二：</strong> 如果对通信的实时性要求很高，则不能断开连接（比如：消息推送），为了保证连接能够存活而不被心跳检测机制自动断开。</p><p>针对情况二的解决方案如下：</p><ol><li>定时发送空包，并且时间间隔小于心跳检测时间间隔，保证连接存活；</li><li>如果连接真的断开了，则客户端监听事件 channelInactive () 里面实现断开重连；</li></ol><p>总结，这种模式的好处有两点，①保证连接能够长时间存活，避免错过重要消息；②避免连接空闲时，频繁的断开和重连，浪费资源。</p><p>其中，心跳检测上节以及详细讲解了，这里主要讲解一下发送空包数据和断开重连如何实现。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="服务端心跳检测"><a href="#服务端心跳检测" class="headerlink" title="服务端心跳检测"></a>服务端心跳检测</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"><span class="comment">//5秒钟之内没有 读事件 则断开连接</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> ReadTimeoutHandler(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串解码器</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串编码器</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务Handler</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> HeartBeatHandler());</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><p>服务端主要是监听读事件，每隔 5 秒读取不到数据，则认为连接无效，主动断开连接。</p><h3 id="客户端定时发送空包"><a href="#客户端定时发送空包" class="headerlink" title="客户端定时发送空包"></a>客户端定时发送空包</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatTimerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//发送空包</span></span><br><span class="line">        scheduleSendHeartBeat(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleSendHeartBeat</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.executor().schedule(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive()) &#123;</span><br><span class="line">                <span class="comment">//发送空包（定义一个实体）</span></span><br><span class="line">                ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>借助 EventLoop 的定时线程池去实现每隔 3 秒钟发送一个空包；</li><li>空包数据，自定义一个实体即可；</li><li>主要的是空包的时间间隔（3s）一定要小于心跳监听的时间间隔（5s）。</li></ol><h3 id="客户端断开重连"><a href="#客户端断开重连" class="headerlink" title="客户端断开重连"></a>客户端断开重连</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串解码器</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line"><span class="comment">//字符串编码器</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line"><span class="comment">//业务Handler，需要传递“bootstrap”</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> ClientHandler(bootstrap));</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Bootstrap bootstrap;</span><br><span class="line">    ClientHandler(Bootstrap bootstrap)&#123;</span><br><span class="line">        <span class="keyword">this</span>.bootstrap=bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">80</span>).sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>连接断开时，客户端的 Handler 的 channelInactive () 会监听的到，在该方法里面实现断开重连；</li><li>Handler 必须传递 bootstrap。</li></ol><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本节主要讲解了基于心跳检测的基础上实现了空包发送和断开重连的功能，主要核心意图有两个</p><ol><li><strong>空包发送：</strong> 让连接能够长时间的存活，而避免空闲连接收到心跳检测的干扰；同时还避免了心跳检测导致的频繁的断开和重连，导致资源浪费；</li><li><strong>断开重连：</strong> 让连接一直在线，保证了连接的稳定性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序列化和反序列化到底有什么用呢？</title>
      <link href="posts/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>posts/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="序列化和反序列化有什么用"><a href="#序列化和反序列化有什么用" class="headerlink" title="序列化和反序列化有什么用"></a>序列化和反序列化有什么用</h1><p>序列化是对象实现Serializable接口，则可以自动被序列化了，那么到底为什么需要做序列化呢？</p><p>计算机底层传输是通过字节流的方式进行传输（也就是byte[]），那么我们的内容（字符串、自定义实体、文件等等）如果需要传输，则需要把这些内容转换成byte[]，这一过程其实就是序列化；反过来，如果想把byte[]转换成目标对象，这一过程其实就是反序列化。</p><p><strong>序列化和反序列化的常见场景：</strong><br>①网络传输，比如：Dubbo、Redis通讯传递数据等等<br>②磁盘IO传输，比如：本地文件-&gt;内存；内存-&gt;本地文件<br>③存储，数据的存储底层都是二进制的方式，因此数据的存取就需要进行序列化</p><p>讲到这里，我们应该能明白为什么Dubbo传递参数需要实现序列化接口了吧。<br>其实序列化和反序列化在我们的开发当中无处不在，只是我们很少去关注它的原理，因此感觉会特别的陌生，或者既熟悉又陌生。</p><h1 id="序列化和反序列化的规则"><a href="#序列化和反序列化的规则" class="headerlink" title="序列化和反序列化的规则"></a>序列化和反序列化的规则</h1><p>其实序列化和反序列化准确来说是一种规则，而不是某种具体的技术。通过制定某种规则，按照这种规则去把我们的数据安全的转换成byte[]；同时又能按照这种规则把byte[]转换成我们的数据，那么就可以把这种规则落地成技术实现并运用到项目当中。</p><p>在Java当中String类型的数据它自动实现序列化接口了，因此它是可以在网络中传输的。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, </span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, </span></span><br><span class="line"><span class="class">    <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">        <span class="keyword">return</span> StringCoding.encode(value, <span class="number">0</span>, value.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自定义的实体，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//get、set方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  User user=<span class="keyword">new</span> User();</span><br><span class="line">  <span class="comment">//发现自定义的实体没有getBytes()方法</span></span><br><span class="line">  <span class="comment">//byte[] bytes=user.getBytes();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思考：自定义实体没有getBytes()方法，那么怎么转换成byte[]呢？</p></blockquote><p><strong>方案一：</strong> 把实体转换成json格式的字符串，那么它最终就可以转换成byte[]了</p><ul><li>技术：通过Fastjson、Jackjson等框架把实体和json字符串进行互转</li><li>优点：序列化的结果可以肉眼能识别，并且比较轻量</li><li>缺点：序列化后的长度相对大</li><li>说明：相信大家在学习Redis的时候，如果保存的是对象，则使用RedisDeskTopManager远程连接发现是一堆看不懂的乱码，因此常常需要手工指定序列化格式。</li></ul><p><strong>方案二：</strong> 把实体转换成xml格式的字符串，那么它最终就可以转换成byte[]了</p><ul><li>技术：通过XStream把实体和xml字符串进行互转</li><li>优点：序列化的结果可以肉眼能识别，并且对实体的属性描述很清晰</li><li>缺点：序列化之后的结果占用字节数比较大</li></ul><p><strong>方案三：</strong> JDK自带的序列化，实体实现Serializable接口</p><ul><li>说明：实现序列化接口的时候，JDK默认会进行序列化和反序列化操作了，但是我们也可以自己自定义规则，具体如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//序列化的时候该方法会被执行</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span>&#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeObject(name);<span class="comment">//name参与序列化，age不参与序列化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//反序列化的时候该方法会被执行</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    name=(String)s.readObject();<span class="comment">//name参与序列化，age不参与序列化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案四：</strong> 使用对象流手工操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把实体序列化到本地文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">seri</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  FileOutputStream fileOut =<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/user.ser&quot;</span>);</span><br><span class="line">  ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);  </span><br><span class="line">  out.writeObject(user);</span><br><span class="line">  out.close();</span><br><span class="line">  fileOut.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把本地文件反序列化成对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">deser</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">  ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">  User user = (User) in.readObject();</span><br><span class="line">  in.close();</span><br><span class="line">  fileIn.close();</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="序列化和反序列化有哪些技术"><a href="#序列化和反序列化有哪些技术" class="headerlink" title="序列化和反序列化有哪些技术"></a>序列化和反序列化有哪些技术</h1><p>主要主流的序列化和反序列化技术：Java 原生序列化、Hessian 序列化、Kryo 序列化、JSON 序列化等</p><p>其实我们核心掌握的是序列化的核心思想即可，技术使用则是非常简单的，大家可以私下去通过案例测试几种技术的性能对比。</p><ul><li>序列化的byte[]数组长度的比较</li><li>同一个数据序列化的耗时时间比较</li><li>反序列化的耗时时间比较</li></ul><h1 id="如何自定义序列化和反序列化规范"><a href="#如何自定义序列化和反序列化规范" class="headerlink" title="如何自定义序列化和反序列化规范"></a>如何自定义序列化和反序列化规范</h1><p>通过上面的讲解，我想大家应该对序列化和反序列化都有一个大体的认识了，最后为了加深大家对序列化和反序列化的理解，大家可以思考如何设计一个序列化框架。其实，上面也提到了它是一种规范的约束，序列化和反序列化都遵守这样一个规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思考：如何把User实体-&gt;byte[]呢？</p></blockquote><p>思路：转换json字符串，<code>&#123;name:&quot;zwy&quot;,age:18&#125;</code>，那么为了缩短最终的byte[]长度，是否还可以进行优化呢？比如说，<code>&#123;&quot;zwy&quot;,18&#125;</code></p><p><strong>小结：</strong> 本节讲解序列化和反序列化技术，主要是平时我们在做网络通讯的时候，需要经常涉及，在学习Netty的时候序列化技术是必不可少的。<br>①在学习Netty的时候，自定义协议的时候，需要涉及序列化<br>②高并发情况下，压缩字节流，提高网络传输效率</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty 数据缓存</title>
      <link href="posts/%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98/"/>
      <url>posts/%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Netty-ByteBuf-传输载体"><a href="#Netty-ByteBuf-传输载体" class="headerlink" title="Netty ByteBuf 传输载体"></a>Netty ByteBuf 传输载体</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Netty 里面的数据读写是以 ByteBuf 为单位进行交互的，ByteBuf 是一个字节容器，如果了解过 NIO 的同学应该知道，在 NIO 里面也有类型的数据载体 ByteBuffer。</p><h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><p>熟悉掌握 ByteBuf 的原理及 API，则可以自定义通信协议，并且使用 ByteBuf、序列化等技术实现通信协议，并且有效解决拆包和粘包问题（后面章节会详细分析）。</p><h2 id="ByteBuf-结构"><a href="#ByteBuf-结构" class="headerlink" title="ByteBuf 结构"></a>ByteBuf 结构</h2><p>ByteBuff 的结构主要由四个部分组成，废弃字节、可读字节、可写字节、可扩容字节，具体结构图如下所示：</p><p><img src="https://s2.loli.net/2021/12/24/oUKhNZQtw6lDakg.png" alt="图片描述"></p><p>通过以上的结构图，我们可以看出它其实就是一个数组，在写数据和读数据的时候分别维护两个指针的移动，分别是 readerIndex 和 writerIndex，在 readerIndex 和 writerIndex 之间的数据是有效可读数据。具体分析如下所示：</p><ol><li>ByteBuf 的四个核心属性，分别是 readerIndex（可读指针位置）、writerIndex（可写指针位置）、capacity（初始化容量值）、maxCapacity（最大容量值）。其中 readerIndex 和 writerIndex 之间的数据是 ByteBuf 的主体数据；</li><li>读取数据的时候，readerIndex 递增，一旦 readerIndex 等于 writerIndex 则表示该容器没有数据可读了。writerIndex-readerIndex 表示有效可读数据的长度；</li><li>写数据的时候，writerIndex 递增，一旦 writerIndex 等于 capacity 表示容器已经满了，ByteBuf 不能再写数据了，capacity-writerIndex 表示容器还可以写入的数据长度；</li><li>当向 ByteBuf 写数据的时候，如果容量不足，那么这个时候可以进行扩容，直到 capacity 扩容到 maxCapacity，超过 maxCapacity 就会报错；</li><li>总结，readerIndex&lt;=writerIndex&lt;=capacity&lt;=maxCapacity。</li></ol><h2 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">capacity()</td><td align="left">容量</td></tr><tr><td align="left">maxCapacity()</td><td align="left">最大容量（当容量最大时，还可以扩容）</td></tr><tr><td align="left">readableBytes()</td><td align="left">可读字节数</td></tr><tr><td align="left">isReadable()</td><td align="left">是否可读</td></tr><tr><td align="left">writableBytes()</td><td align="left">可写字节数</td></tr><tr><td align="left">isWritable()</td><td align="left">是否可写</td></tr><tr><td align="left">maxWritableBytes()</td><td align="left">最大可写字节数</td></tr><tr><td align="left">readerIndex()</td><td align="left">读指针</td></tr><tr><td align="left">readerIndex(int)</td><td align="left">重置读指针为某个位置</td></tr><tr><td align="left">writerIndex()</td><td align="left">写指针</td></tr><tr><td align="left">writeIndex(int)</td><td align="left">重置写指针为某个位置</td></tr><tr><td align="left">markReaderIndex()</td><td align="left">保存当前读指针</td></tr><tr><td align="left">resetReaderIndex()</td><td align="left">回归之前保存的读指针</td></tr><tr><td align="left">markWriterIndex()</td><td align="left">保存当前写指针</td></tr><tr><td align="left">resetWriterIndex</td><td align="left">回归之前保存的写指针</td></tr><tr><td align="left">writeByte(int i)</td><td align="left">写一个字节</td></tr><tr><td align="left">writeBytes(byte[] bytes)</td><td align="left">写一个字节数组</td></tr><tr><td align="left">readByte()</td><td align="left">读一个字节</td></tr><tr><td align="left">readByte(byte[] bytes)</td><td align="left">读一个字节数组（并往参数 bytes 里存放）</td></tr></tbody></table><p>以上是 ByteBuf 的核心的 API，很多时候，在编程的时候直接操作 ByteBuf 可能会相对的繁琐，所以不会直接手工调用这些 API，而是通过封装编码和解码器的方式进行使用，但是编码、解码底层就是通过 ByteBuf 去实现的。</p><h2 id="核心-API-详解"><a href="#核心-API-详解" class="headerlink" title="核心 API 详解"></a>核心 API 详解</h2><h3 id="capatiy"><a href="#capatiy" class="headerlink" title="capatiy()"></a>capatiy()</h3><p>表示 ByteBuf 可以写入多少个字节，一般在初始化 ByteBuf 时就会指定。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf byteBuf=Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="maxCapacity"><a href="#maxCapacity" class="headerlink" title="maxCapacity()"></a>maxCapacity()</h3><p>表示 ByteBuf 最大可以支持多少字节，如果当 writerIndex=capacity 时，会判断 capacity 是否等于 maxCapacity，如果小于则扩容。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1，容量值</span></span><br><span class="line"><span class="comment">//参数2，最大容量值</span></span><br><span class="line">ByteBuf byteBuf = Unpooled.buffer(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h3 id="readalbeBytes"><a href="#readalbeBytes" class="headerlink" title="readalbeBytes()"></a>readalbeBytes()</h3><p>表示 ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readableBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writerIndex - <span class="keyword">this</span>.readerIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="isReadable"><a href="#isReadable" class="headerlink" title="isReadable()"></a>isReadable()</h3><p>如果 writerIndex 和 readerIndex 相等，则不可读，isReadable () 方法返回 false。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">(<span class="keyword">int</span> numBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writerIndex - <span class="keyword">this</span>.readerIndex &gt;= numBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="writableBytes"><a href="#writableBytes" class="headerlink" title="writableBytes()"></a>writableBytes()</h3><p>表示 ByteBuf 当前可写的字节数，它的值等于 capacity-writerIndex。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writableBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.capacity() - <span class="keyword">this</span>.writerIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="isWritable"><a href="#isWritable" class="headerlink" title="isWritable()"></a>isWritable()</h3><p>如果 capacity 和 writerIndex 相等，则表示不可写，isWritable () 返回 false。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.capacity() &gt; <span class="keyword">this</span>.writerIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="maxWritableBytes"><a href="#maxWritableBytes" class="headerlink" title="maxWritableBytes()"></a>maxWritableBytes()</h3><p>capacity 和 writerIndex 相等，并不代表不能继续往 ByteBuf 写数据了。如果发现往 ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity，而 maxWritableBytes () 就表示可写的最大字节数，它的值等于 maxCapacity-writerIndex。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxWritableBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.maxCapacity() - <span class="keyword">this</span>.writerIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="readerIndex"><a href="#readerIndex" class="headerlink" title="readerIndex()"></a>readerIndex()</h3><p>readerIndex () 表示返回当前的读指针 readerIndex，ByteBuf 会维护一个变量 readerIndex。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readerIndex;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readerIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.readerIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="readerIndex-int"><a href="#readerIndex-int" class="headerlink" title="readerIndex(int)"></a>readerIndex(int)</h3><p>readerIndex (int) 表示设置读指针，比如说可以回滚到某个指针位置。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readerIndex</span><span class="params">(<span class="keyword">int</span> readerIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (readerIndex &gt;= <span class="number">0</span> &amp;&amp; readerIndex &lt;= <span class="keyword">this</span>.writerIndex) &#123;</span><br><span class="line">            <span class="comment">//给readerIndex赋值</span></span><br><span class="line">            <span class="keyword">this</span>.readerIndex = readerIndex;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="writeIndex"><a href="#writeIndex" class="headerlink" title="writeIndex()"></a>writeIndex()</h3><p>writeIndex () 表示返回当前的写指针 writerIndex。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writerIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writerIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="writeIndex-int"><a href="#writeIndex-int" class="headerlink" title="writeIndex(int)"></a>writeIndex(int)</h3><p>writeIndex (int) 表示设置写指针，比如说可以回滚到某个指针位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writerIndex</span><span class="params">(<span class="keyword">int</span> writerIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (writerIndex &gt;= <span class="keyword">this</span>.readerIndex &amp;&amp; writerIndex &lt;= <span class="keyword">this</span>.capacity()) &#123;</span><br><span class="line">            <span class="comment">//给writerIndex赋值</span></span><br><span class="line">            <span class="keyword">this</span>.writerIndex = writerIndex;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="markReaderIndex"><a href="#markReaderIndex" class="headerlink" title="markReaderIndex()"></a>markReaderIndex()</h3><p>markReaderIndex () 表示把当前的读指针保存起来，其实类似数据库事务的当前状态标记。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">markReaderIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用markedReaderIndex保存当前读指针</span></span><br><span class="line">    <span class="keyword">this</span>.markedReaderIndex = <span class="keyword">this</span>.readerIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="resetReaderIndex"><a href="#resetReaderIndex" class="headerlink" title="resetReaderIndex()"></a>resetReaderIndex()</h3><p>resetReaderIndex () 表示把当前的读指针恢复到之前保存的值，类似数据库事务回归到某个状态。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">resetReaderIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerIndex(<span class="keyword">this</span>.markedReaderIndex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="markWriterIndex"><a href="#markWriterIndex" class="headerlink" title="markWriterIndex()"></a>markWriterIndex()</h3><p>表示把当前的写指针保存起来。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">markWriterIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.markedWriterIndex = <span class="keyword">this</span>.writerIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">代码块<span class="number">1234</span></span><br></pre></td></tr></table></figure><h3 id="resetWriterIndex"><a href="#resetWriterIndex" class="headerlink" title="resetWriterIndex()"></a>resetWriterIndex()</h3><p>切块之前保存的写指针 writerIndex。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">resetWriterIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.writerIndex = <span class="keyword">this</span>.markedWriterIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="writeByte-byte-b"><a href="#writeByte-byte-b" class="headerlink" title="writeByte(byte b)"></a>writeByte(byte b)</h3><p>writeByte (byte b)，表示一次写入一个字节，writerIndex++。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ensureAccessible();</span><br><span class="line">    <span class="keyword">this</span>.ensureWritable0(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//writerIndex指针自增</span></span><br><span class="line">    <span class="keyword">this</span>._setByte(<span class="keyword">this</span>.writerIndex++, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="writeBytes-byte-src"><a href="#writeBytes-byte-src" class="headerlink" title="writeBytes(byte[] src)"></a>writeBytes(byte[] src)</h3><p>writeBytes (byte [] src)，表示写入一个字节数组，writerIndex=writerIndex+src.length。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.writeBytes((<span class="keyword">byte</span>[])src, <span class="number">0</span>, src.length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ensureAccessible();</span><br><span class="line">    <span class="keyword">this</span>.ensureWritable(length);</span><br><span class="line">    <span class="keyword">this</span>.setBytes(<span class="keyword">this</span>.writerIndex, src, srcIndex, length);</span><br><span class="line">    <span class="keyword">this</span>.writerIndex += length; <span class="comment">//writerIndex指针增加</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="readByte"><a href="#readByte" class="headerlink" title="readByte()"></a>readByte()</h3><p>readByte ()，表示一次读取一个字节，readerIndex++。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.checkReadableBytes0(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="keyword">this</span>.readerIndex;</span><br><span class="line">    <span class="keyword">byte</span> b = <span class="keyword">this</span>._getByte(i);<span class="comment">//读取数据</span></span><br><span class="line">    <span class="keyword">this</span>.readerIndex = i + <span class="number">1</span>; <span class="comment">//指针自增</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="readBytes-byte-dst"><a href="#readBytes-byte-dst" class="headerlink" title="readBytes(byte[] dst)"></a>readBytes(byte[] dst)</h3><p>readBytes (byte [] dst)，表示把 ByteBuf 里面的数据读取到 dst，readerIndex=readerIndex+dst.length。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(<span class="keyword">byte</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readBytes((<span class="keyword">byte</span>[])dst, <span class="number">0</span>, dst.length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.checkReadableBytes(length);</span><br><span class="line">    <span class="keyword">this</span>.getBytes(<span class="keyword">this</span>.readerIndex, dst, dstIndex, length);<span class="comment">//往目标dst里面写数据</span></span><br><span class="line">    <span class="keyword">this</span>.readerIndex += length;<span class="comment">//指针增加</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>读写 API 类似的 API 还有 getBytes、getByte () 与 setBytes ()、setByte () 系列</p></blockquote><p>区别就是 get/set 不会改变读写指针，而 read/write 会改变读写指针，这点在解析数据的时候千万要注意。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节内容主要讲解了 ByteBuf，需要掌握的内容如下：</p><ol><li>理解并且牢记 ByteBuf 结构图；</li><li>基于读写指针、容量、最大可扩容容量，衍生出一系列的读写方法，要注意 read/write 与 get/set 的区别；</li></ol><h1 id="Netty-ByteBuf-几种类型"><a href="#Netty-ByteBuf-几种类型" class="headerlink" title="Netty ByteBuf 几种类型"></a>Netty ByteBuf 几种类型</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>上一节，我们主要学习了 ByteBuf 的核心 API，相信大家都能掌握，本节主要介绍 ByteBuf 的几种分类。</p><h2 id="创建一个-ByteBuf"><a href="#创建一个-ByteBuf" class="headerlink" title="创建一个 ByteBuf"></a>创建一个 ByteBuf</h2><p>常见创建 ByteBuf 主要有两种方式，分别如下所示：</p><p>方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf byteBuf = Unpooled.buffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><blockquote><p>思考：那么这两种方式有什么关联呢？</p></blockquote><p><code>Unpooled.buffer</code> 源码，以下代码是经过整理，只保留了核心代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unpooled</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBufAllocator ALLOC;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ALLOC = UnpooledByteBufAllocator.DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ALLOC.heapBuffer(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">directBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ALLOC.directBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过源码，我们可以知道，其实 Unpooled 工具类也是调用 ByteBufAllocator 去创建 ByteBuf 的。从字面上我们能够大概猜到它针对的是非池化的 ByteBuf 进行创建的。</p><h2 id="ByteBuf-分类"><a href="#ByteBuf-分类" class="headerlink" title="ByteBuf 分类"></a>ByteBuf 分类</h2><p>ByteBuf 是一个字节容器，底层是根据<strong>容量值</strong>来申请一块内存区域来存储字节数组的。既然涉及到内存，那么会分为直接内存和 JVM 内存，这个和 NIO 的直接缓冲器和非直接缓冲器是一样的道理。直接内存，速度很快，垃圾回收是不受 JVM 控制，容易造成内存爆满。</p><p>ByteBuf 主要分为三种类型</p><ol><li>Pooled 和 Unpooled，池化和非池化；</li><li>Heap 和 Direct，堆内存和直接内存；</li><li>Safe 和 Unsafe，安全和非安全。</li></ol><p><strong>池化和非池化：</strong> 池化就是用完就放回池子里面，比如我们所熟悉的数据库连接池。非池化就是每次使用都重新创建，使用完成则立马销毁。从性能的角度来说，池化会比非池化相对高，因为可以重复利用，避免每次都重新创建。</p><p><strong>堆内存和直接内存：</strong> 堆内存是 JVM 内部开辟的一块内存空间，它的生命周期受到 JVM 来管理，不容易造成内存溢出的情况。直接内存则是直接受操作系统管理了，如果数据量很大的情况，容易造成内存溢出情况。</p><p><strong>安全和非安全：</strong> 主要是 Java 操作底层操作数据的一种安全和非安全的方式。</p><p><img src="https://s2.loli.net/2021/12/24/8hzag4kTnc6I2yq.png" alt="图片描述"></p><p>根据不同类型进行组合，得到常见 ByteBuf 的实现类</p><ol><li>池化 + 堆内存，PooledHeapByteBuf；</li><li>池化 + 直接内存，PooledDirectByteBuf；</li><li>池化 + 堆内存 + 不安全，PooledUnsafeHeapByteBuf；</li><li>池化 + 直接内存 + 不安全，PooledUnsafeDirectByteBuf；</li><li>非池化 + 堆内存，UnpooledHeapByteBuf；</li><li>非池化 + 直接内存，UnpooledDirectByteBuf；</li><li>非池化 + 堆内存 + 不安全，UnpooledUnsafeHeapByteBuf；</li><li>非池化 + 直接内存 + 不安全，UnpooledUnsafeDirectByteBuf。</li></ol><h2 id="ByteBufAllocator-的使用"><a href="#ByteBufAllocator-的使用" class="headerlink" title="ByteBufAllocator 的使用"></a>ByteBufAllocator 的使用</h2><p>由于 ByteBuf 的组合种类非常的多，如果让用户手工去创建的化，会非常的麻烦，并且对每种类型不熟悉，很容易出现性能问题。这点跟 Java 线程池有点类似，线程池的种类分好几种，但是通常都是通过 Executors 工具类来进行线程池的创建。</p><p>其中，ByteBufAllocator 又主要分为两种，分别是 <code>UnpooledByteBufAllocator</code> 和 <code>PooledByteBufAllocator</code>。其实，一般情况下我们不需要直接使用具体的分配器，而是使用它默认的即可。</p><h3 id="默认分配-池化-amp-非池化"><a href="#默认分配-池化-amp-非池化" class="headerlink" title="默认分配 - 池化 &amp; 非池化"></a>默认分配 - 池化 &amp; 非池化</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBufAllocator byteBufAllocator = ByteBufAllocator.DEFAULT;</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByteBufAllocator</span> </span>&#123;</span><br><span class="line">    ByteBufAllocator DEFAULT = ByteBufUtil.DEFAULT_ALLOCATOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码：以下源码是经过处理，只保留核心部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ByteBufAllocator DEFAULT_ALLOCATOR;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//1.分配类型</span></span><br><span class="line">        String allocType = SystemPropertyUtil.get(<span class="string">&quot;io.netty.allocator.type&quot;</span>, PlatformDependent.isAndroid() ? <span class="string">&quot;unpooled&quot;</span> : <span class="string">&quot;pooled&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.根据类型，创建不同的分配器</span></span><br><span class="line">        Object alloc;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;unpooled&quot;</span>.equals(allocType)) &#123;</span><br><span class="line">            alloc = UnpooledByteBufAllocator.DEFAULT;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;pooled&quot;</span>.equals(allocType)) &#123;</span><br><span class="line">            alloc = PooledByteBufAllocator.DEFAULT;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alloc = PooledByteBufAllocator.DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DEFAULT_ALLOCATOR = (ByteBufAllocator)alloc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上的源码，我们可以知道，使用 ByteBufAlloctor 来创建 ByteBuf 时，会判断使用池化还是非池化的分配器。</p><h3 id="默认分配-堆内存-amp-直接内存"><a href="#默认分配-堆内存-amp-直接内存" class="headerlink" title="默认分配 - 堆内存 &amp; 直接内存"></a>默认分配 - 堆内存 &amp; 直接内存</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>源码：以下源码是经过处理，只保留核心部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractByteBufAllocator</span> <span class="keyword">implements</span> <span class="title">ByteBufAllocator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> directByDefault;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.directByDefault = preferDirect &amp;&amp; PlatformDependent.hasUnsafe();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.directByDefault ? <span class="keyword">this</span>.directBuffer(initialCapacity) : <span class="keyword">this</span>.heapBuffer(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 directByDefault 来判断是否选择创建堆内存还是直接内存的 ByteBuf，而 directByDefault 是在构造函数里面进行传值的，那么它是一个抽象类，因此肯定是从其子类的构造函数传值进来。</p><p>继续查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledByteBufAllocator</span> <span class="keyword">extends</span> <span class="title">AbstractByteBufAllocator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传递的是false</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledByteBufAllocator</span> <span class="keyword">extends</span> <span class="title">AbstractByteBufAllocator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(preferDirect, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">boolean</span> disableLeakDetector)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传递值给父类的构造函数</span></span><br><span class="line">        <span class="keyword">super</span>(preferDirect);</span><br><span class="line">        <span class="keyword">this</span>.disableLeakDetector = disableLeakDetector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结，ByteBufAllocator 的核心两个步骤分别如下：</p><ol><li>确定是使用哪个分配器，池化还是非池化？<code>UnpooledByteBufAllocator</code> 和 <code>PooledByteBufAllocator</code>；</li><li>再确定是堆内存还是直接内存，主要是在 <code>UnpooledByteBufAllocator</code> 和 <code>PooledByteBufAllocator</code> 的构造函数里面传值确定。</li></ol><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><table><thead><tr><th align="left">方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">buffer();</td><td align="left">创建 ByteBuf（堆内存还是直接内存？），默认容量值</td></tr><tr><td align="left">buffer(int var1);</td><td align="left">创建 ByteBuf（堆内存还是直接内存？），手工指定容量值</td></tr><tr><td align="left">buffer(int var1, int var2);</td><td align="left">创建 ByteBuf（堆内存还是直接内存？），手工指定容量值和最大容量值</td></tr><tr><td align="left">heapBuffer();</td><td align="left">创建一个堆内存的 ByteBuf，默认容量值</td></tr><tr><td align="left">heapBuffer(int var1);</td><td align="left">创建一个堆内存的 ByteBuf，手工指定容量值</td></tr><tr><td align="left">heapBuffer(int var1, int var2);</td><td align="left">创建一个堆内存的 ByteBuf，手工指定容量值和最大容量值</td></tr><tr><td align="left">directBuffer();</td><td align="left">创建一个直接内存的 ByteBuf，默认容量值</td></tr><tr><td align="left">directBuffer(int var1);</td><td align="left">创建一个直接内存的 ByteBuf，手工指定容量值</td></tr><tr><td align="left">directBuffer(int var1, int var2);</td><td align="left">创建一个直接内存的 ByteBuf，手工指定容量值和最大容量值</td></tr></tbody></table><p>一般推荐使用 buffer ()、<code>buffer(int var1)</code>、<code>buffer(int var1,int var2)</code>，因为 Netty 底层回去帮选择创建最优的 ByteBuf。</p><h2 id="Unpooled-的使用"><a href="#Unpooled-的使用" class="headerlink" title="Unpooled 的使用"></a>Unpooled 的使用</h2><p>Unpooled 主要是使用了非池化技术，可以创建堆内存和直接内存的 ByteBuf。</p><p>核心 API 如下所示：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ByteBuf buffer()</td><td align="left">创建非池化 + 堆内存的 ByteBuf，默认容量大小</td></tr><tr><td align="left">ByteBuf buffer(int initialCapacity)</td><td align="left">创建非池化 + 堆内存的 ByteBuf，并且可以指定容量大小</td></tr><tr><td align="left">ByteBuf directBuffer()</td><td align="left">创建非池化 + 直接内存的 ByteBuf，默认容量大小</td></tr><tr><td align="left">directBuffer(int initialCapacity)</td><td align="left">创建非池化 + 直接内存的 ByteBuf，并且可以指定容量大小</td></tr><tr><td align="left">ByteBuf copiedBuffer(byte[] array)</td><td align="left">创建非池化 + 堆内存的 ByteBuf，并且初始化字节数组</td></tr><tr><td align="left">ByteBuf copiedBuffer(byte[] array, int offset, int length)</td><td align="left">创建非池化 + 堆内存的 ByteBuf，并且把字节数组的<code>部分内容</code>初始化到 ByteBuf</td></tr><tr><td align="left">ByteBuf copiedBuffer(ByteBuf buffer)</td><td align="left">创建非池化 + 堆内存的 ByteBuf，并且把参数的 ByteBuf 写入到新创建的 ByteBuf 里</td></tr></tbody></table><p>以上的方法是平时我们使用 Unpooled 时使用最多的，难度不大，只需要分清每个方法的作用是什么即可，可以根据自己需求选择合适的 ByteBuf 类型。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本节主要介绍了 ByteBuf 的几种核心类型以及创建 ByteBuf 的几种方式</p><ol><li>掌握 ByteBuf 的三种类型，分别是池化与非池化、堆内存与直接内存、安全与不安全，以及它们之间的含义；</li><li>ByteBufAllocator 分配器，它是如何去创建 ByteBuf 的，几种模式；</li><li>Unpooled，Netty 提供的非池化工具类。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ChannelHandler 和 ChannelPipeline</title>
      <link href="posts/ChannelHandler%20%E5%92%8C%20ChannelPipeline/"/>
      <url>posts/ChannelHandler%20%E5%92%8C%20ChannelPipeline/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ChannelPipeline-数据管道"><a href="#ChannelPipeline-数据管道" class="headerlink" title="ChannelPipeline 数据管道"></a>ChannelPipeline 数据管道</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面，我们也提到了 ChannelPipeline，它是管道或者说管理 Handler 的集合，很多同学很容易搞混 Channel、ChannelPipeline 和 ChannelHandler 之间关系。</p><p>本节内容我们需要理清并且掌握以下知识点：</p><ol><li>Channel、ChannelPipeline、ChannelHandler 之间的关系；</li><li>了解 ChannelPipeline 如何管理 ChannelHandler。</li></ol><h2 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h2><p>Channel 是一个连接通道，客户端和服务端连接成功之后，会维持一个 Channel，可以通过 Channel 来发送数据。Channel 有且仅有一个 ChannelPipeline 与之相对应，ChannelPipeline 又维护着一个由多个 ChannelHandlerContext 组成的双向链表，ChannelHandlerContext 又关联着一个 ChannelHandler。</p><p>它们之间的关系，大概如下图所示：</p><p><img src="https://s2.loli.net/2021/12/24/E4XdQcWCnLFhoKb.png" alt="图片描述"></p><h2 id="ChannelPipeline-核心方法"><a href="#ChannelPipeline-核心方法" class="headerlink" title="ChannelPipeline 核心方法"></a>ChannelPipeline 核心方法</h2><p>ChannelPipeline 的最常用方法：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">addFirst(…)</td><td align="left">添加 ChannelHandler 在 ChannelPipeline 的第一个位置</td></tr><tr><td align="left">addBefore(…)</td><td align="left">在 ChannelPipeline 中指定的 ChannelHandler 名称之前添加 ChannelHandler</td></tr><tr><td align="left">addAfter(…)</td><td align="left">在 ChannelPipeline 中指定的 ChannelHandler 名称之后添加 ChannelHandler</td></tr><tr><td align="left">addLast(…)</td><td align="left">在 ChannelPipeline 的末尾添加 ChannelHandler</td></tr><tr><td align="left">remove(…)</td><td align="left">删除 ChannelPipeline 中指定的 ChannelHandler</td></tr><tr><td align="left">replace(…)</td><td align="left">替换 ChannelPipeline 中指定的 ChannelHandler</td></tr><tr><td align="left">ChannelHandler first()</td><td align="left">获取链表当中的第一个节点</td></tr><tr><td align="left">ChannelHandler last()</td><td align="left">获取链表当中的最后一个节点</td></tr></tbody></table><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">serverBootstrap</span><br><span class="line">    .group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> Handler1());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> Handler2());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> Handler3());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> Handler4());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>总结，ChannelPipeline 的用法比较固定，虽然方法很多，但是一般常用的就是 addLast。</p><h2 id="ChannelPipeline-管理链表"><a href="#ChannelPipeline-管理链表" class="headerlink" title="ChannelPipeline 管理链表"></a>ChannelPipeline 管理链表</h2><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建ChannelPipeline</span></span><br><span class="line">ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建Handler</span></span><br><span class="line">FirstHandler firstHandler = <span class="keyword">new</span> FirstHandler();</span><br><span class="line">SecondHandler secondHandler=<span class="keyword">new</span> SecondHandler();</span><br><span class="line">ThirdHandler thirdHandler=<span class="keyword">new</span> ThirdHandler();</span><br><span class="line">FourthHandler fourthHandler=<span class="keyword">new</span> FourthHandler();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.操作</span></span><br><span class="line">pipeline.addLast(<span class="string">&quot;handler1&quot;</span>, firstHandler);</span><br><span class="line">pipeline.addFirst(<span class="string">&quot;handler2&quot;</span>, secondHandler);<span class="comment">//在最开始添加</span></span><br><span class="line">pipeline.addLast(<span class="string">&quot;handler3&quot;</span>, thirdHandler);<span class="comment">//在最后添加</span></span><br><span class="line">pipeline.remove(<span class="string">&quot;handler3&quot;</span>); <span class="comment">//根据名称删除</span></span><br><span class="line">pipeline.remove(firstHandler);<span class="comment">//根据对象删除</span></span><br><span class="line">pipeline.replace(<span class="string">&quot;handler2&quot;</span>, <span class="string">&quot;handler4&quot;</span>, fourthHandler);<span class="comment">//替换</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FourthHandler</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="入站和出站执行顺序"><a href="#入站和出站执行顺序" class="headerlink" title="入站和出站执行顺序"></a>入站和出站执行顺序</h2><p>在真实的项目开发当中，inboundHandler 和 outboundHandler 都是多个的，一般是一个业务处理对应一个 Handler。那么多个的情况下，Pipeline 的执行顺序又是怎么样的呢？</p><h3 id="Inbound-不往下传递"><a href="#Inbound-不往下传递" class="headerlink" title="Inbound 不往下传递"></a>Inbound 不往下传递</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> InboundHandler1());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> InboundHandler2());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundHandler1</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inbound1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundHandler2</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inbound1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><blockquote><p>思考：为什么不执行 InboundHandler2 呢？</p><p>原因：InboundHandler1 没有手工往下传递执行。</p></blockquote><h3 id="Inbound-流转顺序"><a href="#Inbound-流转顺序" class="headerlink" title="Inbound 流转顺序"></a>Inbound 流转顺序</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> InboundHandler1());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> InboundHandler2());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundHandler1</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inbound1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//往下传递</span></span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundHandler2</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inbound1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">inbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>InboundHandler 之间可以通过 <code>super.channelRead(ctx, msg);</code> 往下传递。</p><h3 id="Inbound-执行顺序"><a href="#Inbound-执行顺序" class="headerlink" title="Inbound 执行顺序"></a>Inbound 执行顺序</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> InboundHandler1());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> InboundHandler2());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundHandler1</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.往下传递</span></span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">        <span class="comment">//2.打印信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;inbound1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundHandler2</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">inbound1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>InboundHandler1 先往下传递，在执行自己的业务，那么 InboundHandler2 就会比 InboundHandler1 先执行。</p><blockquote><p>总结：Inbound 是按顺序进行传递，但是逻辑的执行并非是按顺序执行，而是由 <code>super.channelRead(ctx, msg);</code> 去决定。</p></blockquote><h3 id="流转到-Outbound"><a href="#流转到-Outbound" class="headerlink" title="流转到 Outbound"></a>流转到 Outbound</h3><p>InboundHandler 往 OutboundHandler 流转，需要手工调用 <code>ctx.channel().writeAndFlush()</code>，否则无法执行 OutboundHandler 的业务逻辑。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundHandler2</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//传递到OutboundHandler</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="Outbound-内部流转"><a href="#Outbound-内部流转" class="headerlink" title="Outbound 内部流转"></a>Outbound 内部流转</h3><p>跟 InboundHandler 一样，需要手工往下传递，否则无法流转到下一个 OutboundHandler。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutboundHandler2</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//往下流转</span></span><br><span class="line">        <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><blockquote><p>总结：OutboundHandler 是按逆向来流转，但是业务逻辑的执行顺序则是由 <code>super.write(ctx, msg, promise);</code> 决定。</p></blockquote><h3 id="ctx-writeAndFlush-和-ctx-channel-writeAndFlush-的区别"><a href="#ctx-writeAndFlush-和-ctx-channel-writeAndFlush-的区别" class="headerlink" title="ctx.writeAndFlush 和 ctx.channel ().writeAndFlush 的区别"></a>ctx.writeAndFlush 和 ctx.channel ().writeAndFlush 的区别</h3><p>很多同学很容易遇到以下问题，并且会想不通。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> InboundHandler1());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> InboundHandler2());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> OutboundHandler1());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> OutboundHandler2());</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>InboundHandler2 流转代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundHandler2</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//流转到OutboundHandler2</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inbound1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">inbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">outbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">outbound1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>修改 InboundHandler2 流转代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundHandler2</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//【注意，调整这里了】</span></span><br><span class="line">        ctx.writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inbound1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">inbound2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><blockquote><p>思考：为什么这里使用 ctx.writeAndFlush 就流程不下去了呢？</p></blockquote><blockquote><p><code>ctx.writeAndFlush();</code> 最终源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span>(!ctx.outbound);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>通过源码，我们发现它是从当前 InboundHandler 开始往前执行。</p><blockquote><p><code>ctx.channel().writeAndFlush();</code> 最终源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.tail.writeAndFlush(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过源码，我们发现它是从链表的最后一个节点开始往前面执行。</p><p>总结，如果是 OutboundHandler 放在 InboundHandler 之后，使用不同的 writeAndFlush 则得到的结果不一样。</p><h3 id="规律总结"><a href="#规律总结" class="headerlink" title="规律总结"></a>规律总结</h3><p>Inbound 的顺序</p><ol><li><strong>流转顺序：</strong> 多个 Inbound 不会自动往下流转，需要手工调用 <code>ctx.fireChannelRead(msg);</code> 才能流转到下一个；</li><li><strong>执行顺序：</strong> 业务逻辑的执行顺序，则根据 <code>ctx.fireChannelRead(msg);</code> 和逻辑的先后顺序所决定；</li><li>Inbound 往 Outbound 流转，则需要手工 <code>ctx.channel().writeAndFlush()</code>。</li></ol><p>Outbound 的顺序</p><ol><li><strong>流转顺序：</strong> 多个 Outbound 不会自动往下流转，需要手工调用 <code>ctx.write(msg, promise);</code> 才能流转到下一个；</li><li><strong>执行顺序：</strong> 业务逻辑的执行顺序，则根据 <code>ctx.write(msg, promise);</code> 和逻辑的先后顺序所决定。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要讲解的知识点</p><ol><li>Channel、ChannelPipeline、ChannelHandlerContext、ChannelHandler 之间的关系；</li><li>ChannelPipeline 的核心方法，以及它是如何管理 Handler 的，主要通过 addLast () 去组装 Handler；</li><li>入站和出站的流转顺序和业务逻辑的执行顺序。</li></ol><h1 id="ChannelHandler-业务处理"><a href="#ChannelHandler-业务处理" class="headerlink" title="ChannelHandler 业务处理"></a>ChannelHandler 业务处理</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>本节，主要讲解基于 ChannelHandler 去自定义专门处理业务逻辑的 Handler。使用 Netty 开发的客户端和服务端之间通信，通信只是数据的传输，但是接受到数据如何去处理，此时就需要用到我们的自定义 Handler 去实现了。并且通常情况下，不同的业务需要对应不同的 Handler。</p><h2 id="自定义-Handler-步骤"><a href="#自定义-Handler-步骤" class="headerlink" title="自定义 Handler 步骤"></a>自定义 Handler 步骤</h2><p>如果是接受对方传输数据并且做处理，则继承 <code>ChannelInboundHandlerAdapter</code>。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundHandler1</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是向对方写数据时，则继承 <code>ChannelOutboundHandlerAdapter</code>。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutboundHandler1</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">channelActive(ChannelHandlerContext ctx)</td><td align="left">在客户端连接建立成功之后被调用，并且只会调用一次。一般用来做一些初始化工作、登录认证等。</td></tr><tr><td align="left">channelInactive(ChannelHandlerContext ctx)</td><td align="left">连接断开时，触发该事件，无论是客户端主动断开，还是服务端主动断开，客户端和服务端的该方法都会监听到事件。</td></tr><tr><td align="left">channelRead(ChannelHandlerContext ctx, Object msg)</td><td align="left">当 channel 上面有数据到来时会触发 channelRead 事件，当数据到来时，eventLoop 被唤醒继而调用 channelRead 方法处理数据。</td></tr><tr><td align="left">channelReadComplete(ChannelHandlerContext ctx)</td><td align="left">channelRead 期间做个判断，read 到 0 个字节或者是 read 到的字节数小于 buffer 的容量，满足以上条件就会调用 <code>channelReadComplete</code> 方法。</td></tr><tr><td align="left">exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</td><td align="left">发生异常时，触发该事件。</td></tr></tbody></table><p>以上方法是自定义 Handler 重新最多的方法，其中 channelRead () 是重点掌握。</p><h2 id="ChannelHandler-处理流程"><a href="#ChannelHandler-处理流程" class="headerlink" title="ChannelHandler 处理流程"></a>ChannelHandler 处理流程</h2><p><img src="https://s2.loli.net/2021/12/24/c9WOlKMJtE8GdgC.png" alt="图片描述"></p><h2 id="简单业务开发"><a href="#简单业务开发" class="headerlink" title="简单业务开发"></a>简单业务开发</h2><p>需求：实现客户端向服务端发送登录认证请求。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端实现的功能：在连接准备就绪时 channelActive () 发起登录认证。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientLoginHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.通道激活的时候，发送账号、密码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;1234567&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象流序列化Map</span></span><br><span class="line">        ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">        oos.writeObject(map);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes=os.toByteArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        oos.close();</span><br><span class="line">        os.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送</span></span><br><span class="line">        ctx.channel().writeAndFlush(Unpooled.copiedBuffer(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>channelActive 事件是通道建立时触发该事件，并且仅触发一次该事件，通常情况下，在 channelActive 里面实现登录认证；</li><li>客户端往服务端发送数据的时候需要使用对象流进行序列化，客户端接收服务端响应信息的时候，需要通过对象流进行反序列化；</li><li>Netty 底层是 ByteBuf 进行传输的（后面章节会详细介绍），最终网络底层传输则是 byte []，因此需要做序列化和反序列化操作。</li></ol><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端实现的功能：接受客户端的请求数据，并且做账户和密码的校验。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLoginHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.读取客户端发送过来的数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.转换ByteBuf</span></span><br><span class="line">        ByteBuf buffer=(ByteBuf)msg;</span><br><span class="line">        <span class="comment">//2.定义一个byte数组，长度是ByteBuf的可读字节数</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[buffer.readableBytes()];</span><br><span class="line">        <span class="comment">//3.往自定义的byte[]读取数据</span></span><br><span class="line">        buffer.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.对象流反序列化</span></span><br><span class="line">        ByteArrayInputStream is=<span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream iss=<span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">        Map&lt;String,String&gt; map=(Map&lt;String,String&gt;)iss.readObject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.关闭流</span></span><br><span class="line">        is.close();</span><br><span class="line">        iss.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.认证账号、密码，并且响应</span></span><br><span class="line">        String username=map.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password=map.get(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(username.equals(<span class="string">&quot;admin&quot;</span>)&amp;&amp;password.equals(<span class="string">&quot;123456&quot;</span>))&#123;</span><br><span class="line">            ctx.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;success&quot;</span>.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ctx.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;error&quot;</span>.getBytes()));</span><br><span class="line">            ctx.channel().closeFuture();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>channelRead 方法，在客户端有数据可读取的时候会触发该方法；</li><li>接受到的数据不可以直接使用，并且先转换 ByteBuf，再转换 byte []，最后通过对象流转换成目标类型的数据；</li><li>解析出来的账号、密码，进行认证（这里是写死，真实是连接数据库进行校验），把认证结果响应给客户端。</li></ol><h2 id="复杂业务开发"><a href="#复杂业务开发" class="headerlink" title="复杂业务开发"></a>复杂业务开发</h2><p>上面的登录认证案例只是比较简单的一个业务，真实项目当中，肯定是很多的业务组合而成的，那么如何基于 Netty 的 Handler 去实现呢？</p><h3 id="共用一个-Handler"><a href="#共用一个-Handler" class="headerlink" title="共用一个 Handler"></a>共用一个 Handler</h3><blockquote><p>所有业务共用一个 Handler，由该 Handler 进行根据<strong>业务编码</strong>作为路由标识进行业务分发。</p></blockquote><p><strong>方案优缺点：</strong></p><ol><li><strong>优点：</strong> 思路简单，适合业务不是很复杂的业务；</li><li><strong>缺点：</strong> 如果业务很多的情况下，代码会变的非常的臃肿，不太好管理。</li></ol><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map=(Map&lt;String,String&gt;)msg;</span><br><span class="line">        String code=map.get(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(code.equals(<span class="string">&quot;login&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//具体逻辑</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code.equals(<span class="string">&quot;getUserInfo&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//具体逻辑</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//..............</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h3 id="多个-Handler-手工流转"><a href="#多个-Handler-手工流转" class="headerlink" title="多个 Handler 手工流转"></a>多个 Handler 手工流转</h3><blockquote><p>定义多个 Handler，每个 Handler 根据<strong>业务编码</strong>来判断是否需要处理，如果是则处理，否则继续向下流转。</p></blockquote><p><strong>方案优缺点：</strong></p><ol><li><strong>优点：</strong> 把所有的业务解耦，不用所有业务都耦合在一起，使项目结构更清晰，更加容易维护；</li><li><strong>缺点：</strong> 客户端和服务端都有维护一份业务编码，一旦编码发生变更，则需要找到具体业务点去调整，相对比较麻烦。</li></ol><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map=(Map&lt;String,String&gt;)msg;</span><br><span class="line">        String code=map.get(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(code.equals(<span class="string">&quot;login&quot;</span>))&#123;</span><br><span class="line"><span class="comment">//逻辑处理</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//手工流转下一个Handler</span></span><br><span class="line">            <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="SimpleChannelInboundHandler"><a href="#SimpleChannelInboundHandler" class="headerlink" title="SimpleChannelInboundHandler"></a>SimpleChannelInboundHandler</h3><blockquote><p>根据客户端提交的参数类型，自动流转到指定的 Handler 去处理。</p></blockquote><p><strong>方案优缺点：</strong></p><ol><li><strong>优点：</strong> ①把业务解耦，每个业务对应独立的 Handler；②不需要维护一份业务编码；</li><li><strong>缺点：</strong> 所有的封装封装都得对应一个实体，实体数量会比较多，但是严格意义来说，也不能说是缺点，现在基本上都是面向对象来进行编程。</li></ol><p>这种模式在真实开发当中是使用最广泛的。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//处理业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本节内容，主要讲解如何在真实项目当中去使用 Handler，需要掌握的知识点如下：</p><ol><li>如何自定义一个 Handler；</li><li>Handler 的几个核心方法的使用；</li><li>如果复杂业务，三种业务逻辑处理方式以及优缺点。</li></ol><h1 id="ChannelHandler-生命周期"><a href="#ChannelHandler-生命周期" class="headerlink" title="ChannelHandler 生命周期"></a>ChannelHandler 生命周期</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>本节内容，我们主要讲解 ChannelHandler 在执行过程中的生命周期是什么样的？需要执行哪些核心的生命周期方法以及顺序？</p><p>了解生命周期的核心目的是，可以在合适的生命周期方法扩展自己的业务功能。</p><h2 id="UML-关系"><a href="#UML-关系" class="headerlink" title="UML 关系"></a>UML 关系</h2><p>首先，我们先来了解以下 ChannelHandler 的类依赖关系图，具体如下所示：<br><img src="http://img.mukewang.com/wiki/5f375cea09281f4e12400581.jpg" alt="图片描述"></p><p>通过上面的类结构图，我们总结一下规律：</p><ol><li>ChannelHandler 有两个子接口，分别是 <code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code>，其实从字面意思就能知道，它们分别是入站和出站的接口类。</li><li>如果我们自定义的业务 Handler 直接实现 ChannelInboundHandler 或者 ChannelOutboundHandler，那么我们需要实现的接口非常的多，增加了开发的难度。Netty 已经帮我们封装好了两个实现类，分别是 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter，这样可以大大简化了开发工作。</li></ol><h2 id="核心生命周期方法"><a href="#核心生命周期方法" class="headerlink" title="核心生命周期方法"></a>核心生命周期方法</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">handlerAdded</td><td align="left">Handler 被加入 Pipeline 时触发（仅仅触发一次）</td></tr><tr><td align="left">channelRegistered</td><td align="left">channelRegistered 注册成功时触发</td></tr><tr><td align="left">channelActive</td><td align="left">channel 连接就绪时触发</td></tr><tr><td align="left">channelRead</td><td align="left">channel 有数据可读时触发</td></tr><tr><td align="left">channelReadComplete</td><td align="left">channel 有数据可读，并且读完时触发</td></tr><tr><td align="left">channelInactive</td><td align="left">channel 断开时触发</td></tr><tr><td align="left">channelUnregistered</td><td align="left">channel 取消注册时触发</td></tr><tr><td align="left">handlerRemoved</td><td align="left">handler 被从 Pipeline 移除时触发</td></tr></tbody></table><blockquote><p>问题 1：channelRegistered 注册指的是什么呢？</p></blockquote><p>Channel 在创建时，需要绑定 ChannelPipeline 和 EventLoop 等操作，完成这些操作时会触发 channelRegistered () 方法。</p><blockquote><p>问题 2：channelRead 和 channelReadComplete 的区别？</p></blockquote><p>当 Channel 有数据可读时，会触发 channelRead 事件，eventLoop 被唤醒并且调用 channelRead () 处理数据；eventLoop 唤醒后读取数据包装成 msg，然后将 msg 作为参数调用 channelRead ()，期间做了个判断，读取到 0 字节或者读取到的字节数小于 buffer 的容量，满足以上条件就会调用 channelReadComplete ()。</p><h2 id="生命周期执行流程"><a href="#生命周期执行流程" class="headerlink" title="生命周期执行流程"></a>生命周期执行流程</h2><p>ChannelHandler 的一些特殊回调方法，这些回调方法的执行是有顺序的，而这个执行顺序可以称为 ChannelHandler 的生命周期。</p><h3 id="客户端发送一次请求"><a href="#客户端发送一次请求" class="headerlink" title="客户端发送一次请求"></a>客户端发送一次请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundHandler1</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.handlerAdded(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRegistered&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelActive&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRead&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelReadComplete&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelReadComplete(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelInactive&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelUnregistered&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.handlerRemoved(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handlerAdded</span><br><span class="line">channelRegistered</span><br><span class="line">channelActive</span><br><span class="line">channelRead</span><br><span class="line">channelReadComplete</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="客户端发送多次请求"><a href="#客户端发送多次请求" class="headerlink" title="客户端发送多次请求"></a>客户端发送多次请求</h3><p>客户端每隔 5 秒钟发送一次消息给服务端，查看效果如何？</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture channelFuture=bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">80</span>).sync();</span><br><span class="line">channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(future.isDone())&#123;</span><br><span class="line">            <span class="keyword">if</span>(future.isSuccess())&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//1秒钟之后，每隔5描述发送一次消息</span></span><br><span class="line">                channelFuture.channel().eventLoop().scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        channelFuture.channel().writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">1</span>,<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(future.isCancelled())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接被取消&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(future.cause()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接出错：&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handlerAdded</span><br><span class="line">channelRegistered</span><br><span class="line">channelActive</span><br><span class="line">channelRead</span><br><span class="line">channelReadComplete</span><br><span class="line">    </span><br><span class="line">channelRead</span><br><span class="line">channelReadComplete</span><br><span class="line">    </span><br><span class="line">channelRead</span><br><span class="line">channelReadComplete</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过执行结果我们发现，第一次的时候执行 handlerAdded ()、channelRegistered ()、channelActive ()，后面就不会被执行了。</p><p>客户端的每次请求时，都会触发 channelRead () 和 channelReadComplete () 两个核心方法。</p><h3 id="手工关闭通道"><a href="#手工关闭通道" class="headerlink" title="手工关闭通道"></a>手工关闭通道</h3><blockquote><p>疑问：channelInactive、channelUnregistered、handlerRemoved 什么时候会被执行呢？</p></blockquote><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;channelRead&quot;</span>);</span><br><span class="line">    <span class="comment">//手工关闭通道</span></span><br><span class="line">    ctx.channel().close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handlerAdded</span><br><span class="line">channelRegistered</span><br><span class="line">channelActive</span><br><span class="line">channelRead</span><br><span class="line">channelReadComplete</span><br><span class="line">channelInactive</span><br><span class="line">channelUnregistered</span><br><span class="line">handlerRemoved</span><br><span class="line">代码块<span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>总结，人为的关闭通道或者其他因素（比如：网络故障等），则会触发 channelInactive、channelUnregistered、handlerRemoved 的执行。</p><h3 id="生命周期总结"><a href="#生命周期总结" class="headerlink" title="生命周期总结"></a>生命周期总结</h3><p>我们来逐个总结一下每个回调方法的含义</p><ol><li>handlerAdded () ：当检测到新连接之后，调用 <code>ch.pipeline().addLast(new LifeCycleHandler());</code> 之后的回调，表示在当前的 channel 中，已经成功添加了一个 handler 到双向链表。</li><li>channelRegistered ()：这个回调方法，表示当前的 channel 的所有的逻辑处理已经和某个 NIO 线程建立了绑定关系，从线程池里面去抓一个线程绑定在这个 channel 上，这里的 NIO 线程通常指的是 NioEventLoop。</li><li>channelActive ()：当 channel 的所有的业务逻辑链准备完毕，channel 的 pipeline 中已经添加完所有的 handler 以及绑定好一个 NIO 线程之后，这条连接算是真正激活了，接下来就会回调到此方法。</li><li>channelRead ()：客户端向服务端发来数据，每次都会回调此方法，表示有数据可读。</li><li>channelReadComplete ()：服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕。</li><li>channelInactive (): 表面这条连接已经被关闭了，这条连接在 TCP 层面已经不再是 ESTABLISH 状态了。</li><li>channelUnregistered (): 既然连接已经被关闭，那么与这条连接绑定的线程就不需要对这条连接负责了，这个回调就表明与这条连接对应的 NIO 线程移除掉对这条连接的处理。</li><li>handlerRemoved ()：给这条连接上添加的所有的业务逻辑处理器都给移除掉。</li></ol><p>ChannelHandler 回调方法的执行顺序为</p><ol><li>连接请求，handlerAdded () -&gt; channelRegistered () -&gt; channelActive () -&gt; channelRead () -&gt; channelReadComplete ()；</li><li>数据请求，channelRead () -&gt; channelReadComplete ()；</li><li>通道被关闭，channelInactive () -&gt; channelUnregistered () -&gt; handlerRemoved ()。</li></ol><p><img src="https://s2.loli.net/2021/12/24/sXuwNYjyaigHCdn.png" alt="图片描述"></p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>本节内容主要讲解 ChannelHandler 的生命周期方法的执行顺序及触发机制，目的是了解每个方法的触发时间点，有助于业务点的扩展。核心掌握以下知识点：</p><ol><li>核心的生命周期方法有哪些，它们的触发时间点是什么；</li><li>channelRegistered 需要清楚，这个不容易理解；</li><li>channelRead 和 channelReadComplete 的区别，需要清楚；</li><li>通过三种 Demo 来说明了不同的生命周期方法的执行次数，有的是只执行一次，有的是每次都会执行。</li></ol><h1 id="ChannelHandler-性能优化"><a href="#ChannelHandler-性能优化" class="headerlink" title="ChannelHandler 性能优化"></a>ChannelHandler 性能优化</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>本节我们主要来继续讲解 ChannelHandler 的其它特性，主要讲解如何去进行 ChannelHandler 业务链表的常见性能优化。</p><h2 id="优化途径"><a href="#优化途径" class="headerlink" title="优化途径"></a>优化途径</h2><p>通常情况下为了提高自定义业务 Handler 的性能需要进行一定的优化策略，常见的优化方案分别是缩短传播路径、Handler 单利等。</p><ol><li><strong>传播路径：</strong> 如果业务很复杂的情况，由很多的 Handler 组成的时候，链条过长会消耗性能，因此，一般都是动态的删除一些没用的 Handler。</li><li><strong>Handler 单利：</strong> 每个客户端进来，都会为每个 Channel 创建一轮 Handler 并且加入到 Pipeline 进行管理，new 的过程是消耗性能的。</li></ol><p><img src="https://s2.loli.net/2021/12/24/B6fJSZeiF8rWlNc.png" alt="图片描述"></p><h2 id="热插拔"><a href="#热插拔" class="headerlink" title="热插拔"></a>热插拔</h2><p>上节我们学习了 ChannelHandler 的生命周期，其中有一个关键的方法是 handlerRemoved ()，在 handler 被移除的时候触发该事件，针对该事件，其实我们可以灵活的扩展自己的业务功能。</p><blockquote><p>需求：客户端和服务端之间通信，必须需要先认证。</p></blockquote><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">    .group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1.登录认证Handler</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> LoginHandler());</span><br><span class="line">            <span class="comment">//2.其他业务Handler</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> OtherHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>通过以上的代码，我们就能很好的解决了客户端登录认证问题，但是我们会发现，在登录认证成功之后，客户端发起其他类型请求的时候，每次请求 LoginHandler 都会被执行，那么应该怎么去解决这个问题呢？</p><blockquote><p>解决思路：在客户端第一次连接服务端时，进行账号认证，认证成功之后，把 LoginHandler 给移除掉。</p></blockquote><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.省略了部分代码（转换ByteBuf，对象流反序列化）</span></span><br><span class="line">        <span class="comment">//2.获取Map</span></span><br><span class="line">        Map&lt;String,String&gt; map=(Map&lt;String,String&gt;)iss.readObject();</span><br><span class="line">        <span class="comment">//3.认证账号、密码，并且响应</span></span><br><span class="line">        String username=map.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password=map.get(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(username.equals(<span class="string">&quot;admin&quot;</span>)&amp;&amp;password.equals(<span class="string">&quot;123456&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//3.1.给客户端响应</span></span><br><span class="line">            ctx.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;success&quot;</span>.getBytes()));</span><br><span class="line">            <span class="comment">//3.2.移除该Handler，这样下次请求就不会再执行该Handler了</span></span><br><span class="line">            ctx.pipeline().remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ctx.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;error&quot;</span>.getBytes()));</span><br><span class="line">            ctx.channel().closeFuture();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LoginHandler被移除&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>总结，动态新增和移除 Handler，也称之为<strong>热插拔</strong>，在真实项目开发当中其实非常的有用。</p><h2 id="Handler-单利"><a href="#Handler-单利" class="headerlink" title="Handler 单利"></a>Handler 单利</h2><h3 id="Shareable"><a href="#Shareable" class="headerlink" title="@Shareable"></a>@Shareable</h3><p><code>ch.pipeline().addLast(new LoginHandler());</code> 添加链表节点的时候，我们是手工 new 一个对象，其实也就是说，每个客户端连接进来的时候，都需要组建一条双向链表，并且都是 new 每个节点的对象，我们都知道每次 new 性能肯定是不高。</p><p>Spring 的 IOC 其实就是解决手工 new 对象的，项目启动的时候把所有对象创建完放到 Spring 容器，后面每次使用的时候无需再创建，而是直接从容器里面获取，这种方式可以提高性能。同样道理，Netty 也提供类似的功能，那就是 <code>@Shareable</code> 注解修饰的 Handler，只要用该注解修饰之后，那么该 Handler 就会变成共享，也就是说被所有的客户端所共享，无需每次都创建，自然性能会得到提升。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用注解修饰</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLoginHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提前创建好</span></span><br><span class="line">        <span class="keyword">final</span> ServerLoginHandler serverLoginHandler=<span class="keyword">new</span> ServerLoginHandler();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        serverBootstrap</span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//这里无需再创建，只需要传递实例即可</span></span><br><span class="line">                    ch.pipeline().addLast(serverLoginHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        serverBootstrap.bind(<span class="number">80</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="Shareable-线程不安全"><a href="#Shareable-线程不安全" class="headerlink" title="@Shareable 线程不安全"></a>@Shareable 线程不安全</h3><p>对于共享的 Handler，很容易就会出现线程安全问题，多个线程同时访问同一个对象不会出现任何的线程安全问题，但是有读有写，则就会产生线程安全问题，因此需要特别注意，因此，如果使用了 @Shareable 修饰了 Handler，那么千万不要包含全局变量、全局静态变量，否则就会出现线程安全问题。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLoginHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//全局变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//递增</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><blockquote><p>疑问：为什么以上的代码在并发情况下是不安全的呢？</p></blockquote><p>原因是，每个线程内部都会开辟一个内存空间，从主内存中拷贝 count 值，在线程中递增之后，再把结果写到主内存当中。并发情况下，多个线程之间可能取得的值是一样，然后线程之间又不可见性，因此就会导致线程不安全。</p><blockquote><p>解决：如果开发过程中遇到类似的问题，应该如何解决呢？</p></blockquote><p>直接使用 <code>AtomicXxx</code> 去代替，AtomicXxx 是 J.U.C 下提供的工具类，底层是通过 CAS 无锁机制去控制，保证线程安全。</p><h3 id="集成-Spring-容器"><a href="#集成-Spring-容器" class="headerlink" title="集成 Spring 容器"></a>集成 Spring 容器</h3><p>其实，在真实开发项目当中，一般都是把 Handler 直接交给 Spring 容器进行管理，也就是说在 Handler 类上添加 Spring 提供的 @Component 注解即可。</p><p><strong>主要目的：</strong></p><ol><li>统一把 Handler 交给 Spring 来管理；</li><li>Handler 一般都是需要和底层的数据库进行交互的，真实项目当中一般都是使用 Spring 来管理 ORM 组件，如果 Handler 不交给 Spring 管理，那么操作数据库的时候就会相对麻烦。</li></ol><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交给Spring容器管理</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLoginHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServerLoginHandler serverLoginHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里无需再创建，只需要传递实例即可</span></span><br><span class="line">ch.pipeline().addLast(serverLoginHandler);</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>本内容主要是从两个方面去进行业务 Handler 性能上面的优化，分别是</p><ol><li><strong>热插拔：</strong> 在执行过程中动态的删除无用的 Handler, 缩短 Handler 的传播距离；</li><li><strong>单例：</strong> 避免每个客户端的连接进来时都重复创建 Handler，使用单利的集中方式以及线程安全问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty 编解码器</title>
      <link href="posts/Netty%20%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
      <url>posts/Netty%20%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Netty-编码和解码"><a href="#Netty-编码和解码" class="headerlink" title="Netty 编码和解码"></a>Netty 编码和解码</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节内容，主要是讲解 Netty 的编码和解码，前面我们讲解了 ByteBuf，Netty 是面向 ByteBuf 来编程的，发送的内容会被编码成 ByteBuf，从 Channel 接受的数据流则被封装成了 ByteBuf，需要把它解码成我们所熟悉的格式。</p><h2 id="编码和解码的作用"><a href="#编码和解码的作用" class="headerlink" title="编码和解码的作用"></a>编码和解码的作用</h2><p>首先，我们先通过一个实例来进行说明。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> CodecHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodecHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接受：&quot;</span>+msg.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端发送数据：<br><img src="http://img.mukewang.com/wiki/5f377c1a0929f60112000325.jpg" alt="图片描述"></p><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接受：PooledUnsafeDirectByteBuf(ridx: <span class="number">0</span>, widx: <span class="number">5</span>, cap: <span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>通过以上测试，发现客户端往服务端发送普通的字符串，服务端接受的时候并不是正常字符串，而是把 ByteBuf 类型打印出来。</p><p>主要原因是，Netty 的数据类型是 ByteBuf，无法直接强转，需要通过解码的方式去转换才能得到正常的数据，编码也是同样道理。</p><p>因此，本节学编码和解码的知识可以了解 Netty 如何去接受和发送参数。</p><h2 id="解码示例"><a href="#解码示例" class="headerlink" title="解码示例"></a>解码示例</h2><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLoginHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.读取客户端发送过来的数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.转换ByteBuf</span></span><br><span class="line">        ByteBuf buffer=(ByteBuf)msg;</span><br><span class="line">        <span class="comment">//2.定义一个byte数组，长度是ByteBuf的可读字节数</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[buffer.readableBytes()];</span><br><span class="line">        <span class="comment">//3.往自定义的byte[]读取数据</span></span><br><span class="line">        buffer.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.字节流-&gt;字符串</span></span><br><span class="line">       String str=<span class="keyword">new</span> String(bytes);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，我们发现能正常接收并且打印客户端发送过来的字符串数据。但是如果是其它的类型数据（比如：Map，实体，List 等）那么还得手工写另外的转换方法，相对比较麻烦。</p><h2 id="编码解码流程"><a href="#编码解码流程" class="headerlink" title="编码解码流程"></a>编码解码流程</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>无论是使用 Netty 还是原始的 Socket 编程，基于 TCP 通信的数据包格式均为二进制，但是我们平时开发不可能基于二进制去开发，而是封装一个一个的实体。这样的话，我们就需要实现实体和二进制之间的编码和解码了。</p><ol><li>客户端往服务端发送消息，手写需要把实体转换成 byte []，并且把 byte [] 写入到 ByteBuf 容器里面，最终转换二进制。其实，整个过程就是一个编码的过程；</li><li>服务端接受到消息，二进制是给机器去识别的，人眼无法快速去识别它，然而实体是我们所熟悉并且一看就能看出有哪些属性，因此需要把二进制转换我们所熟悉的实体，整个过程就是一个解码的过程。</li></ol><p><img src="https://s2.loli.net/2021/12/24/lvOYjcKByhIe5oP.png" alt="图片描述"></p><h3 id="编码流程"><a href="#编码流程" class="headerlink" title="编码流程"></a>编码流程</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装编码方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">encode</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 ByteBuf 对象</span></span><br><span class="line">    ByteBuf byteBuf = ByteBufAllocator.DEFAULT.ioBuffer();</span><br><span class="line">    <span class="comment">// 2. 序列化 Java 对象</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = SerializeUtils.serialize(obj);</span><br><span class="line">    <span class="comment">// 3. 实际编码过程</span></span><br><span class="line">    byteBuf.writeBytes(bytes);</span><br><span class="line">    <span class="keyword">return</span> byteBuf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeUtils</span></span>&#123;</span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialize(Object obj)&#123;</span><br><span class="line">        <span class="comment">//省略序列化过程</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>创建一个 ByteBuf（前面章节详细讲解过）；</li><li>把内容序列化成字节数组；</li><li>把字节数组写入到 ByteBuf。</li></ol><h3 id="解码流程"><a href="#解码流程" class="headerlink" title="解码流程"></a>解码流程</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">decode</span><span class="params">(ByteBuf byteBuf,Class clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据包长度</span></span><br><span class="line">    <span class="keyword">int</span> length = byteBuf.readableBytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    byteBuf.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SerializeUtils.desrialize(bytes,clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeUtils</span></span>&#123;</span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">desrialize</span><span class="params">(<span class="keyword">byte</span>[] bytes,Class clazz)</span></span>&#123;</span><br><span class="line">        <span class="comment">//省略反序列化过程</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>根据 ByteBuf 获取可读的数据长度；</li><li>根据数据长度创建相应的字节数组；</li><li>把 ByteBuf 里面的内容读取到自定义的字节数组里面；</li><li>通过反序列化的手段，把字节数组反序列化成对象。</li></ol><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>上面讲编码和解码的时候，涉及两个空方法没有实现，分别是 <code>serialize()</code> 序列化和 <code>desrialize()</code> 反序列化，其实序列化和反序列化技术选择很多，常见的解决方案大概如下：</p><ol><li>通过对象流来手工实现序列化，但是实体必须实现 <code>Serializeable</code> 序列化接口，否则无法被正常序列化和反序列化；</li><li>对象 -&gt; 转换 json 格式的字符串，Java 里面 String 类型字符串可以自动转换字节数组，常见的开源框架分别有 Fastjson、Jackjson 等；</li><li>对象 - 转存 xml 格式的字符串，常见框架有 XStream 等；</li><li>其他技术，如：Hessian 序列化、Kryo 序列化等。</li></ol><p>这里就不详细展开展示序列化和反序列化的说明，如果有兴趣，可以参考我写的另外一篇文章：</p><p><a href="https://www.imooc.com/article/303099">https://www.imooc.com/article/303099</a></p><p>接下来，主要说明的是，为了灵活扩展，我们最好不要写死某种序列化技术，为了方便后期更改技术框架，因为每种序列化技术的差距比较大，主要体现两点：</p><ol><li><strong>消耗时间：</strong> 序列化和反序列化的消耗时间长度；</li><li><strong>数据长度：</strong> 序列化过后的字节数组长度，这个是会影响网络传输性能的。</li></ol><p>一般情况下，通过面向接口 + 策略模式的方式去解耦，底层可以灵活的切换序列化技术。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerializeService</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(T t);</span><br><span class="line">    <span class="comment">//反序列化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes,Class&lt;T&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体序列化实现列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonSerializeService</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">SerializeService</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(T t)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反序列化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//序列化使用</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SerializeService serializeService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">encode</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 ByteBuf 对象</span></span><br><span class="line">        ByteBuf byteBuf = ByteBufAllocator.DEFAULT.ioBuffer();</span><br><span class="line">        <span class="comment">// 2. 序列化 Java 对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializeService.serialize(obj);</span><br><span class="line">        <span class="comment">// 3. 实际编码过程</span></span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line">        <span class="keyword">return</span> byteBuf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节内容大家掌握好以下内容：</p><ol><li>编码和解码的概念是什么？为什么需要编码和解码？</li><li>Netty 如何去进行编码和解码，以及大体流程是什么？</li><li>编码和解码需要依赖序列化和反序列化技术，要了解序列化方面的技术有哪些。</li></ol><blockquote><p>思考题：能否把我们的编码和解码封装成独立的 Handler 呢？那么应该如何去封装呢？</p></blockquote><h1 id="如何自定义编解码器"><a href="#如何自定义编解码器" class="headerlink" title="如何自定义编解码器"></a>如何自定义编解码器</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>上一节我们一节了解了什么是编码解码、序列化和反序列化了，并且留有一道思考题，本节内容主要是深入解析该思考题。</p><blockquote><p>思考题：能否把我们的编码和解码封装成独立的 Handler 呢？那么应该如何去封装呢？</p></blockquote><h2 id="为什么要封装独立-Handler？"><a href="#为什么要封装独立-Handler？" class="headerlink" title="为什么要封装独立 Handler？"></a>为什么要封装独立 Handler？</h2><p>即使我们把编码和解码封装成了方法，但是还是需要在 Handler 业务逻辑里面进行手工调用，虽然看似不怎么影响，但是业务 Handler 不够纯粹，应该让 Handler 只是专心的负责处理业务逻辑就好。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyEncoderHandler());<span class="comment">//解码Handler</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyDecoderHandler());<span class="comment">//编码Handler</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyBusiHandler());<span class="comment">//业务Handler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBusiHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.接受参数，可以直接强转</span></span><br><span class="line">        UserReq userReq=(UserReq)msg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.相应数据，直接写对象</span></span><br><span class="line">        UserRes res=<span class="keyword">new</span> UserRes();</span><br><span class="line">        res.setCode(<span class="number">0</span>);</span><br><span class="line">        res.setMsg(<span class="string">&quot;接受成功&quot;</span>);</span><br><span class="line">        ctx.writeAndFlush(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上的代码，我们把编码和解码封装成两个独立的 Handler，并且加入到 ChannelPipeline 里面进行管理。在我们的业务 Handler 里面就可以直接操作实体数据，无需手工转换成字节数组了。</p><blockquote><p>思考：那么如何进行封装 Handler 呢？</p></blockquote><h2 id="StringDecoder-和-StringEncoder"><a href="#StringDecoder-和-StringEncoder" class="headerlink" title="StringDecoder 和 StringEncoder"></a>StringDecoder 和 StringEncoder</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>StringDecoder 和 StringEncoder 是 Netty 为我们提供的专门针对普通字符串的解码和编码器，使用起来非常的简单。</p><p>客户端直接发送字符串。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ClientTestHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//客户端直接写字符串，没有任何的数据加工</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码块<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>服务端直接强转字符串。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ServerTestHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//直接把msg转换成String类型</span></span><br><span class="line">        String str=msg.toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;str=&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码块<span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>总结，这种模式开发起来实在太方便了，无需做数据的加工，我们还是按照我们熟悉的方式去写代码，非常的方便。</p><p>但是，它只是支持普通的字符串类型进行编码和解码而已，对于复杂的引用类型则无效。</p><h3 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h3><p>其实原理是非常的简单的，请看下图。</p><p><img src="https://s2.loli.net/2021/12/24/NZbspkQWJAvSqKE.png" alt="图片描述"><br><strong>执行流程说明：</strong></p><ol><li>StringDecoder 必须放在业务 Handler 之前，因为都是 InboundHandler，需要按顺序执行；</li><li>StringEncoder 放在业务 Handler 之前，则可以使用 ctx.writeAndFlush () 输出数据，也可以使用 ctx.channel ().writeAndFlus () 输出数据（ChannelHandler 已经讲过原理了）；</li><li>StringEncoder 放在业务 Handler 之后，则只能使用 <code>ctx.channel().writeAndFlush()</code> 输出数据。</li></ol><h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><blockquote><p>思考：StringDecoder 和 StringEncoder 到底怎么实现的呢？</p></blockquote><p>StringDecoder 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//直接msg.toString()</span></span><br><span class="line">        out.add(msg.toString(<span class="keyword">this</span>.charset));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 StringDecoder 的源码非常的简单，直接<code>.toString()</code> 转换即可。</p><p>StringEncoder 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">CharSequence</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, CharSequence msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//继续跟进源码</span></span><br><span class="line">            out.add(ByteBufUtil.encodeString(ctx.alloc(), CharBuffer.wrap(msg), <span class="keyword">this</span>.charset));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">encodeString</span><span class="params">(ByteBufAllocator alloc, CharBuffer src, Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续跟进源码</span></span><br><span class="line">    <span class="keyword">return</span> encodeString0(alloc, <span class="keyword">false</span>, src, charset, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保留核心源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteBuf <span class="title">encodeString0</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">boolean</span> enforceHeap, CharBuffer src, Charset charset, <span class="keyword">int</span> extraCapacity)</span> </span>&#123;</span><br><span class="line">    CharsetEncoder encoder = CharsetUtil.encoder(charset);</span><br><span class="line">    <span class="keyword">int</span> length = (<span class="keyword">int</span>)((<span class="keyword">double</span>)src.remaining() * (<span class="keyword">double</span>)encoder.maxBytesPerChar()) + extraCapacity;</span><br><span class="line">    <span class="keyword">boolean</span> release = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建ByteBuf分配器</span></span><br><span class="line">    ByteBuf dst;</span><br><span class="line">    <span class="keyword">if</span> (enforceHeap) &#123;</span><br><span class="line">        dst = alloc.heapBuffer(length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dst = alloc.buffer(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBuf var12;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.得到NIO的ByteBuffer【跟进Netty的ByteBuf基本上一样】</span></span><br><span class="line">        ByteBuffer dstBuf = dst.internalNioBuffer(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> pos = dstBuf.position();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.把内容写得NIO的ByteBuffer</span></span><br><span class="line">        CoderResult cr = encoder.encode(src, dstBuf, <span class="keyword">true</span>);</span><br><span class="line">        cr = encoder.flush(dstBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.更新ByteBuf的写指针writeIndex</span></span><br><span class="line">        dst.writerIndex(dst.writerIndex() + dstBuf.position() - pos);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.给var12赋值</span></span><br><span class="line">        var12 = dst;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CharacterCodingException var16) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var16);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致流程就是把字符串内容转换成 NIO 的 ByteBuffer，这里大致知道整个流程即可，不用深究每行代码的意思，其实 Netty 的 ByteBuf 底层就是基于 ByteBuffer 进行封装的。</p><h2 id="自定义编解码器"><a href="#自定义编解码器" class="headerlink" title="自定义编解码器"></a>自定义编解码器</h2><p>通过上面 Demo 的学习，以及 StringDecoder 和 StringEncoder 两个类的学习，相信大家更加能理解编解码器了，毕竟 StringDecoder 和 StringEncoder 从字面意思也能理解它们是针对字符串格式的，如果我们想要传递一个实体那么怎么办呢？</p><p>主要解决方案有两种：</p><p><strong>方案一：</strong> 把实体转换成 json 格式字符串，然后依然使用 StringDecoder 和 StringEncoder 编解码器，但是每次手工转换和解析，非常的麻烦；<br><strong>方案二：</strong> 自定义针对实体的编解码器，并且加入到双向链表里面，这样就可以传递自定义实体了。</p><p>下面主要讲解如何实现针对实体的编解码器：</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p><strong>核心步骤：</strong></p><ol><li>继承 MessageToByteEncoder，重写 encode 方法；</li><li>把 User 对象转换成 byte []；</li><li>把 byte [] 写到 ByteBuf。</li></ol><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                          User user, </span></span></span><br><span class="line"><span class="function"><span class="params">                          ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.对象流</span></span><br><span class="line">        ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes=os.toByteArray();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//2.关闭流</span></span><br><span class="line">        oos.close();</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.写到ByteBuf容器</span></span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p><strong>核心步骤：</strong></p><ol><li>继承 ByteToMessageDecoder，重写 decode 方法；</li><li>自定义一个 byte [] 数组，长度是 ByteBuf 的可读长度；</li><li>把 ByteBuf 转换成 User 实体。</li></ol><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                          ByteBuf byteBuf, </span></span></span><br><span class="line"><span class="function"><span class="params">                          List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.定义byte[]，长度为ByteBuf可读长度</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">        <span class="comment">//2.往byte[]读取数据</span></span><br><span class="line">        byteBuf.readBytes(bytes);</span><br><span class="line"><span class="comment">//3.对象流</span></span><br><span class="line">        ByteArrayInputStream is=<span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream iss=<span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">        User user=(User)iss.readObject();</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        is.close();</span><br><span class="line">        iss.close();</span><br><span class="line"><span class="comment">//5.添加到集合</span></span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加到-Pipeline"><a href="#添加到-Pipeline" class="headerlink" title="添加到 Pipeline"></a>添加到 Pipeline</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.解码器</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> MyDecoder());</span><br><span class="line">        <span class="comment">//2.编码器</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> MyEncoder());</span><br><span class="line">        <span class="comment">//3.业务Handler</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> ServerTestHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>通常情况下，需要把编解码器分别独立封装成 Handler，并且加入到 ChannelPipeline 进行管理，主要目的是简化繁琐的编码和解码的步骤，让业务 Handler 更加专注去处理业务逻辑，更加的符合开发人员的习惯。</p><p>本节主要掌握以下两点内容</p><ol><li>如果针对字符串，那么可以使用 Netty 内置的编解码器，分别是 StringEncoder 和 StringDecoder；</li><li>如果是其它引用类型，主要有两种方式，①转换成字符串格式；②自定义编解码器。</li></ol><h1 id="Netty-内置编解码器"><a href="#Netty-内置编解码器" class="headerlink" title="Netty 内置编解码器"></a>Netty 内置编解码器</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>上节我们讲解了 Netty 的内置编码器以及自定义编码器，本节主要讲解 Netty 提供的几个核心编解码器的抽象类，主要是 <code>MessageToByteEncoder</code>、<code>ByteToMessageDecoder</code>、<code>SimpleChannelInboundHandler</code>。</p><h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><p>Netty 官方也是考虑到了如何减轻开发人员的繁琐、重复性的工作，因此，它内置了一些好用的编解码器抽象，让我们更加便捷的自定义自己想要的编解码器。</p><p>通过本节学习，我们需要掌握以下几点</p><ol><li>有哪些编解码器的抽象；</li><li>它们的核心原理是什么。</li></ol><h2 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h2><p><img src="https://s2.loli.net/2021/12/24/8G2Ve4fpBmjlDXn.png" alt="图片描述"></p><h2 id="MessageToByteEncoder"><a href="#MessageToByteEncoder" class="headerlink" title="MessageToByteEncoder"></a>MessageToByteEncoder</h2><p>从字面意思上可知，它主要是把消息内容转换成 Byte，也就是说是编码。使用非常的简单，继承 <code>MessageToByteEncoder</code> 可以很容易的开发一个 Handler。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">BaseBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                          BaseBean baseBean, </span></span></span><br><span class="line"><span class="function"><span class="params">                          ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.把“数据”转换成字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes= JSON.toJSONBytes(baseBean);</span><br><span class="line"><span class="comment">//2.把字节数组往ByteBuf容器写</span></span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyEncoder());</span><br></pre></td></tr></table></figure><p>源码：保留核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">I</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类型匹配器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeParameterMatcher matcher;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MessageToByteEncoder</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">this</span>.matcher = TypeParameterMatcher.find(<span class="keyword">this</span>, MessageToByteEncoder.class, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.preferDirect = preferDirect;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.acceptOutboundMessage(msg)) &#123;</span><br><span class="line">            <span class="comment">//类型判断通过，则处理</span></span><br><span class="line">            </span><br><span class="line">            I cast = msg;</span><br><span class="line">            <span class="comment">//创建ByteBuf</span></span><br><span class="line">            buf = <span class="keyword">this</span>.allocateBuffer(ctx, msg, <span class="keyword">this</span>.preferDirect);</span><br><span class="line"><span class="comment">//调用抽象方法（由子类实现）</span></span><br><span class="line">            <span class="keyword">this</span>.encode(ctx, cast, buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//类型判断不通过，则往下流转</span></span><br><span class="line">            ctx.write(msg, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext var1, I var2, ByteBuf var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ByteToMessageDecoder"><a href="#ByteToMessageDecoder" class="headerlink" title="ByteToMessageDecoder"></a>ByteToMessageDecoder</h2><p>从字面上我们也很容易猜到它的作用，主要是把 Byte 类型的数据转换成对应实体，也称之为解码。使用非常的简单。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"><span class="comment">//把ByteBuf反序列化，并且添加到List里面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List out)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//1.定义byte[]，长度为ByteBuf可读长度</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">        <span class="comment">//2.往byte[]读取数据</span></span><br><span class="line">        byteBuf.readBytes(bytes);</span><br><span class="line"><span class="comment">//3.对象流</span></span><br><span class="line">        ByteArrayInputStream is=<span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream iss=<span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">        User user=(User)iss.readObject();</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        is.close();</span><br><span class="line">        iss.close();</span><br><span class="line"><span class="comment">//5.添加到集合</span></span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承了 <code>ByteToMessageDecoder</code> 这个类之后，我们只需要实现一下 decode () 方法，这里的 in 大家可以看到，传递进来的时候就已经是 ByteBuf 类型，所以我们不再需要强转，第三个参数是 List 类型，我们通过往这个 List 里面添加解码后的结果对象，就可以自动实现结果往下一个 handler 进行传递，我们就实现了解码的逻辑 handler。</p><h2 id="SimpleChannelInboundHandler"><a href="#SimpleChannelInboundHandler" class="headerlink" title="SimpleChannelInboundHandler"></a>SimpleChannelInboundHandler</h2><p>前面讲解 ChannelHandler 多业务情况下的时候，我们讲解到了 <code>SimpleChannelInboundHandler</code>，它的核心作用是自动判断数据格式类型，并且转发给对应的 Handler 来处理。</p><p>一般来说，Netty 开发的应用如果很复杂的时候，那么应该如何处理呢？通常有三种方案。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>对反序列化后的结果进行类型判断，不同的类型做不同的业务处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//对反序列化后的结果进行类型判断，不同的类型做不同的业务处理</span></span><br><span class="line">    <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> LoginReqBean)&#123;</span><br><span class="line">        login((LoginReqBean) msg,ctx.channel());</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> MsgReqBean)&#123;</span><br><span class="line">        sendMsg((MsgReqBean)msg,ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式比较简单，但是通过 <code>if else</code> 逻辑进行逻辑的处理，当我们要处理的指令越来越多的时候，代码会显得越来越臃肿。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>判断是否是自己应该处理，如果不是，则手工往下流转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> LoginReqBean)&#123;</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//往下流转</span></span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>使用 <code>SimpleChannelInboundHandler</code> 来简化我们的指令处理逻辑。</p><p><code>SimpleChannelInboundHandler</code> 使用非常简单，我们在继承这个类的时候，给他传递一个泛型参数，然后在 channelRead0 () 方法里面，我们不用再通过 if 逻辑来判断当前对象是否是本 handler 可以处理的对象，也不用强转，不用往下传递本 handler 处理不了的对象，这一切都已经交给父类 <code>SimpleChannelInboundHandler</code> 来实现了，我们只需要专注于我们要处理的业务逻辑即可。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginReqHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LoginReqBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginReqBean loginReqBean)</span></span>&#123;</span><br><span class="line">        <span class="comment">//登录逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgReqHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MsgReqBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MsgReqBean msgReqBean)</span></span>&#123;</span><br><span class="line">        <span class="comment">//消息发送逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码：只保留核心部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">I</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类型匹配器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeParameterMatcher matcher;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SimpleChannelInboundHandler</span><span class="params">(<span class="keyword">boolean</span> autoRelease)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化类型匹配器</span></span><br><span class="line">        <span class="keyword">this</span>.matcher = TypeParameterMatcher.find(<span class="keyword">this</span>, SimpleChannelInboundHandler.class, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.acceptInboundMessage(msg)) &#123;</span><br><span class="line">            <span class="comment">//类型校验通过通过，则调用抽象方法（子类去实现）</span></span><br><span class="line">            <span class="keyword">this</span>.channelRead0(ctx, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//类型校验不通过，则往下流转</span></span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象方法，由自定义业务类去实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext var1, I var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>本节学习主要掌握以下知识点</p><ol><li>基于 MessageToByteEncoder，我们可以实现自定义编码，而不用关心 ByteBuf 的创建，不用每次向写数据的时候，都手工进行编码；</li><li>基于 ByteToMessageDecoder，我们可以实现自定义解码，而不用关心 ByteBuf 的强转和 解码结果的传递；</li><li>基于 SimpleChannelInboundHandler，我们可以实现根据数据格式来判断由哪个 Handler 去处理，不需要手工 <code>if else</code> 判断，不需要手动传递对象，做到了真正关心业务逻辑的处理；</li><li>其实，这三种 Handler 也是有各自的应用场景，<code>ByteToMessageDecoder</code> 和 <code>MessageToByteEncoder</code> 是用来封装解码器和编码器，<code>SimpleChannelInboundHandler</code> 则是用于业务逻辑的简化开发。</li></ol><h1 id="Netty-粘包和拆包"><a href="#Netty-粘包和拆包" class="headerlink" title="Netty 粘包和拆包"></a>Netty 粘包和拆包</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>前面几个章节主要解析了 Netty 的编码、解码问题，那么是否有了编解码器，我们的 Netty 通信就能正常了呢？</p><p>TCP 协议在传输数据时没有办法判断数据是什么时候结束的，它无法识别一段完整的信息，因此可能会导致接受到的数据和发送时的数据不一致的情况。因此需要人为的指定一种规范的协议，从而保证数据的安全性，比如：我们所熟悉的 HTTP 协议。</p><p>本节内容，我们主要需要以下两点知识</p><ol><li>TCP 拆包、粘包的原因；</li><li>TCP 拆包、粘包的解决方案。</li></ol><h2 id="学习目的-1"><a href="#学习目的-1" class="headerlink" title="学习目的"></a>学习目的</h2><p>拆包、粘包在 TCP 协议当中，或者说 Netty 开发当中必须需要去解决的问题。在开发当中，你会发现你不需要解决拆包、粘包问题，数据也是能正常发送和接受，那么为什么需要去解决呢？</p><p>原因是，数据量比较小，TCP 发送之前它是有个缓冲池的，根据缓冲池的大小来把数据包拆分成多个小包进行发送。在高并发的情况下，拆包、粘包问题是经常会发生的，因此需要去 解决，否则接收方将获取不到正确的数据。</p><h2 id="粘包和拆包问题解析"><a href="#粘包和拆包问题解析" class="headerlink" title="粘包和拆包问题解析"></a>粘包和拆包问题解析</h2><h3 id="模拟拆包粘包问题"><a href="#模拟拆包粘包问题" class="headerlink" title="模拟拆包粘包问题"></a>模拟拆包粘包问题</h3><p>开始，之前我们先看一个简单的案例，具体如下所示：</p><p><strong>客户端：</strong> 客户端使用 for 循环，连续向服务端发送 <code>hello world</code>1000 遍（使用 StringEncoder 编码器）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            ctx.channel().writeAndFlush(</span><br><span class="line">                Unpooled.copiedBuffer(<span class="string">&quot;hello world 世界你好,Netty技术学习&quot;</span>.getBytes())</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端：</strong> 正常输出客户端的信息（使用 StringDecoder 解码器）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str=msg.toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong><br><img src="http://img.mukewang.com/wiki/5f377f3e09006aa606330241.jpg" alt="图片描述"></p><p><strong>总结：</strong><br>通过以上的输出结果，我们发现，客户端发送过来的数据，有时候能正确打印，有时候数据粘在了一起。以上输出结果有乱码想象、有多个信息输出到一行，就是 ByteBuf 粘包和 ByteBuf 半包。</p><p>通过上面的简单案例，我们发现 TCP 协议下会产生数据安全性问题，其实在 TCP 中粘包和拆包是不可避免的，因为在 TCP 协议中，数据流向水流一样，根本不知道应该从哪里截取才是完整的数据包。TCP 并不了解上层业务的数据含义，它会根据 TCP 缓冲区的实际情况进行包的划分，因此一个完整的业务包可能会被 TCP 拆分成多个包进行发送，也可能会把多个小包封装成一个大包进行发送，这就是 TCP 粘包和拆包问题。</p><h3 id="常见的原因分析"><a href="#常见的原因分析" class="headerlink" title="常见的原因分析"></a>常见的原因分析</h3><p>粘包和拆包其实是客户端和服务端之间都会发生的事情，并不是说只是在客户端产生或者服务端产生，具体分析如下：</p><p><strong>发送方的粘包和拆包问题</strong></p><ol><li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包，也就是拆分几次发送；</li><li>要发送数据大于最大报文长度，TCP 在传输前将进行拆包，也就是拆分几次发送；</li><li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li></ol><p><strong>接收方的粘包和拆包问题</strong></p><ol><li>服务端分两次读取到独立的数据包，那么解析出来的数据正常，没有粘包和拆包问题；</li><li>服务端一次读取两个数据包，那么这些数据包就会粘合在一起，因此称为粘包；</li><li>服务端分两次读取两个数据包，第一次读到数据 1 和数据 2 部分内容，第二次读取数据 2 剩余内容，这被成为 TCP 拆包。</li></ol><p><strong>粘包和拆包的示意图</strong></p><p><img src="https://s2.loli.net/2021/12/24/5A32DCsbLkRyQj1.png" alt="图片描述"></p><p>总结，拆包和粘包问题并不是某一方的问题，可能是发送的粘包和拆包导致接收方读取数据出错，也可能是发送方正常，但是接收方读取出错。但是我们只需要了解，发送方和接收方什么情况下会拆包和粘包。</p><h2 id="Netty-提供的粘包拆包解决方案"><a href="#Netty-提供的粘包拆包解决方案" class="headerlink" title="Netty 提供的粘包拆包解决方案"></a>Netty 提供的粘包拆包解决方案</h2><p>虽然，在 Netty 当中是基于 ByteBuf 字节容器去编程，但是底层还是会被转换成字节流进行传输， 数据到了服务端，也是按照字节流的方式读入，然后到了 Netty 应用层面，重新拼装成 ByteBuf。如果为了数据的完整性，通常的解决方案如下：</p><ol><li>每次读取完都需要判断是否是一个完整数据包 ；</li><li>如果当前读取的数据不足以拼接成一个完整数据包，那就保留该数据，继续从 TCP 缓冲器读取，直到拼接成一个完整数据包为止；</li><li>如果拼接成了完整的数据包，但是有多余的数据，则仍然保留，以便和下次读取的数据进行拼接。</li></ol><blockquote><p>思考：那么应该如何去判断一个业务数据的完整结束呢？</p></blockquote><p><strong>方案一：</strong> 固定数据长度，客户端在发送数据的时候，每个数据包的长度固定（比如：1024 个字节），如果发送数据不足 1024 字节时，以空格补齐；服务端则每次读取固定长度是数据；<br><strong>方案二：</strong> 分隔符，每个数据包的结尾加一个特殊分隔符，服务端则读取到特殊分隔符则认为数据包结束；如果一次读取的数据没有结束符，则保留当前数据，等待下次读取；<br><strong>方案三：</strong> 将数据分为消息头和消息体，在头部保存了消息的数据长度，只有读取指定长度的数据就算完整数据包；<br><strong>方案四：</strong> 自定义协议，通过协议的规范进行发送和接受数据。</p><p>当然，以上的方案 Netty 官方也考虑到了，并且为了简化开发人员的工作量，Netty 内置了常见的拆包器，具体如下：</p><p><strong>1. 固定长度的拆包器 FixedLengthFrameDecoder</strong></p><p>每个数据包的长度都是固定的，比如 1024，那么只需要把这个拆包器加到 pipeline 中，Netty 会把一个个长度为 1024 的数据包 (ByteBuf) 传递到下一个 channelHandler。</p><p><strong>2. 行拆包器 LineBasedFrameDecoder</strong></p><p>它是一个特殊的分隔符拆包器，以换行符作为结束符。</p><p><strong>3. 分隔符拆包器 DelimiterBasedFrameDecoder</strong></p><p>可以自定义自己的分隔符。</p><p><strong>4. 基于长度域拆包器 LengthFieldBasedFrameDecoder</strong></p><p>是最通用的一种拆包器，有一个存放数据长度的字段，读到该字段之后，往后面的数据读取一定长度的数据即可，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>本节内容需要掌握的知识点</p><ol><li>什么是拆包、粘包问题，以及它的产生原因是什么？</li><li>解决拆包、粘包问题的思路以及常见解决方案是什么？</li></ol><h1 id="Netty-通讯协议设计概要"><a href="#Netty-通讯协议设计概要" class="headerlink" title="Netty 通讯协议设计概要"></a>Netty 通讯协议设计概要</h1><h2 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h2><p>上节内容，我们主要介绍了 Netty 的粘包和拆包问题，并且大致介绍了 Netty 提供的常见拆包器，分别是固定长度拆包器、行拆包器、分隔符拆包器、基于长度域拆包器，但是它们只是相对简单的协议，也就是说无法满足复杂的业务场景，因此，我们可以通过自定义协议的方式去解决 TCP 的粘包和拆包问题。</p><h2 id="了解什么是协议"><a href="#了解什么是协议" class="headerlink" title="了解什么是协议"></a>了解什么是协议</h2><p>首先，我们大概了解什么是协议，协议可以把它认为是一种规则而不是技术，约束客户端和服务端之间通讯，数据组装和拆分的一种规范。客户端安装某种规范去组装数据，把数据传输给服务端，服务端再安装这种规范拆解数据，那么这就是一种协议，可以根据实际业务区指定符合自身的协议，其实基于 Netty 去制定的私有协议，我个人接触过的是传输车辆 GPS 数据的 809 协议，在和 GPS 服务器通讯时，必须按照该协议去进行封装和解析数据，否则通讯异常。</p><p>其实，类似的规则还有很多，从开发的角度来说，都是各种规则和约束，比如说：前面提到的序列化技术，序列化其实就是把数据按照某种规则去转换成 byte 数字，而反序列化就是按照这种规则再去把字节流转换成对应的类型数据。这些都是基于某种规则的基础上，使用技术的手段去封装的结果。</p><h2 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h2><h3 id="协议架构"><a href="#协议架构" class="headerlink" title="协议架构"></a>协议架构</h3><p><strong>思路架构图：</strong></p><p>首先，我们先来了解协议在整个通讯当中的扮演的角色，如下图所示：</p><p><img src="http://img.mukewang.com/wiki/5f433dea09162d1709640621.jpg" alt="图片描述"><br>如上图所示，客户端和服务端之间的通讯流程：</p><p><strong>客户端发送数据</strong></p><ol><li>客户端先把一个对象序列化成字节流；</li><li>然后把字节流根据协议把字节流组装好；</li><li>最后转换成二进制传输到网络。</li></ol><p><strong>服务端接受数据</strong></p><ol><li>从网络中读取二进制数据到本地的缓冲区；</li><li>根据协议的规则读取指定数据，并且识别是否是完整的数据包；</li><li>如果是完整的数据包，则转换成实体对象。</li></ol><p>由此可见，协议主要是管理字节流格式的一种规则，如果把协议环节去掉，那么服务端就无法知道字节流的结束位置。</p><h3 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h3><p><img src="https://s2.loli.net/2021/12/24/ykl69CtuwjhPdWi.png" alt="图片描述"></p><p><strong>协议介绍：</strong></p><ol><li>协议标识符，以一个固定数作为标识符，占用 4 个字节，主要目的是用来识别协议的开头，只要是以该标识开头的协议则进行处理，否则不处理。主要目的是提高处理性能问题，如果随便一个请求都需要进行处理，但是最终处理起来发现协议格式不对，抛异常，肯定会影响系统性能；</li><li>数据长度，占用 4 个字节，标识数据的真实长度，获取到该值后，往后读取指定长度的数据即可。主要目的是防止粘包和拆包安全性问题；</li><li>指令，协议是某个应用所有的业务公用的一种规则，那么应该如何区分是哪种业务呢？这里主要通过指令来进行区分；</li><li>数据，这部分存储的是真实的数据。</li></ol><p>这算是比较简单，并且常用的设计思路，主要和 Netty 内置的基于长度域拆包器类似，基本上都是有一个字段是用来存储真实的数据长度，这样才能准确的读取数据的完整内容。当然，还可以在该设计基础上加上更多的字段，比如：使用的序列号技术、协议版本号等等。</p><h3 id="技术栈说明"><a href="#技术栈说明" class="headerlink" title="技术栈说明"></a>技术栈说明</h3><p>相信到这里，大家对协议基本上有一个简单的认识了，其实协议并不难，它只是一个约束而已，那么我们如何通过技术的实现，让协议生效呢？主要的核心思想如下：</p><ol><li>序列化和发序列话技术，这个在 Netty 的编解码的时候已经讲过，序列化可以把对象转化成字节流，反序列化可以把字节流转换成对象；</li><li>字节容器（字节缓冲区），必须按照协议的字段顺序往字节容器里面存放对应的字节内容，然后把整个容器写到网络当中。这样数据才能按照顺序进行传输，服务端才能按照顺序进行数据的读取和处理。</li></ol><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>本节主要介绍协议的思想，它就是一种规则，客户端和服务端必须需要遵守的规则，才能保证数据的安全性。其次，讲解了协议在客户端和服务端通讯当中所扮演的角色，如果没有协议，那么服务端一直读取字节流，根本无法知道数据的完整性。最后，大概介绍了协议设计的大概思想，主要核心字段有四个，分别是协议标识符、数据长度、指令、数据，这四个字段是满足协议的基本元素，可以根据实际业务再进行扩展字段。</p><h1 id="Netty-通讯协议功能实现"><a href="#Netty-通讯协议功能实现" class="headerlink" title="Netty 通讯协议功能实现"></a>Netty 通讯协议功能实现</h1><h2 id="前言-5"><a href="#前言-5" class="headerlink" title="前言"></a>前言</h2><p>上节内容，我们主要讲解了 Netty 通讯协议设计，其实思路很简单就是核心的四个字段，分别是协议标识符、数据长度、指令、数据。还有其中涉及的技术主要是序列化和反序列化技术以及字节容器。那么本节主要是基于这个思想去实现我们的自定义协议，并且测试客户端循环 1000 遍发送数据是否还会出现粘包和拆包问题。</p><p><strong>技术栈说明</strong></p><ol><li>主要是使用对象流进行序列化和反序列化（ObjectInputStream 和 ObjectOutputStream）；</li><li>字节容器主要是以 Netty 的 ByteBuf 来管理字节。</li></ol><h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p><img src="https://s2.loli.net/2021/12/24/lI6uiZhqYw938AT.png" alt="图片描述"></p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                          User user, </span></span></span><br><span class="line"><span class="function"><span class="params">                          ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建一个内存输出流</span></span><br><span class="line">        ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">//2.创建一个对象输出流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">        <span class="comment">//3.把user对象写到内存流里面</span></span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        <span class="comment">//4.通过内存流获取user对象转换后的字节数字</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=os.toByteArray();</span><br><span class="line">        <span class="comment">//5.关闭流</span></span><br><span class="line">        oos.close();</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.根据协议组装数据</span></span><br><span class="line">        byteBuf.writeInt(<span class="number">1</span>);<span class="comment">//标识</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">1</span>);<span class="comment">//指令</span></span><br><span class="line">        byteBuf.writeInt(bytes.length);<span class="comment">//长度</span></span><br><span class="line">        byteBuf.writeBytes(bytes);<span class="comment">//数据内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>自定义一个编码器，把客户端向服务端发送的数据进行加工，主要是转换字节流，然后根据自定义协议来组装数据；</li><li>标识占用四个字节，使用 writeInt ()，一个 int 表示四个字节；</li><li>指令占用一个字节，因此使用 writeByte () 即可；</li><li>数据长度占用四个字节，因此使用 writeByte ()，int 表示的最大值一般来说足够表示数据的内容了，除非特别特别大的数据（比如：超级大文件的传输）则可以使用 writeLong () 来表示数据长度。</li></ol><h3 id="解码实现"><a href="#解码实现" class="headerlink" title="解码实现"></a>解码实现</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ChannelHandlerContext channelHandlerContext, </span></span></span><br><span class="line"><span class="function"><span class="params">        ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.根据协议分别取出对应的数据</span></span><br><span class="line">        <span class="keyword">int</span> tag=byteBuf.readInt();<span class="comment">//标识符</span></span><br><span class="line">        <span class="keyword">byte</span> code=byteBuf.readByte();<span class="comment">//指令</span></span><br><span class="line">        <span class="keyword">int</span> len=byteBuf.readInt();<span class="comment">//长度</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[len];<span class="comment">//定义一个字节数据，长度是数据的长度</span></span><br><span class="line">        byteBuf.readBytes(bytes);<span class="comment">//往字节数组读取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过对象流来转换字节流，转换成User对象</span></span><br><span class="line">        ByteArrayInputStream is=<span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream iss=<span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">        User user=(User)iss.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        iss.close();</span><br><span class="line"></span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong><br>这里主要是实现了解码器，主要目的是通过自定义协议来分别读取对应的数据，并且通过对象流来反序列化字节流。</p><h3 id="发送方-Handler"><a href="#发送方-Handler" class="headerlink" title="发送方 Handler"></a>发送方 Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            User user=<span class="keyword">new</span> User();</span><br><span class="line">            user.setName(i+<span class="string">&quot;-&gt;zwy&quot;</span>);</span><br><span class="line">            user.setAge(<span class="number">18</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注意，这里直接写user对象，无需再手工转换字节流了，编码器会自动帮忙处理。</span></span><br><span class="line">            ctx.channel().writeAndFlush(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong><br>客户端在链接就绪时，使用 for 循环给服务端发送数据，主要目的是检测是否会产生数据粘包和拆包问题。</p><h3 id="接受方-Handler"><a href="#接受方-Handler" class="headerlink" title="接受方 Handler"></a>接受方 Handler</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user=(User)msg;</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加入-Pipeline"><a href="#加入-Pipeline" class="headerlink" title="加入 Pipeline"></a>加入 Pipeline</h3><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.拆包器</span></span><br><span class="line">ch.pipeline().addLast(</span><br><span class="line">    <span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//2.自定义编码器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyEncoder());</span><br><span class="line"><span class="comment">//3.业务处理Handler</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ClientTestHandler());</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Netty内置拆包器</span></span><br><span class="line">ch.pipeline().addLast(</span><br><span class="line">    <span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//2.自定义解码器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyEncoder());</span><br><span class="line"><span class="comment">//3.业务Handler</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ServerTestHandler());</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>需要往双向链表里面加入三个特殊的 Handler，分别是 <code>LengthFieldBasedFrameDecoder</code> 和自定义的编码器、解码器；</li><li><code>LengthFieldBasedFrameDecoder</code> 拆包器的构造函数字段说明，分别如下所示：<br>2.1 第一个参数，maxFrameLength：解码时，处理每个帧数据的最大长度，一般来说直接赋予 <code>Integer.MAX_VALUE</code> 即可；<br>2.2 第二个参数，lengthFieldOffset ：存放帧数据的长度数据的起始位（偏移位），通俗点说，就是表示数据长度的字段在整个协议里面所处的位置，由于协议的结果是：协议标识（4 个字节）、指令（1 个字节）、数据长度（4 个字节），因此数据长度处于第 5 个位置；<br>2.3 第三个参数，lengthFieldLength：长度属性的长度，即存放整个大数据包长度的字节所占的长度，这里是 4 个字节。</li></ol><blockquote><p>疑问：为什么需要加 <code>LengthFieldBasedFrameDecoder</code> 呢？</p><p>回答：自定义协议它是无法知道数据包是什么时候应该结束，需要依赖 Netty 提供的拆包器。</p></blockquote><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>先启动服务端，然后启动客户端，打印结果没有出现粘包和拆包问题，证明我们自定义的协议有效，最终运行效果如下所示：<br><img src="http://img.mukewang.com/wiki/5f377ffb0939934103360608.jpg" alt="图片描述"></p><h2 id="LengthFieldBaseFrameDecoder"><a href="#LengthFieldBaseFrameDecoder" class="headerlink" title="LengthFieldBaseFrameDecoder"></a>LengthFieldBaseFrameDecoder</h2><p>这里，主要简单的介绍该拆包器，因为它是我们平时开发当中最常用的拆包器， 几乎所有和长度相关的二进制协议都可以通过它来实现，因此在这里简单的介绍一下它的原理。</p><blockquote><p>思考：如果让我们简单实现一个自己的拆包器，那么我们应该如何去实现呢？</p></blockquote><p>其实原理很简单，就是不断从 TCP 缓冲区中读取数据，每次读取完都需要判断是否是一个完整的数据包。</p><ol><li>如果当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从 tcp 缓冲区中读取，直到得到一个完整的数据包；</li><li>如果当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，够成一个完整的业务数据包传递到下一个节点进行处理。如果拼接完一个数据包时还有多余的数据仍然保留，以便和下次读到的数据进行拼接；</li><li>Netty 中的拆包也是如上这个原理，内部会有一个累加器，每次读取到数据都会不断累加，然后尝试对累加到的数据进行拆包，拆成一个完整的业务数据包，这个基类叫做 <code>ByteToMessageDecoder</code> 。</li></ol><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>本节，主要是根据上节设计的通讯协议来具体的实现效果，主要掌握的核心步骤是：</p><ol><li>需要依赖 <code>LengthFieldBaseFrameDecoder</code> 拆包器，并且需要了解该拆包器的参数定义和大概原理；</li><li>掌握编码器和解码器的实现，主要是在编码器和解码器里面实现协议的数据粘包和数据拆包。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化--AOF</title>
      <link href="posts/Redis%E6%8C%81%E4%B9%85%E5%8C%96--AOF/"/>
      <url>posts/Redis%E6%8C%81%E4%B9%85%E5%8C%96--AOF/</url>
      
        <content type="html"><![CDATA[<p>使用 RDB 持久化有一个风险，它可能会造成最新数据丢失的风险。因为 RDB 的持久化有一定的时间间隔，在这个时间段内如果 Redis 服务意外终止的话，就会造成最新的数据全部丢失。</p><p>可能会操作 Redis 服务意外终止的条件：</p><ul><li>安装 Redis 的机器停止运行，蓝屏或者系统崩溃；</li><li>安装 Redis 的机器出现电源故障，例如突然断电；</li><li>使用 <code>kill -9 Redis_PID</code> 等。</li></ul><p>那么如何解决以上的这些问题呢？Redis 为我们提供了另一种持久化的方案——AOF。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AOF（Append Only File）中文是附加到文件，顾名思义 AOF 可以把 Redis 每个键值对操作都记录到文件（appendonly.aof）中。</p><h1 id="持久化查询和设置"><a href="#持久化查询和设置" class="headerlink" title="持久化查询和设置"></a>持久化查询和设置</h1><h2 id="查询-AOF-启动状态"><a href="#查询-AOF-启动状态" class="headerlink" title="查询 AOF 启动状态"></a>查询 AOF 启动状态</h2><p>使用 <code>config get appendonly</code> 命令，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/lisbUCv97jf6DVG.png" alt="image.png"></p><p>其中，第一行为 AOF 文件的名称，而最后一行表示 AOF 启动的状态，yes 表示已启动，no 表示未启动。</p><h2 id="开启-AOF-持久化"><a href="#开启-AOF-持久化" class="headerlink" title="开启 AOF 持久化"></a>开启 AOF 持久化</h2><p>Redis 默认是关闭 AOF 持久化的，想要开启 AOF 持久化，有以下两种方式：</p><ul><li>通过命令行的方式；</li><li>通过修改配置文件的方式（redis.conf）。</li></ul><p>下面分别来看以上两种方式的实现。</p><h3 id="命令行启动-AOF"><a href="#命令行启动-AOF" class="headerlink" title="命令行启动 AOF"></a>命令行启动 AOF</h3><p>命令行启动 AOF，使用 <code>config set appendonly yes</code> 命令，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/gv42tnQEfeAKLhF.png" alt="image.png"></p><p><strong>命令行启动 AOF 的优缺点</strong>：命令行启动优点是无需重启 Redis 服务，缺点是如果 Redis 服务重启，则之前使用命令行设置的配置就会失效。</p><h3 id="配置文件启动-AOF"><a href="#配置文件启动-AOF" class="headerlink" title="配置文件启动 AOF"></a>配置文件启动 AOF</h3><p>Redis 的配置文件在它的根路径下的 redis.conf 文件中，获取 Redis 的根目录可以使用命令 <code>config get dir</code> 获取，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/Sk2ItMY5AJ9deh3.png" alt="image.png"></p><p>只需要在配置文件中设置 <code>appendonly yes</code> 即可，默认 <code>appendonly no</code> 表示关闭 AOF 持久化。 <strong>配置文件启动 AOF 的优缺点</strong>：修改配置文件的缺点是每次修改配置文件都要重启 Redis 服务才能生效，优点是无论重启多少次 Redis 服务，配置文件中设置的配置信息都不会失效。</p><h1 id="触发持久化"><a href="#触发持久化" class="headerlink" title="触发持久化"></a>触发持久化</h1><p>AOF 持久化开启之后，只要满足一定条件，就会触发 AOF 持久化。AOF 的触发条件分为两种：自动触发和手动触发。</p><h2 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h2><p>有两种情况可以自动触发 AOF 持久化，分为是：<strong>满足 AOF 设置的策略触发</strong>和<strong>满足 AOF 重写触发。</strong>其中，AOF 重写触发会在本文的后半部分详细介绍，这里重点来说 AOF 持久化策略都有哪些。 AOF 持久化策略，分为以下三种：</p><ul><li>always：每条 Redis 操作命令都会写入磁盘，最多丢失一条数据；</li><li>everysec：每秒钟写入一次磁盘，最多丢失一秒的数据；</li><li>no：不设置写入磁盘的规则，根据当前操作系统来决定何时写入磁盘，Linux 默认 30s 写入一次数据至磁盘。</li></ul><p>这三种配置可以在 Redis 的配置文件（redis.conf）中设置，如下代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 开启每秒写入一次的持久化策略</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：因为每次写入磁盘都会对 Redis 的性能造成一定的影响，所以要根据用户的实际情况设置相应的策略，一般设置每秒写入一次磁盘的频率就可以满足大部分的使用场景了。</p></blockquote><p>触发自动持久化的两种情况，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/VKqGQcexHNJiMBh.png" alt="image.png"></p><h2 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h2><p>在客户端执行 <code>bgrewriteaof</code> 命令就可以手动触发 AOF 持久化，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/fqz6kOD5SLlbyvh.png" alt="5.png">可以看出执行完 <code>bgrewriteaof</code> 命令之后，AOF 持久化就会被触发。</p><h1 id="AOF-文件重写"><a href="#AOF-文件重写" class="headerlink" title="AOF 文件重写"></a>AOF 文件重写</h1><p>AOF 是通过记录 Redis 的执行命令来持久化（保存）数据的，所以随着时间的流逝 AOF 文件会越来越多，这样不仅增加了服务器的存储压力，也会造成 Redis 重启速度变慢，为了解决这个问题 Redis 提供了 AOF 重写的功能。</p><h2 id="什么是-AOF-重写？"><a href="#什么是-AOF-重写？" class="headerlink" title="什么是 AOF 重写？"></a>什么是 AOF 重写？</h2><p>AOF 重写指的是它会直接读取 Redis 服务器当前的状态，并压缩保存为 AOF 文件。例如，我们增加了一个计数器，并对它做了 99 次修改，如果不做 AOF 重写的话，那么持久化文件中就会有 100 条记录执行命令的信息，而 AOF 重写之后，之后记录一条此计数器最终的结果信息，这样就去除了所有的无效信息。</p><h2 id="AOF-重写实现"><a href="#AOF-重写实现" class="headerlink" title="AOF 重写实现"></a>AOF 重写实现</h2><p>触发 AOF 文件重写，要满足两个条件，这两个条件也是配置在 Redis 配置文件中的，它们分别：</p><ul><li>auto-aof-rewrite-min-size：允许 AOF 重写的最小文件容量，默认是 64mb 。</li><li>auto-aof-rewrite-percentage：AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次（上次）的 AOF 文件大一倍时，才会启动 AOF 文件重写。</li></ul><p>查询 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 的值，可使用 <code>config get xxx</code> 命令，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/rgkG3EoSVAPLvBm.png" alt="6.png"></p><blockquote><p>小贴士：只有同时满足 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 设置的条件，才会触发 AOF 文件重写。</p></blockquote><p><strong>注意</strong>：使用 <code>bgrewriteaof</code> 命令，可以自动触发 AOF 文件重写。</p><h2 id="AOF-重写流程"><a href="#AOF-重写流程" class="headerlink" title="AOF 重写流程"></a>AOF 重写流程</h2><p>AOF 文件重写是生成一个全新的文件，并把当前数据的最少操作命令保存到新文件上，当把所有的数据都保存至新文件之后，Redis 会交换两个文件，并把最新的持久化操作命令追加到新文件上。</p><h1 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h1><p>合理的设置 AOF 的配置，可以保障 Redis 高效且稳定的运行，以下是 AOF 的全部配置信息和说明。</p><p>AOF 的配置参数在 Redis 的配置文件中，也就是 Redis 根路径下的 <code>redis.conf</code> 文件中，配置参数和说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启 AOF，yes 为开启，默认是关闭</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># AOF 默认文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># AOF 持久化策略配置</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次的 AOF 文件大一倍时，才会启动 AOF 文件重写。</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"># 允许 AOF 重写的最小文件容量</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 是否开启启动时加载 AOF 文件效验，默认值是 yes，表示尽可能的加载 AOF 文件，忽略错误部分信息，并启动 Redis 服务。</span><br><span class="line"># 如果值为 no，则表示，停止启动 Redis，用户必须手动修复 AOF 文件才能正常启动 Redis 服务。</span><br><span class="line">aof-load-truncated yes</span><br></pre></td></tr></table></figure><p>其中比较重要的是 appendfsync 参数，用它来设置 AOF 的持久化策略，可以选择按时间间隔或者操作次数来存储 AOF 文件，这个参数的三个值在文章开头有说明，这里就不再复述了。</p><h1 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h1><h2 id="正常数据恢复"><a href="#正常数据恢复" class="headerlink" title="正常数据恢复"></a>正常数据恢复</h2><p>正常情况下，只要开启了 AOF 持久化，并且提供了正常的 appendonly.aof 文件，在 Redis 启动时就会自定加载 AOF 文件并启动，执行如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/KzmOItHseNYlur8.png" alt="7.png">其中 <code>DB loaded from append only file......</code> 表示 Redis 服务器在启动时，先去加载了 AOF 持久化文件。</p><blockquote><p>小贴士：默认情况下 appendonly.aof 文件保存在 Redis 的根目录下。</p></blockquote><p><strong>持久化文件加载规则</strong></p><ul><li>如果只开启了 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复；</li><li>如果只开启了 RDB 持久化，Redis 启动时只会加载 RDB 文件（dump.rdb），进行数据恢复；</li><li>如果同时开启了 RDB 和 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复。</li></ul><p>在 AOF 开启的情况下，即使 AOF 文件不存在，只有 RDB 文件，也不会加载 RDB 文件。 AOF 和 RDB 的加载流程如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/hj3UL1aKWNMciPo.png" alt="8.png"></p><h2 id="简单异常数据恢复"><a href="#简单异常数据恢复" class="headerlink" title="简单异常数据恢复"></a>简单异常数据恢复</h2><p>在 AOF 写入文件时如果服务器崩溃，或者是 AOF 存储已满的情况下，AOF 的最后一条命令可能被截断，这就是异常的 AOF 文件。</p><p>在 AOF 文件异常的情况下，如果为修改 Redis 的配置文件，也就是使用 <code>aof-load-truncated</code> 等于 <code>yes</code> 的配置，Redis 在启动时会忽略最后一条命令，并顺利启动 Redis，执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* Reading RDB preamble from AOF file...</span><br><span class="line">* Reading the remaining AOF tail...</span><br><span class="line"># !!! Warning: short read while loading the AOF file !!!</span><br><span class="line"># !!! Truncating the AOF at offset 439 !!!</span><br><span class="line"># AOF loaded anyway because aof-load-truncated is enabled</span><br></pre></td></tr></table></figure><h2 id="复杂异常数据恢复"><a href="#复杂异常数据恢复" class="headerlink" title="复杂异常数据恢复"></a>复杂异常数据恢复</h2><p>AOF 文件可能出现更糟糕的情况，当 AOF 文件不仅被截断，而且中间的命令也被破坏，这个时候再启动 Redis 会提示错误信息并中止运行，错误信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* Reading the remaining AOF tail...</span><br><span class="line"># Bad file format reading the append only file: make a backup of your AOF file, then use .&#x2F;redis-check-aof --fix &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>出现此类问题的解决方案如下：</p><ol><li>首先使用 AOF 修复工具，检测出现的问题，在命令行中输入 <code>redis-check-aof</code> 命令，它会跳转到出现问题的命令行，这个时候可以尝试手动修复此文件；</li><li>如果无法手动修复，我们可以使用 <code>redis-check-aof --fix</code> 自动修复 AOF 异常文件，不过执行此命令，可能会导致异常部分至文件末尾的数据全部被丢弃。</li></ol><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF 优点"></a>AOF 优点</h2><ul><li>AOF 持久化保存的数据更加完整，AOF 提供了三种保存策略：每次操作保存、每秒钟保存一次、跟随系统的持久化策略保存，其中每秒保存一次，从数据的安全性和性能两方面考虑是一个不错的选择，也是 AOF 默认的策略，即使发生了意外情况，最多只会丢失 1s 钟的数据；</li><li>AOF 采用的是命令追加的写入方式，所以不会出现文件损坏的问题，即使由于某些意外原因，导致了最后操作的持久化数据写入了一半，也可以通过 redis-check-aof 工具轻松的修复；</li><li>AOF 持久化文件，非常容易理解和解析，它是把所有 Redis 键值操作命令，以文件的方式存入了磁盘。即使不小心使用 <code>flushall</code> 命令删除了所有键值信息，只要使用 AOF 文件，删除最后的 <code>flushall</code> 命令，重启 Redis 即可恢复之前误删的数据。</li></ul><h2 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF 缺点"></a>AOF 缺点</h2><ul><li>对于相同的数据集来说，AOF 文件要大于 RDB 文件；</li><li>在 Redis 负载比较高的情况下，RDB 比 AOF 性能更好；</li><li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 更健壮。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>AOF 保存数据更加完整，它可以记录每次 Redis 的键值变化，或者是选择每秒保存一次数据。AOF 的持久化文件更加易读，但相比与二进制的 RDB 来说，所占的存储空间也越大，为了解决这个问题，AOF 提供自动化重写机制，最大程度的减少了 AOF 占用空间大的问题。同时 AOF 也提供了很方便的异常文件恢复命令： <code>redis-check-aof --fix</code> ，为使用 AOF 提供了很好的保障。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化--RDB</title>
      <link href="posts/Redis%E6%8C%81%E4%B9%85%E5%8C%96--RDB/"/>
      <url>posts/Redis%E6%8C%81%E4%B9%85%E5%8C%96--RDB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Redis 的读写都是在内存中，所以它的性能较高，但在内存中的数据会随着服务器的重启而丢失，为了保证数据不丢失，我们需要将内存中的数据存储到磁盘，以便 Redis 重启时能够从磁盘中恢复原有的数据，而整个过程就叫做 Redis 持久化。</p></blockquote><p><img src="https://s2.loli.net/2021/12/13/ufiDXC4ahNzKklE.png" alt="image.png"></p><p>Redis 持久化也是 Redis 和 Memcached 的主要区别之一，因为 Memcached 不具备持久化功能。</p><h1 id="持久化的几种方式"><a href="#持久化的几种方式" class="headerlink" title="持久化的几种方式"></a>持久化的几种方式</h1><p>Redis 持久化拥有以下三种方式：</p><ul><li><strong>快照方式</strong>（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>文件追加方式</strong>（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；</li><li><strong>混合持久化方式</strong>，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。</li></ul><p>因为每种持久化方案，都有特定的使用场景，让我们先从 RDB 持久化说起吧。</p><h1 id="RDB简介"><a href="#RDB简介" class="headerlink" title="RDB简介"></a>RDB简介</h1><p>RDB（Redis DataBase）是将某一个时刻的内存快照（Snapshot），以二进制的方式写入磁盘的过程。</p><h1 id="持久化触发"><a href="#持久化触发" class="headerlink" title="持久化触发"></a>持久化触发</h1><p>RDB 的持久化触发方式有两类：一类是手动触发，另一类是自动触发。</p><h2 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h2><p>手动触发持久化的操作有两个： <code>save</code> 和 <code>bgsave</code> ，它们主要区别体现在：是否阻塞 Redis 主线程的执行。</p><h3 id="save-命令"><a href="#save-命令" class="headerlink" title="save 命令"></a>save 命令</h3><p>在客户端中执行 <code>save</code> 命令，就会触发 Redis 的持久化，但同时也是使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以<strong>在生产环境一定要慎用</strong>。</p><p><code>save</code> 命令使用如下：<img src="https://s2.loli.net/2021/12/13/sSyYdZjqoxbFa9I.png" alt="image.png">从图片可以看出，当执行完 <code>save</code> 命令之后，持久化文件 <code>dump.rdb</code> 的修改时间就变了，这就表示 <code>save</code> 成功的触发了 RDB 持久化。 <code>save</code> 命令执行流程，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/Zu17OH6QVMKaoIx.png" alt="image.png"></p><h3 id="bgsave-命令"><a href="#bgsave-命令" class="headerlink" title="bgsave 命令"></a>bgsave 命令</h3><p>bgsave（background save）既后台保存的意思， 它和 <code>save</code> 命令最大的区别就是 <code>bgsave</code> 会 fork() 一个子进程来执行持久化，整个过程中只有在 fork() 子进程时有短暂的阻塞，当子进程被创建之后，Redis 的主进程就可以响应其他客户端的请求了，相对于整个流程都阻塞的 <code>save</code> 命令来说，显然 <code>bgsave</code> 命令更适合我们使用。 <code>bgsave</code> 命令使用，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/qIsaFWgD1AoEVcp.png" alt="image.png"></p><p><code>bgsave</code> 执行流程，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/mA4JU8edhRCOgw7.png" alt="image.png"></p><h2 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h2><p>说完了 RDB 的手动触发方式，下面来看如何自动触发 RDB 持久化？ RDB 自动持久化主要来源于以下几种情况。</p><h3 id="save-m-n"><a href="#save-m-n" class="headerlink" title="save m n"></a>save m n</h3><p><code>save m n</code> 是指在 m 秒内，如果有 n 个键发生改变，则自动触发持久化。 参数 m 和 n 可以在 Redis 的配置文件中找到，例如，<code>save 60 1</code> 则表明在 60 秒内，至少有一个键发生改变，就会触发 RDB 持久化。 自动触发持久化，本质是 Redis 通过判断，如果满足设置的触发条件，自动执行一次 <code>bgsave</code> 命令。 注意：当设置多个 save m n 命令时，满足任意一个条件都会触发持久化。 例如，我们设置了以下两个 save m n 命令：</p><ul><li>save 60 10</li><li>save 600 1</li></ul><p>当 60s 内如果有 10 次 Redis 键值发生改变，就会触发持久化；如果 60s 内 Redis 的键值改变次数少于 10 次，那么 Redis 就会判断 600s 内，Redis 的键值是否至少被修改了一次，如果满足则会触发持久化。</p><h3 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h3><p><code>flushall</code> 命令用于清空 Redis 数据库，在生产环境下一定慎用，当 Redis 执行了 <code>flushall</code> 命令之后，则会触发自动持久化，把 RDB 文件清空。 执行结果如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/YDK4vj25S3mRCqd.png" alt="image.png"></p><h2 id="主从同步触发"><a href="#主从同步触发" class="headerlink" title="主从同步触发"></a>主从同步触发</h2><p>在 Redis 主从复制中，当从节点执行全量复制操作时，主节点会执行 <code>bgsave</code> 命令，并将 RDB 文件发送给从节点，该过程会自动触发 Redis 持久化。</p><h1 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h1><p>合理的设置 RDB 的配置，可以保障 Redis 高效且稳定的运行，下面一起来看 RDB 的配置项都有哪些？</p><p>RDB 配置参数可以在 Redis 的配置文件中找见，具体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># RDB 保存的条件</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># bgsave 失败之后，是否停止持久化数据到磁盘，yes 表示停止持久化，no 表示忽略错误继续写文件。</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># RDB 文件压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># RDB 文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># RDB 文件目录</span><br><span class="line">dir .&#x2F;</span><br></pre></td></tr></table></figure><p>其中比较重要的参数如下列表： <strong>① save 参数</strong> 它是用来配置触发 RDB 持久化条件的参数，满足保存条件时将会把数据持久化到硬盘。 默认配置说明如下：</p><ul><li>save 900 1：表示 900 秒内如果至少有 1 个 key 值变化，则把数据持久化到硬盘；</li><li>save 300 10：表示 300 秒内如果至少有 10 个 key 值变化，则把数据持久化到硬盘；</li><li>save 60 10000：表示 60 秒内如果至少有 10000 个 key 值变化，则把数据持久化到硬盘。</li></ul><p><strong>② rdbcompression 参数</strong> 它的默认值是 <code>yes</code> 表示开启 RDB 文件压缩，Redis 会采用 LZF 算法进行压缩。如果不想消耗 CPU 性能来进行文件压缩的话，可以设置为关闭此功能，这样的缺点是需要更多的磁盘空间来保存文件。 <strong>③ rdbchecksum 参数</strong> 它的默认值为 <code>yes</code> 表示写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。</p><h1 id="配置查询"><a href="#配置查询" class="headerlink" title="配置查询"></a>配置查询</h1><p>Redis 中可以使用命令查询当前配置参数。查询命令的格式为：<code>config get xxx</code> ，例如，想要获取 RDB 文件的存储名称设置，可以使用 <code>config get dbfilename</code> ，执行效果如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/AvDxyGWZjgbYPCi.png" alt="image.png"></p><p>查询 RDB 的文件目录，可使用命令 <code>config get dir</code> ，执行效果如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/tboEm6qycvLUfAl.png" alt="image.png"></p><h1 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h1><p>设置 RDB 的配置，可以通过以下两种方式：</p><ul><li>手动修改 Redis 配置文件；</li><li>使用命令行设置，例如，使用 <code>config set dir &quot;/usr/data&quot;</code> 就是用于修改 RDB 的存储目录。</li></ul><p><strong>注意</strong>：手动修改 Redis 配置文件的方式是全局生效的，即重启 Redis 服务器设置参数也不会丢失，而使用命令修改的方式，在 Redis 重启之后就会丢失。但手动修改 Redis 配置文件，想要立即生效需要重启 Redis 服务器，而命令的方式则不需要重启 Redis 服务器。</p><blockquote><p>小贴士：Redis 的配置文件位于 Redis 安装目录的根路径下，默认名称为 redis.conf。</p></blockquote><h1 id="RDB-文件恢复"><a href="#RDB-文件恢复" class="headerlink" title="RDB 文件恢复"></a>RDB 文件恢复</h1><p>当 Redis 服务器启动时，如果 Redis 根目录存在 RDB 文件 dump.rdb，Redis 就会自动加载 RDB 文件恢复持久化数据。 如果根目录没有 dump.rdb 文件，请先将 dump.rdb 文件移动到 Redis 的根目录。 <strong>验证 RDB 文件是否被加载</strong> Redis 在启动时有日志信息，会显示是否加载了 RDB 文件，我们执行 Redis 启动命令：<code>src/redis-server redis.conf</code> ，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/xgKkor47MyWFVdq.png" alt="image.png">从日志上可以看出， Redis 服务在启动时已经正常加载了 RDB 文件。</p><blockquote><p>小贴士：Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p></blockquote><h1 id="RDB-优缺点"><a href="#RDB-优缺点" class="headerlink" title="RDB 优缺点"></a>RDB 优缺点</h1><h2 id="RDB-优点"><a href="#RDB-优点" class="headerlink" title="RDB 优点"></a>RDB 优点</h2><ul><li>RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；</li><li>RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；</li><li>RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作；</li><li>与 AOF 格式的文件相比，RDB 文件可以更快的重启。</li></ul><h2 id="RDB-缺点"><a href="#RDB-缺点" class="headerlink" title="RDB 缺点"></a>RDB 缺点</h2><ul><li>因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据；</li><li>RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。</li></ul><h1 id="禁用持久化"><a href="#禁用持久化" class="headerlink" title="禁用持久化"></a>禁用持久化</h1><p>禁用持久化可以提高 Redis 的执行效率，如果对数据丢失不敏感的情况下，可以在连接客户端的情况下，执行 <code>config set save &quot;&quot;</code> 命令即可禁用 Redis 的持久化，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/mRnuNCIKEVb9kso.png" alt="image.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过本文我们可以得知，RDB 持久化分为手动触发和自动触发两种方式，它的优点是存储文件小，Redis 启动 时恢复数据比较快，缺点是有丢失数据的风险。RDB 文件的恢复也很简单，只需要把 RDB 文件放到 Redis 的根目录，在 Redis 启动时就会自动加载并恢复数据。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化--混合持久化</title>
      <link href="posts/Redis%E6%8C%81%E4%B9%85%E5%8C%96--%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>posts/Redis%E6%8C%81%E4%B9%85%E5%8C%96--%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>RDB 和 AOF 持久化各有利弊，RDB 可能会导致一定时间内的数据丢失，而 AOF 由于文件较大则会影响 Redis 的启动速度，为了能同时使用 RDB 和 AOF 各种的优点，Redis 4.0 之后新增了混合持久化的方式。</p><p>在开启混合持久化的情况下，AOF 重写时会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，之后的数据再以 AOF 的格式化追加的文件的末尾。</p><p>混合持久化的数据存储结构如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/3cotY1HUeVmBTz9.png" alt="1.png"></p><h1 id="开启混合持久化"><a href="#开启混合持久化" class="headerlink" title="开启混合持久化"></a>开启混合持久化</h1><p>查询是否开启混合持久化可以使用 <code>config get aof-use-rdb-preamble</code> 命令，执行结果如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/JiAyCwT72amsGZW.png" alt="2.png"></p><p>其中 yes 表示已经开启混合持久化，no 表示关闭，Redis 5.0 默认值为 yes。 如果是其他版本的 Redis 首先需要检查一下，是否已经开启了混合持久化，如果关闭的情况下，可以通过以下两种方式开启：</p><ul><li>通过命令行开启</li><li>通过修改 Redis 配置文件开启</li></ul><h2 id="通过命令行开启"><a href="#通过命令行开启" class="headerlink" title="通过命令行开启"></a>通过命令行开启</h2><p>使用命令 <code>config set aof-use-rdb-preamble yes</code> 执行结果如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/35XuvjFPskqHK1N.png" alt="3.png"></p><blockquote><p>小贴士：命令行设置配置的缺点是重启 Redis 服务之后，设置的配置就会失效。</p></blockquote><h2 id="通过修改-Redis-配置文件开启"><a href="#通过修改-Redis-配置文件开启" class="headerlink" title="通过修改 Redis 配置文件开启"></a>通过修改 Redis 配置文件开启</h2><p>在 Redis 的根路径下找到 redis.conf 文件，把配置文件中的 <code>aof-use-rdb-preamble no</code> 改为 <code>aof-use-rdb-preamble yes</code> 如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/iRjq3npEXoUJ1Ms.png" alt="4.png"></p><h1 id="实例运行"><a href="#实例运行" class="headerlink" title="实例运行"></a>实例运行</h1><p>当在混合持久化关闭的情况下，使用 <code>bgrewriteaof</code> 触发 AOF 文件重写之后，查看 appendonly.aof 文件的持久化日志，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/3Iw8H2O9nG6heSd.png" alt="5.png">可以看出，当混合持久化关闭的情况下 AOF 持久化文件存储的为标准的 AOF 格式的文件。 当混合持久化开启的模式下，使用 <code>bgrewriteaof</code> 命令触发 AOF 文件重写，得到 appendonly.aof 的文件内容如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/6vgK4qOG9RTrsQM.png" alt="6.png">可以看出 appendonly.aof 文件存储的内容是 <code>REDIS</code> 开头的 RDB 格式的内容，并非为 AOF 格式的日志。</p><h1 id="数据恢复和源码解析"><a href="#数据恢复和源码解析" class="headerlink" title="数据恢复和源码解析"></a>数据恢复和源码解析</h1><p>混合持久化的数据恢复和 AOF 持久化过程是一样的，只需要把 appendonly.aof 放到 Redis 的根目录，在 Redis 启动时，只要开启了 AOF 持久化，Redis 就会自动加载并恢复数据。 Redis 启动信息如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/mf4KbVkguNq1dSe.png" alt="7.png">可以看出 Redis 在服务器初始化的时候加载了 AOF 文件的内容。</p><h2 id="混合持久化的加载流程"><a href="#混合持久化的加载流程" class="headerlink" title="混合持久化的加载流程"></a>混合持久化的加载流程</h2><p>混合持久化的加载流程如下：</p><ol><li>判断是否开启 AOF 持久化，开启继续执行后续流程，未开启执行加载 RDB 文件的流程；</li><li>判断 appendonly.aof 文件是否存在，文件存在则执行后续流程；</li><li>判断 AOF 文件开头是 RDB 的格式, 先加载 RDB 内容再加载剩余的 AOF 内容；</li><li>判断 AOF 文件开头不是 RDB 的格式，直接以 AOF 格式加载整个文件。</li></ol><p>AOF 加载流程图如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/2TSVJctWKh1d3ak.png" alt="8.png"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>Redis 判断 AOF 文件的开头是否是 RDB 格式的，是通过关键字 <code>REDIS</code> 判断的，RDB 文件的开头一定是 <code>REDIS</code> 关键字开头的，判断源码在 Redis 的 src/aof.c 中，核心代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> sig[<span class="number">5</span>]; <span class="comment">/* &quot;REDIS&quot; */</span></span><br><span class="line"><span class="keyword">if</span> (fread(sig,<span class="number">1</span>,<span class="number">5</span>,fp) != <span class="number">5</span> || <span class="built_in">memcmp</span>(sig,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// AOF 文件开头非 RDB 格式，非混合持久化文件</span></span><br><span class="line">    <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* RDB preamble. Pass loading the RDB functions. */</span></span><br><span class="line">    rio rdb;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Reading RDB preamble from AOF file...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">    <span class="comment">// AOF 文件开头是 RDB 格式，先加载 RDB 再加载 AOF</span></span><br><span class="line">    <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,<span class="literal">NULL</span>,<span class="number">1</span>) != C_OK) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error reading the RDB preamble of the AOF file, AOF loading aborted&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Reading the remaining AOF tail...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载 AOF 格式的数据</span></span><br></pre></td></tr></table></figure><p>可以看出 Redis 是通过判断 AOF 文件的开头是否是 <code>REDIS</code> 关键字，来确定此文件是否为混合持久化文件的。</p><blockquote><p>小贴士：AOF 格式的开头是 *，而 RDB 格式的开头是 REDIS。</p></blockquote><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p><strong>混合持久化优点：</strong></p><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li></ul><p><strong>混合持久化缺点：</strong></p><ul><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li><li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li></ul><h1 id="持久化最佳实践"><a href="#持久化最佳实践" class="headerlink" title="持久化最佳实践"></a>持久化最佳实践</h1><p>持久化虽然保证了数据不丢失，但同时拖慢了 Redis 的运行速度，那怎么更合理的使用 Redis 的持久化功能呢？ Redis 持久化的最佳实践可从以下几个方面考虑。</p><h2 id="控制持久化开关"><a href="#控制持久化开关" class="headerlink" title="控制持久化开关"></a>控制持久化开关</h2><p>使用者可根据实际的业务情况考虑，如果对数据的丢失不敏感的情况下，可考虑关闭 Redis 的持久化，这样所以的键值操作都在内存中，就可以保证最高效率的运行 Redis 了。 持久化关闭操作：</p><ul><li>关闭 RDB 持久化，使用命令： <code>config set save &quot;&quot;</code></li><li>关闭 AOF 和 混合持久化，使用命令： <code>config set appendonly no</code></li></ul><h2 id="主从部署"><a href="#主从部署" class="headerlink" title="主从部署"></a>主从部署</h2><p>使用主从部署，一台用于响应主业务，一台用于数据持久化，这样就可能让 Redis 更加高效的运行。</p><h2 id="使用混合持久化"><a href="#使用混合持久化" class="headerlink" title="使用混合持久化"></a>使用混合持久化</h2><p>混合持久化结合了 RDB 和 AOF 的优点，Redis 5.0 默认是开启的。</p><h2 id="使用配置更高的机器"><a href="#使用配置更高的机器" class="headerlink" title="使用配置更高的机器"></a>使用配置更高的机器</h2><p>Redis 对 CPU 的要求并不高，反而是对内存和磁盘的要求很高，因为 Redis 大部分时候都在做读写操作，使用更多的内存和更快的磁盘，对 Redis 性能的提高非常有帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis是如何执行的</title>
      <link href="posts/Redis%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
      <url>posts/Redis%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="命令执行流程"><a href="#命令执行流程" class="headerlink" title="命令执行流程"></a>命令执行流程</h1><p>一条命令的执行过程有很多细节，但大体可分为：客户端先将用户输入的命令，转化为 Redis 相关的通讯协议，再用 socket 连接的方式将内容发送给服务器端，服务器端在接收到相关内容之后，先将内容转化为具体的执行命令，再判断用户授权信息和其他相关信息，当验证通过之后会执行最终命令，命令执行完之后，会进行相关的信息记录和数据统计，然后再把执行结果发送给客户端，这样一条命令的执行流程就结束了。如果是集群模式的话，主节点还会将命令同步至子节点，下面我们一起来看更加具体的执行流程。</p><p><img src="https://s2.loli.net/2021/12/04/TsfHU7mId51bX8v.png" alt="image.png"></p><p><strong>步骤一：用户输入一条命令</strong></p><p><strong>步骤二：客户端先将命令转换成 Redis 协议，然后再通过 socket 连接发送给服务器端</strong></p><p>客户端和服务器端是基于 socket 通信的，服务器端在初始化时会创建了一个 socket 监听，用于监测链接客户端的 socket 链接，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 开启 Socket 事件监听</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>socket 小知识：每个 socket 被创建后，会分配两个缓冲区，输入缓冲区和输出缓冲区。 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。 注意：数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。</p></blockquote><p>当 socket 成功连接之后，客户端会先把命令转换成 Redis 通讯协议（RESP 协议，REdis Serialization Protocol）发送给服务器端，这个通信协议是为了保障服务器能最快速的理解命令的含义而制定的，如果没有这个通讯协议，那么 Redis 服务器端要遍历所有的空格以确认此条命令的含义，这样会加大服务器的运算量，而直接发送通讯协议，相当于把服务器端的解析工作交给了每一个客户端，这样会很大程度的提高 Redis 的运行速度。例如，当我们输入 <code>set key val</code> 命令时，客户端会把这个命令转换为 <code>*3\r\n$3\r\nSET\r\n$4\r\nKEY\r\n$4\r\nVAL\r\n</code> 协议发送给服务器端。 更多通讯协议，可访问官方文档：<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a></p><p><strong>扩展知识：I/O 多路复用</strong></p><p>Redis 使用的是 I/O 多路复用功能来监听多 socket 链接的，这样就可以使用一个线程链接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作，从而大大提高了 Redis 的运行效率。</p><p>I/O 多路复用机制如下图所示：<img src="https://s2.loli.net/2021/12/04/tKDSOlFMkmvQsBo.png" alt="IO多路复用.png"></p><p>综合来说，此步骤的执行流程如下：</p><ul><li>与服务器端以 socket 和 I/O 多路复用的技术建立链接；</li><li>将命令转换为 Redis 通讯协议，再将这些协议发送至缓冲区。</li></ul><p><strong>步骤三：服务器端接收到命令</strong></p><p>服务器会先去输入缓冲中读取数据，然后判断数据的大小是否超过了系统设置的值(默认是 1GB)，如果大于此值就会返回错误信息，并关闭客户端连接。 默认大小如下图所示：<img src="https://s2.loli.net/2021/12/04/KqDbE6vgB8zc4kU.png" alt="redis-run-max_query_buffer.png">当数据大小验证通过之后，服务器端会对输入缓冲区中的请求命令进行分析，提取命令请求中包含的命令参数，存储在 client 对象(服务器端会为每个链接创建一个 Client 对象)的属性中。</p><p><strong>步骤四：执行前准备</strong></p><p>① 判断是否为退出命令，如果是则直接返回；</p><p>② 非 null 判断，检查 client 对象是否为 null，如果是返回错误信息；</p><p>③ 获取执行命令，根据 client 对象存储的属性信息去 redisCommand 结构中查询执行命令；</p><p>④ 用户权限效验，未通过身份验证的客户端只能执行 AUTH(授权) 命令，未通过身份验证的客户端执行了 AUTH 之外的命令则返回错误信息；</p><p>⑤ 集群相关操作，如果是集群模式，把命令重定向到目标节点，如果是 master(主节点) 则不需要重定向；</p><p>⑥ 检查服务器端最大内存限制，如果服务器端开启了最大内存限制，会先检查内存大小，如果内存超过了最大值会对内存进行回收操作；</p><p>⑦ 持久化检测，检查服务器是否开启了持久化和持久化出错停止写入配置，如果开启了此配置并且有持久化失败的情况，禁止执行写命令；</p><p>⑧ 集群模式最少从节点(slave)验证，如果是集群模式并且配置了 repl<em>min</em>slaves<em>to</em>write(最小从节点写入)，当从节点的数量少于配置项时，禁止执行写命令；</p><p>⑨ 只读从节点验证，当此服务器为只读从节点时，只接受 master 的写命令；</p><p>⑩ 客户端订阅判断，当客户端正在订阅频道时，只会执行部分命令（只会执行 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE，其他命令都会被拒绝）。</p><p>⑪ 从节点状态效验，当服务器为 slave 并且没有连接 master 时，只会执行状态查询相关的命令，如 info 等；</p><p>⑫ 服务器初始化效验，当服务器正在启动时，只会执行 loading 标志的命令，其他的命令都会被拒绝；</p><p>⑬ lua 脚本阻塞效验，当服务器因为执行 lua 脚本阻塞时，只会执行部分命令；</p><p>⑭ 事务命令效验，如果执行的是事务命令，则开启事务把命令放入等待队列；</p><p>⑮ 监视器 (monitor) 判断，如果服务器打开了监视器功能，那么服务器也会把执行命令和相关参数发送给监视器 (监视器是用于监控服务器运行状态的)。</p><p>当服务器经过以上操作之后，就可以执行真正的操作命令了。</p><p><strong>步骤五：执行最终命令，调用 redisCommand 中的 proc 函数执行命令。</strong></p><p><strong>步骤六：执行完后相关记录和统计</strong> ① 检查慢查询是否开启，如果开启会记录慢查询日志； ② 检查统计信息是否开启，如果开启会记录一些统计信息，例如执行命令所耗费时长和计数器(calls)加1； ③ 检查持久化功能是否开启，如果开启则会记录持久化信息； ④ 如果有其它从服务器正在复制当前服务器，则会将刚刚执行的命令传播给其他从服务器。</p><p><strong>步骤七：返回结果给客户端</strong> 命令执行完之后，服务器会通过 socket 的方式把执行结果发送给客户端，客户端再把结果展示给用户，至此一条命令的执行就结束了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>当用户输入一条命令之后，客户端会以 socket 的方式把数据转换成 Redis 协议，并发送至服务器端，服务器端在接受到数据之后，会先将协议转换为真正的执行命令，在经过各种验证以保证命令能够正确并安全的执行，但验证处理完之后，会调用具体的方法执行此条命令，执行完成之后会进行相关的统计和记录，然后再把执行结果返回给客户端，整个执行流程，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/04/K2dqUrBQ8xH1Dom.png" alt="Redis执行流程.png"></p><p>更多执行细节，可在 Redis 的源码文件 <code>server.c</code> 中查看。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>列表使用与内部实现原理</title>
      <link href="posts/%E5%88%97%E8%A1%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>posts/%E5%88%97%E8%A1%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>列表类型 (List) 是一个使用链表结构存储的有序结构，它的元素插入会按照先后顺序存储到链表结构中，因此它的元素操作 (插入\删除) 时间复杂度为 O(1)，所以相对来说速度还是比较快的，但它的查询时间复杂度为 O(n)，因此查询可能会比较慢。</p><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><p>列表类型的使用相对来说比较简单，对它的操作就相当操作一个没有任何 key 值的 value 集合，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/vj7omg8PQ1Aunxz.png" alt="列表类型使用-列表结构图.png"></p><h2 id="给列表添加一个或多个元素"><a href="#给列表添加一个或多个元素" class="headerlink" title="给列表添加一个或多个元素"></a>给列表添加一个或多个元素</h2><p>语法：lpush key value [value …] 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list 1 2 3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><h2 id="给列表尾部添加一个或多个元素"><a href="#给列表尾部添加一个或多个元素" class="headerlink" title="给列表尾部添加一个或多个元素"></a>给列表尾部添加一个或多个元素</h2><p>语法：rpush key value [value …] 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list2 1 2 3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><h2 id="返回列表指定区间内的元素"><a href="#返回列表指定区间内的元素" class="headerlink" title="返回列表指定区间内的元素"></a>返回列表指定区间内的元素</h2><p>语法：lrange key start stop 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">&quot;2&quot;</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">&quot;2&quot;</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>其中 -1 代表列表中的最后一个元素。</p><h2 id="获取并删除列表的第一个元素"><a href="#获取并删除列表的第一个元素" class="headerlink" title="获取并删除列表的第一个元素"></a>获取并删除列表的第一个元素</h2><p>语法：lpop key 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line">&quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br></pre></td></tr></table></figure><h2 id="获取并删除列表的最后一个元素"><a href="#获取并删除列表的最后一个元素" class="headerlink" title="获取并删除列表的最后一个元素"></a>获取并删除列表的最后一个元素</h2><p>语法：rpop key 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list</span><br><span class="line">&quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br></pre></td></tr></table></figure><h2 id="根据下标获取对应的元素"><a href="#根据下标获取对应的元素" class="headerlink" title="根据下标获取对应的元素"></a>根据下标获取对应的元素</h2><p>语法：lindex key index 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list3 a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lindex list3 0</span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure><h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>下面来看列表类型在 Java 中的使用，同样先添加 Jedis 框架，使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 声明 Redis key</span></span><br><span class="line">        <span class="keyword">final</span> String REDISKEY = <span class="string">&quot;list&quot;</span>;</span><br><span class="line">        <span class="comment">// 在头部插入一个或多个元素</span></span><br><span class="line">        Long lpushResult = jedis.lpush(REDISKEY, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Sql&quot;</span>);</span><br><span class="line">        System.out.println(lpushResult); <span class="comment">// 输出：2</span></span><br><span class="line">        <span class="comment">// 获取第 0 个元素的值</span></span><br><span class="line">        String idValue = jedis.lindex(REDISKEY, <span class="number">0</span>);</span><br><span class="line">        System.out.println(idValue); <span class="comment">// 输出：Sql</span></span><br><span class="line">        <span class="comment">// 查询指定区间的元素</span></span><br><span class="line">        List&lt;String&gt; list = jedis.lrange(REDISKEY, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// 输出：[Sql, Java]</span></span><br><span class="line">        <span class="comment">// 在元素 Java 前面添加 MySQL 元素</span></span><br><span class="line">        jedis.linsert(REDISKEY, ListPosition.BEFORE, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">        System.out.println(jedis.lrange(REDISKEY, <span class="number">0</span>, -<span class="number">1</span>)); <span class="comment">// 输出：[Sql, MySQL, Java]</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><blockquote><p>2 Sql [Sql, Java] [Sql, MySQL, Java]</p></blockquote><h1 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h1><p>我们先用 <code>debug encoding key</code> 来查看列表类型的内部存储类型，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding list</span><br><span class="line">&quot;quicklist&quot;</span><br></pre></td></tr></table></figure><p>从结果可以看出，列表类型的底层数据类型是 quicklist。</p><p>quicklist (快速列表) 是 Redis 3.2 引入的数据类型，早期的列表类型使用的是ziplist (压缩列表) 和双向链表组成的，Redis 3.2 改为用 quicklist 来存储列表元素。</p><p>我们来看下 quicklist 的实现源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span> <span class="comment">// src/quicklist.h</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* ziplist 的个数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* quicklist 的节点数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* LZF 压缩算法深度 */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;           <span class="comment">/* 对应的 ziplist */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist 字节数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* ziplist 个数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* 该节点先前是否被压缩 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* 节点太小无法压缩 */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; </span><br><span class="line">    <span class="keyword">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出 quicklist 是一个双向链表，链表中的每个节点实际上是一个 ziplist，它们的结构如下图所示：</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/assets/2020-02-28-31230.png" alt="列表类型使用-quicklist结构图.png"></p><p>ziplist 作为 quicklist 的实际存储结构，它本质是一个字节数组，ziplist 数据结构如下图所示：</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/assets/2020-02-28-031231.png" alt="列表类型使用-压缩列表结构图.png"></p><p>其中的字段含义如下：</p><ul><li>zlbytes：压缩列表字节长度，占 4 字节；</li><li>zltail：压缩列表尾元素相对于起始元素地址的偏移量，占 4 字节；</li><li>zllen：压缩列表的元素个数；</li><li>entryX：压缩列表存储的所有元素，可以是字节数组或者是整数；</li><li>zlend：压缩列表的结尾，占 1 字节。</li></ul><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>下面我们来看一下更多关于列表类型的源码实现。</p><h2 id="添加功能源码分析"><a href="#添加功能源码分析" class="headerlink" title="添加功能源码分析"></a>添加功能源码分析</h2><p>quicklist 添加操作对应函数是 quicklistPush，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123;</span><br><span class="line">        <span class="comment">// 在列表头部添加元素</span></span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123;</span><br><span class="line">        <span class="comment">// 在列表尾部添加元素</span></span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 quicklistPushHead 为例，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        <span class="comment">// 在头部节点插入元素</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 头部节点不能继续插入，需要新建 quicklistNode、ziplist 进行插入</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新建的 quicklistNode 插入到 quicklist 结构中</span></span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>quicklistPushHead 函数的执行流程，先判断 quicklist 的 head 节点是否可以插入数据，如果可以插入则使用 ziplist 的接口进行插入，否则就新建 quicklistNode 节点进行插入。</p><p>函数的入参是待插入的 quicklist，还有需要插入的值 value 以及他的大小 sz。</p><p>函数的返回值为 int，0 表示没有新建 head，1 表示新建了 head。 quicklistPushHead 执行流程，如下图所示：</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/assets/2020-02-28-031232.png" alt="列表类型使用-插入流程图.png"></p><h2 id="删除功能源码分析"><a href="#删除功能源码分析" class="headerlink" title="删除功能源码分析"></a>删除功能源码分析</h2><p>quicklist 元素删除分为两种情况：单一元素删除和区间元素删除，它们都位于 src/quicklist.c 文件中。</p><h3 id="单一元素删除"><a href="#单一元素删除" class="headerlink" title="单一元素删除"></a>单一元素删除</h3><p>单一元素的删除函数是 quicklistDelEntry，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> </span>&#123;</span><br><span class="line">    quicklistNode *prev = entry-&gt;node-&gt;prev;</span><br><span class="line">    quicklistNode *next = entry-&gt;node-&gt;next;</span><br><span class="line">    <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">    <span class="keyword">int</span> deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,</span><br><span class="line">                                         entry-&gt;node, &amp;entry-&gt;zi);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 quicklistDelEntry 函数的底层，依赖 quicklistDelIndex 函数进行元素删除。</p><h3 id="区间元素删除"><a href="#区间元素删除" class="headerlink" title="区间元素删除"></a>区间元素删除</h3><p>区间元素删除的函数是 quicklistDelRange，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start 表示开始删除的下标，count 表示要删除的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistDelRange</span><span class="params">(quicklist *quicklist, <span class="keyword">const</span> <span class="keyword">long</span> start,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> extent = count; </span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="number">0</span> &amp;&amp; extent &gt; (quicklist-&gt;count - start)) &#123;</span><br><span class="line">        <span class="comment">// 删除的元素个数大于已有元素</span></span><br><span class="line">        extent = quicklist-&gt;count - start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt; <span class="number">0</span> &amp;&amp; extent &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(-start)) &#123;</span><br><span class="line">        <span class="comment">// 删除指定的元素个数</span></span><br><span class="line">        extent = -start; <span class="comment">/* c.f. LREM -29 29; just delete until end. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// extent 为剩余需要删除的元素个数，</span></span><br><span class="line">    <span class="keyword">while</span> (extent) &#123;</span><br><span class="line">        <span class="comment">// 保存下个 quicklistNode，因为本节点可能会被删除</span></span><br><span class="line">        quicklistNode *next = node-&gt;next;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> del;</span><br><span class="line">        <span class="keyword">int</span> delete_entire_node = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry.offset == <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">            <span class="comment">// 删除整个 quicklistNode</span></span><br><span class="line">            delete_entire_node = <span class="number">1</span>;</span><br><span class="line">            del = node-&gt;count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &gt;= <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">           <span class="comment">// 删除本节点的所有元素</span></span><br><span class="line">            del = node-&gt;count - entry.offset;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// entry.offset&lt;0 表示从后向前，相反则表示从前向后剩余的元素个数</span></span><br><span class="line">            del = -entry.offset;</span><br><span class="line">            <span class="keyword">if</span> (del &gt; extent)</span><br><span class="line">                del = extent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除本节点部分元素</span></span><br><span class="line">            del = extent;</span><br><span class="line">        &#125;</span><br><span class="line">        D(<span class="string">&quot;[%ld]: asking to del: %ld because offset: %d; (ENTIRE NODE: %d), &quot;</span></span><br><span class="line">          <span class="string">&quot;node count: %u&quot;</span>,</span><br><span class="line">          extent, del, entry.offset, delete_entire_node, node-&gt;count);</span><br><span class="line">        <span class="keyword">if</span> (delete_entire_node) &#123;</span><br><span class="line">            __quicklistDelNode(quicklist, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quicklistDecompressNodeForUse(node);</span><br><span class="line">            node-&gt;zl = ziplistDeleteRange(node-&gt;zl, entry.offset, del);</span><br><span class="line">            quicklistNodeUpdateSz(node);</span><br><span class="line">            node-&gt;count -= del;</span><br><span class="line">            quicklist-&gt;count -= del;</span><br><span class="line">            quicklistDeleteIfEmpty(quicklist, node);</span><br><span class="line">            <span class="keyword">if</span> (node)</span><br><span class="line">                quicklistRecompressOnly(quicklist, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩余待删除元素的个数</span></span><br><span class="line">        extent -= del;</span><br><span class="line">        <span class="comment">// 下个 quicklistNode</span></span><br><span class="line">        node = next;</span><br><span class="line">        <span class="comment">// 从下个 quicklistNode 起始位置开始删除</span></span><br><span class="line">        entry.offset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，quicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。</p><p>quicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。</p><h3 id="更多源码"><a href="#更多源码" class="headerlink" title="更多源码"></a>更多源码</h3><p>除了上面介绍的几个常用函数之外，还有一些更多的函数，例如：</p><ul><li>quicklistCreate：创建 quicklist；</li><li>quicklistInsertAfter：在某个元素的后面添加数据；</li><li>quicklistInsertBefore：在某个元素的前面添加数据；</li><li>quicklistPop：取出并删除列表的第一个或最后一个元素；</li><li>quicklistReplaceAtIndex：替换某个元素。</li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>列表的典型使用场景有以下两个：</p><ul><li>消息队列：列表类型可以使用 rpush 实现先进先出的功能，同时又可以使用 lpop 轻松的弹出（查询并删除）第一个元素，所以列表类型可以用来实现消息队列；</li><li>文章列表：对于博客站点来说，当用户和文章都越来越多时，为了加快程序的响应速度，我们可以把用户自己的文章存入到 List 中，因为 List 是有序的结构，所以这样又可以完美的实现分页功能，从而加速了程序的响应速度。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过本文我们可以知道列表类型并不是简单的双向链表，而是采用了 quicklist 的数据结构对数据进行存取，quicklist 是 Redis 3.2 新增的数据类型，它的底层采取的是压缩列表加双向链表的存储结构，quicklist 为了存储更多的数据，会对每个 quicklistNode 节点进行压缩，这样就可以有效的存储更多的消息队列或者文章的数据了。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字典使用与内部实现原理</title>
      <link href="posts/%E5%AD%97%E5%85%B8%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>posts/%E5%AD%97%E5%85%B8%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>字典类型 (Hash) 又被成为散列类型或者是哈希表类型，它是将一个键值 (key) 和一个特殊的“哈希表”关联起来，这个“哈希表”表包含两列数据：字段和值。例如我们使用字典类型来存储一篇文章的详情信息，存储结构如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/ebOtN3yXRpidYSE.png" alt="哈希表存储结构.png"></p><p>同理我们也可以使用字典类型来存储用户信息，并且使用字典类型来存储此类信息，是不需要手动序列化和反序列化数据的，所以使用起来更加的方便和高效。</p><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><p>首先我们使用命令行工具 redis-cli，来对字典类型进行相关的操作。</p><h2 id="插入单个元素"><a href="#插入单个元素" class="headerlink" title="插入单个元素"></a>插入单个元素</h2><p>语法：hset key field value 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash key2 value2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h2 id="当某键不存在时，插入数据"><a href="#当某键不存在时，插入数据" class="headerlink" title="当某键不存在时，插入数据"></a>当某键不存在时，插入数据</h2><p>语法：hsetnx key field value 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx myhash k4 v4</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash k4</span><br><span class="line">&quot;v4&quot;</span><br></pre></td></tr></table></figure><p>如果<strong>尝试插入已存在的键</strong>，不会改变原来的值，示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx myhash k4 val4</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hget myhash k4</span><br><span class="line">&quot;v4&quot;</span><br></pre></td></tr></table></figure><p>尝试修改已经存在的 k4 赋值为 val4，但并没有生效，查询 k4 的结果依然是原来的值 v4。</p><h2 id="查询单个元素"><a href="#查询单个元素" class="headerlink" title="查询单个元素"></a>查询单个元素</h2><p>语法：hget key field 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget myhash key1</span><br><span class="line">&quot;value1&quot;</span><br></pre></td></tr></table></figure><h2 id="删除-key-中的一个或多个元素"><a href="#删除-key-中的一个或多个元素" class="headerlink" title="删除 key 中的一个或多个元素"></a>删除 key 中的一个或多个元素</h2><p>语法：hdel myhash field [field …] 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel myhash key1 key2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>注意：不能使用类似于 <code>hdel myhash</code> 的命令删除整个 Hash 值的。</p><h2 id="某个整数值累加计算"><a href="#某个整数值累加计算" class="headerlink" title="某个整数值累加计算"></a>某个整数值累加计算</h2><p>语法：hincrby key field increment 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash k3 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash k3 2</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; hget myhash k3</span><br><span class="line">&quot;5&quot;</span><br></pre></td></tr></table></figure><h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>接下来我们用 Java 代码实现对 Redis 的操作，同样我们先引入 Jedis 框架 ，接下来再用代码来对字典类型进行操作，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 把 Key 值定义为变量</span></span><br><span class="line">        <span class="keyword">final</span> String REDISKEY = <span class="string">&quot;myhash&quot;</span>;</span><br><span class="line">        <span class="comment">// 插入单个元素</span></span><br><span class="line">        jedis.hset(REDISKEY, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询单个元素</span></span><br><span class="line">        Map&lt;String, String&gt; singleMap = jedis.hgetAll(REDISKEY);</span><br><span class="line">        System.out.println(singleMap.get(<span class="string">&quot;key1&quot;</span>));  <span class="comment">// 输出：value1</span></span><br><span class="line">        <span class="comment">// 查询所有元素</span></span><br><span class="line">        Map&lt;String, String&gt; allMap = jedis.hgetAll(REDISKEY);</span><br><span class="line">        System.out.println(allMap.get(<span class="string">&quot;k2&quot;</span>)); <span class="comment">// 输出：val2</span></span><br><span class="line">        System.out.println(allMap); <span class="comment">// 输出：&#123;key1=value1, k1=val1, k2=val2, k3=9.2, k4=v4...&#125;</span></span><br><span class="line">        <span class="comment">// 删除单个元素</span></span><br><span class="line">        Long delResult = jedis.hdel(REDISKEY, <span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除结果：&quot;</span> + delResult);    <span class="comment">// 输出：删除结果：1</span></span><br><span class="line">        <span class="comment">// 查询单个元素</span></span><br><span class="line">        System.out.println(jedis.hget(REDISKEY, <span class="string">&quot;key1&quot;</span>)); <span class="comment">// 输出：返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，在 Jedis 中我们可以直接使用 Map 来接收 Redis 中读取的字典类型的数据，省去了手动转化的麻烦，还是比较方便的。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>字典类型本质上是由数组和链表结构组成的，来看字典类型的源码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span> <span class="comment">// dict.h</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 下一个 entry</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>字典类型的数据结构，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/NpDHGZVzoeAtKJ7.png" alt="Redis-HashType-02.png"></p><p>通常情况下字典类型会使用数组的方式来存储相关的数据，但发生哈希冲突时才会使用链表的结构来存储数据。</p><h1 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h1><p>字典类型的存储流程是先将键值进行 Hash 计算，得到存储键值对应的数组索引，再根据数组索引进行数据存储，但在小概率事件下可能会出完全不相同的键值进行 Hash 计算之后，得到相同的 Hash 值，这种情况我们称之为<strong>哈希冲突</strong>。</p><p>哈希冲突一般通过链表的形式解决，相同的哈希值会对应一个链表结构，每次有哈希冲突时，就把新的元素插入到链表的尾部，请参考上面数据结构的那张图。</p><p>键值查询的流程如下：</p><ul><li>通过算法 (Hash，计算和取余等) 操作获得数组的索引值，根据索引值找到对应的元素；</li><li>判断元素和查找的键值是否相等，相等则成功返回数据，否则需要查看 next 指针是否还有对应其他元素，如果没有，则返回 null，如果有的话，重复此步骤。</li></ul><p>键值查询流程，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/jQ79rfIC6g1kLHM.png" alt="Redis-HashType-03.png"></p><h1 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h1><p>Redis 为了保证应用的高性能运行，提供了一个重要的机制——渐进式 rehash。 渐进式 rehash 是用来保证字典缩放效率的，也就是说在字典进行扩容或者缩容是会采取渐进式 rehash 的机制。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>当元素数量等于数组长度时就会进行扩容操作，源码在 dict.c 文件中，核心代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 需要的容量小于当前容量，则不需要扩容 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictht n; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size); <span class="comment">// 重新计算扩容后的值</span></span><br><span class="line">    <span class="comment">/* 计算新的扩容大小等于当前容量，不需要扩容 */</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">/* 分配一个新的哈希表，并将所有指针初始化为NULL */</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一次初始化</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n; <span class="comment">// 把增量输入放入新 ht[1] 中</span></span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>; <span class="comment">// 非默认值 -1，表示需要进行 rehash</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，如果需要扩容则会申请一个新的内存地址赋值给 ht[1]，并把字典的 rehashindex 设置为 0，表示之后需要进行 rehash 操作。</p><h2 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h2><p>当字典的使用容量不足总空间的 10% 时就会触发缩容，Redis 在进行缩容时也会把 rehashindex 设置为 0，表示之后需要进行 rehash 操作。</p><h2 id="渐进式rehash流程"><a href="#渐进式rehash流程" class="headerlink" title="渐进式rehash流程"></a>渐进式rehash流程</h2><p>在进行渐进式 rehash 时，会同时保留两个 hash 结构，新键值对加入时会直接插入到新的 hash 结构中，并会把旧 hash 结构中的元素一点一点的移动到新的 hash 结构中，当移除完最后一个元素时，清空旧 hash 结构，主要的执行流程如下：</p><ul><li>扩容或者缩容时把字典中的字段 rehashidx 标识为 0；</li><li>在执行定时任务或者执行客户端的 hset、hdel 等操作指令时，判断是否需要触发 rehash 操作（通过 rehashidx 标识判断），如果需要触发 rehash 操作，也就是调用 dictRehash 函数，dictRehash 函数会把 ht[0] 中的元素依次添加到新的 Hash 表 ht[1] 中；</li><li>rehash 操作完成之后，清空 Hash 表 ht[0]，然后对调 ht[1] 和 ht[0] 的值，把新的数据表 ht[1] 更改为 ht[0]，然后把字典中的 rehashidx 标识为 -1，表示不需要执行 rehash 操作。</li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>哈希字典的典型使用场景如下：</p><ul><li>商品购物车，购物车非常适合用哈希字典表示，使用人员唯一编号作为字典的 key，value 值可以存储商品的 id 和数量等信息；</li><li>存储用户的属性信息，使用人员唯一编号作为字典的 key，value 值为属性字段和对应的值；</li><li>存储文章详情页信息等。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文我们学习了字典类型的操作命令和在代码中的使用，也明白了字典类型实际是由数组和链表组成的，当字典进行扩容或者缩容时会进行渐进式 rehash 操作，渐进式 rehash 是用来保证 Redis 运行效率的，它的执行流程是同时保留两个哈希表，把旧表中的元素一点一点的移动到新表中，查询的时候会先查询两个哈希表，当所有元素都移动到新的哈希表之后，就会删除旧的哈希表。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有序集合使用与内部实现原理</title>
      <link href="posts/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>posts/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>有序集合类型 (Sorted Set) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合的存储元素值也是不能重复的，但分值是可以重复的。</p><p>当我们把学生的成绩存储在有序集合中时，它的存储结构如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/TZJBwbfpaE2hnDN.png" alt="学生存储值.png"></p><p>下面我们先从有序集合的使用开始说起。</p><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><h2 id="添加一个或多个元素"><a href="#添加一个或多个元素" class="headerlink" title="添加一个或多个元素"></a>添加一个或多个元素</h2><p>语法：zadd key [NX|XX] [CH] [INCR] score member [score member …] 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 10 java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset1 3 golang 4 sql 1 redis</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>可以看出有序集合的添加是 <code>zadd 键值 分值1 元素值1 分值2 元素值2</code> 的形式添加的。</p><h2 id="查询所有元素列表"><a href="#查询所有元素列表" class="headerlink" title="查询所有元素列表"></a>查询所有元素列表</h2><p>语法：zrange key start stop [WITHSCORES] 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange zset 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;mysql&quot;</span><br><span class="line">3) &quot;java&quot;</span><br></pre></td></tr></table></figure><p>其中 -1 表示最后一个元素，查询结果包含开始和结束元素。</p><h2 id="删除一个或多个元素-根据元素值"><a href="#删除一个或多个元素-根据元素值" class="headerlink" title="删除一个或多个元素(根据元素值)"></a>删除一个或多个元素(根据元素值)</h2><p>语法：zrem key member [member …] 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore zset1 0 -1 #查询所有元素</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;sql&quot;</span><br><span class="line">4) &quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem zset1 redis sql #删除元素：reids、sql</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1 #查询所有元素</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">2) &quot;java&quot;</span><br></pre></td></tr></table></figure><p>删除命令中如果包含了不存在的元素，并不会影响命令的正常执行，不存在的元素将会被忽略。</p><h2 id="查询某元素的-score-值"><a href="#查询某元素的-score-值" class="headerlink" title="查询某元素的 score 值"></a>查询某元素的 score 值</h2><p>语法：zscore key member 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore zset1 redis</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><h2 id="查询-score-区间内元素"><a href="#查询-score-区间内元素" class="headerlink" title="查询 score 区间内元素"></a>查询 score 区间内元素</h2><p>语法：zrangebyscore key min max [WITHSCORES] [LIMIT offset count] 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore zset1 3 10</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;sql&quot;</span><br><span class="line">4) &quot;java&quot;</span><br></pre></td></tr></table></figure><h2 id="查询某元素排名"><a href="#查询某元素排名" class="headerlink" title="查询某元素排名"></a>查询某元素排名</h2><p>语法：zrank key member 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset 5 redis 10 java 8 mysql #创建有序集合</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrank zset java #查询元素排序</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrank zset redis</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>可以看出，排名是从 0 开始的，排名可以理解为元素排序后的下标值。</p><h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>下面来看有序集合在 Java 中的使用，同样先添加 Jedis 框架，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZSetExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;小明&quot;</span>, <span class="number">80.5d</span>);</span><br><span class="line">        map.put(<span class="string">&quot;小红&quot;</span>, <span class="number">75d</span>);</span><br><span class="line">        map.put(<span class="string">&quot;老王&quot;</span>, <span class="number">85d</span>);</span><br><span class="line">        <span class="comment">// 为有序集合(ZSet)添加元素</span></span><br><span class="line">        jedis.zadd(<span class="string">&quot;grade&quot;</span>, map);</span><br><span class="line">        <span class="comment">// 查询分数在 80 分到 100 分之间的人(包含 80 分和 100 分)</span></span><br><span class="line">        Set&lt;String&gt; gradeSet = jedis.zrangeByScore(<span class="string">&quot;grade&quot;</span>, <span class="number">80</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(gradeSet); <span class="comment">// 输出：[小明, 老王]</span></span><br><span class="line">        <span class="comment">// 查询小红的排名(排名从 0 开始)</span></span><br><span class="line">        System.out.println(jedis.zrank(<span class="string">&quot;grade&quot;</span>, <span class="string">&quot;小明&quot;</span>)); <span class="comment">// 输出：1</span></span><br><span class="line">        <span class="comment">// 从集合中移除老王</span></span><br><span class="line">        jedis.zrem(<span class="string">&quot;grade&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询有序集合中的所有元素(根据排名从小到大)</span></span><br><span class="line">        Set&lt;String&gt; range = jedis.zrange(<span class="string">&quot;grade&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(range); <span class="comment">// 输出：[小红, 小明]</span></span><br><span class="line">        <span class="comment">// 查询有序集合中的所有元素(根据 score 从小到大)</span></span><br><span class="line">        Set&lt;String&gt; rangeByScore = jedis.zrangeByScore(<span class="string">&quot;grade&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(rangeByScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h1><p>有序集合是由 ziplist (压缩列表) 或 skiplist (跳跃表) 组成的。</p><h2 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h2><p>当数据比较少时，有序集合使用的是 ziplist 存储的，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myzset 1 db 2 redis 3 mysql</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; object encoding myzset</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure><p>从结果可以看出，有序集合把 myset 键值对存储在 ziplist 结构中了。 有序集合使用 ziplist 格式存储必须满足以下两个条件：</p><ul><li>有序集合保存的元素个数要小于 128 个；</li><li>有序集合保存的所有元素成员的长度都必须小于 64 字节。</li></ul><p>如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。 接下来我们来测试以下，当有序集合中某个元素长度大于 64 字节时会发生什么情况？ 代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zmaxleng 1.0 redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding zmaxleng</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; zadd zmaxleng 2.0 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding zmaxleng</span><br><span class="line">&quot;skiplist&quot;</span><br></pre></td></tr></table></figure><p>通过以上代码可以看出，当有序集合保存的所有元素成员的长度大于 64 字节时，有序集合就会从 ziplist 转换成为 skiplist。</p><blockquote><p>小贴士：可以通过配置文件中的 zset-max-ziplist-entries（默认 128）和 zset-max-ziplist-value（默认 64）来设置有序集合使用 ziplist 存储的临界值。</p></blockquote><h2 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h2><p>skiplist 数据编码底层是使用 zset 结构实现的，而 zset 结构中包含了一个字典和一个跳跃表，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>更多关于跳跃表的源码实现，会在后面的章节详细介绍。</p><h3 id="跳跃表实现原理"><a href="#跳跃表实现原理" class="headerlink" title="跳跃表实现原理"></a>跳跃表实现原理</h3><p>跳跃表的结构如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/oGDj5XfA2vJyFLM.png" alt="有序集合-跳跃表.png"></p><p>根据以上图片展示，当我们在跳跃表中查询值 32 时，执行流程如下：</p><ul><li>从最上层开始找，1 比 32 小，在当前层移动到下一个节点进行比较；</li><li>7 比 32 小，当前层移动下一个节点比较，由于下一个节点指向 Null，所以以 7 为目标，移动到下一层继续向后比较；</li><li>18 小于 32，继续向后移动查找，对比 77 大于 32，以 18 为目标，移动到下一层继续向后比较；</li><li>对比 32 等于 32，值被顺利找到。</li></ul><p>从上面的流程可以看出，跳跃表会想从最上层开始找起，依次向后查找，如果本层的节点大于要找的值，或者本层的节点为 Null 时，以上一个节点为目标，往下移一层继续向后查找并循环此流程，直到找到该节点并返回，如果对比到最后一个元素仍未找到，则返回 Null。</p><h3 id="为什么是跳跃表？而非红黑树？"><a href="#为什么是跳跃表？而非红黑树？" class="headerlink" title="为什么是跳跃表？而非红黑树？"></a>为什么是跳跃表？而非红黑树？</h3><p>因为跳跃表的性能和红黑树基本相近，但却比红黑树更好实现，所有 Redis 的有序集合会选用跳跃表来实现存储。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>有序集合的经典使用场景如下：</p><ul><li>学生成绩排名</li><li>粉丝列表，根据关注的先后时间排序</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过本文的学习我们了解到，有序集合具有唯一性和排序的功能，排序功能是借助分值字段 score 实现的，score 字段不仅可以实现排序功能，还可以实现数据的赛选与过滤的功能。我们还了解到了有序集合是由 压缩列表 (ziplist) 或跳跃列表 (skiplist) 来存储的，当元素个数小于 128 个，并且所有元素的值都小于 64 字节时，有序集合会采取 ziplist 来存储，反之则会用 skiplist 来存储，其中 skiplist 是从上往下、从前往后进行元素查找的，相比于传统的普通列表，可能会快很多，因为普通列表只能从前往后依次查找。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集合使用与内部实现原理</title>
      <link href="posts/%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>posts/%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>集合类型 (Set) 是一个无序并唯一的键值集合。</p><p>之所以说集合类型是一个无序集合，是因为它的存储顺序不会按照插入的先后顺序进行存储，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset v2 v1 v3 #插入数据 v2、v1、v3 </span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers myset #查询数据</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br></pre></td></tr></table></figure><p>从上面代码执行结果可以看出，myset 的存储顺序并不是以插入的先后顺序进行存储的。</p><p>集合类型和列表类型的区别如下：</p><ul><li>列表可以存储重复元素，集合只能存储非重复元素；</li><li>列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。</li></ul><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><p>集合类型的功能比列表类型丰富一些，集合类型可以用来统计多个集合的交集、错集和并集，如下代码所示。</p><h2 id="添加一个或多个元素"><a href="#添加一个或多个元素" class="headerlink" title="添加一个或多个元素"></a>添加一个或多个元素</h2><p>语法：sadd key member [member …] 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset v1 v2 v3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><h2 id="查询集合所有元素"><a href="#查询集合所有元素" class="headerlink" title="查询集合所有元素"></a>查询集合所有元素</h2><p>语法：smembers key 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br></pre></td></tr></table></figure><h2 id="查询集合的成员数量"><a href="#查询集合的成员数量" class="headerlink" title="查询集合的成员数量"></a>查询集合的成员数量</h2><p>语法：scard key 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><h2 id="查询集合中是否包含某个元素"><a href="#查询集合中是否包含某个元素" class="headerlink" title="查询集合中是否包含某个元素"></a>查询集合中是否包含某个元素</h2><p>语法：sismember key member 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember myset v1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset v4</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h2 id="从一个集合中移动一个元素到另一个集合"><a href="#从一个集合中移动一个元素到另一个集合" class="headerlink" title="从一个集合中移动一个元素到另一个集合"></a>从一个集合中移动一个元素到另一个集合</h2><p>语法：smove source destination member 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v8&quot;</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 v3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v8&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br></pre></td></tr></table></figure><h2 id="移除集合中一个或多个元素"><a href="#移除集合中一个或多个元素" class="headerlink" title="移除集合中一个或多个元素"></a>移除集合中一个或多个元素</h2><p>语法：srem key member [member …] 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v4&quot;</span><br><span class="line">2) &quot;v1&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">4) &quot;v2&quot;</span><br><span class="line">5) &quot;v5&quot;</span><br><span class="line">127.0.0.1:6379&gt; srem myset v5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v3&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v1&quot;</span><br><span class="line">4) &quot;v4&quot;</span><br></pre></td></tr></table></figure><p>注意：使用 srem 指令，不存在的元素将会被忽略。 </p><h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>下面来看集合类型在 Java 中的使用，同样先添加 Jedis 框架，使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建集合并添加元素</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;golang&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询集合中的所有元素</span></span><br><span class="line">        Set&lt;String&gt; members = jedis.smembers(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(members); <span class="comment">// 输出：[java, golang]</span></span><br><span class="line">        <span class="comment">// 查询集合中的元素数量</span></span><br><span class="line">        System.out.println(jedis.scard(<span class="string">&quot;set1&quot;</span>));</span><br><span class="line">        <span class="comment">// 移除集合中的一个元素</span></span><br><span class="line">        jedis.srem(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;golang&quot;</span>);</span><br><span class="line">        System.out.println(jedis.smembers(<span class="string">&quot;set1&quot;</span>)); <span class="comment">// 输出：[java]</span></span><br><span class="line">        <span class="comment">// 创建集合 set2 并添加元素</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;golang&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询两个集合中交集</span></span><br><span class="line">        Set&lt;String&gt; inters = jedis.sinter(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">        System.out.println(inters); <span class="comment">// 输出：[java]</span></span><br><span class="line">        <span class="comment">// 查询两个集合中并集</span></span><br><span class="line">        Set&lt;String&gt; unions = jedis.sunion(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">        System.out.println(unions); <span class="comment">// 输出：[java,golang]</span></span><br><span class="line">        <span class="comment">// 查询两个集合的错集</span></span><br><span class="line">        Set&lt;String&gt; diffs = jedis.sdiff(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(diffs); <span class="comment">// 输出：[golang]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h1><p>集合类型是由 intset (整数集合) 或 hashtable (普通哈希表) 组成的。当集合类型以 hashtable 存储时，哈希表的 key 为要插入的元素值，而哈希表的 value 则为 Null，如下图所示：</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/assets/2020-02-28-031226.png" alt="集合Set-hashtable.png"></p><p>当集合中所有的值都为整数时，Redis 会使用 intset 结构来存储，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset 1 9 3 -2</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，<strong>当所有元素都为整数时，集合会以 intset 结构进行(数据)存储</strong>。 当发生以下两种情况时，会导致集合类型使用 hashtable 而非 intset 存储： 1）当元素的个数超过一定数量时，默认是 512 个，该值可通过命令 <code>set-max-intset-entries xxx</code> 来配置。 2）当元素为非整数时，集合将会使用 hashtable 来存储，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myht &quot;redis&quot; &quot;db&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; object encoding myht</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，<strong>当元素为非整数时，集合会使用 hashtable 进行存储</strong>。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>集合源码在 t_set.c 文件中，核心源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 添加元素到集合</span></span><br><span class="line"><span class="comment"> * 如果当前值已经存在，则返回 0 不作任何处理，否则就添加该元素，并返回 1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// 字典类型</span></span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            <span class="comment">// 把 value 作为字典到 key，将 Null 作为字典到 value，将元素存入到字典</span></span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123; <span class="comment">// inset 数据类型</span></span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">// 超过 inset 的最大存储数量，则使用字典类型存储</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 转化为整数类型失败，使用字典类型存储</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未知编码(类型)</span></span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这些代码验证了，我们上面所说的内容，当元素都为整数并且元素的个数没有到达设置的最大值时，键值的存储使用的是 intset 的数据结构，反之到元素超过了一定的范围，又或者是存储的元素为非整数时，集合会选择使用 hashtable 的数据结构进行存储。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>集合类型的经典使用场景如下：</p><ul><li>微博关注我的人和我关注的人都适合用集合存储，可以保证人员不会重复；</li><li>中奖人信息也适合用集合类型存储，这样可以保证一个人不会重复中奖。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过本文我们知道了，集合类型是由整数集合 (intset) 或者是哈希表 (hashtable) 组成的，集合类型比较适合用来数据去重和保障数据的唯一性，除此之外，集合类型还可以用来统计多个集合的交集、错集和并集 (见附录)。当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串使用与内部实现原理</title>
      <link href="posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Redis 发展到现在已经有 9 种数据类型了，其中最基础、最常用的数据类型有 5 种，它们分别是：字符串类型、列表类型、哈希表类型、集合类型、有序集合类型，而在这 5 种数据类型中最常用的是字符串类型，所以本文我们先从字符串的使用开始说起。</p><p>字符串类型的全称是 Simple Dynamic Strings 简称 SDS，中文意思是：简单动态字符串。它是以键值对 key-value 的形式进行存储的，根据 key 来存储和获取 value 值，它的使用相对来说比较简单，但在实际项目中应用非常广泛。</p><h1 id="字符串类型能做什么？"><a href="#字符串类型能做什么？" class="headerlink" title="字符串类型能做什么？"></a>字符串类型能做什么？</h1><p>字符串类型的使用场景有很多，但从功能的角度来区分，大致可分为以下两种：</p><ul><li>字符串存储和操作；</li><li>整数类型和浮点类型的存储和计算。</li></ul><p>字符串最常用的业务场景有以下几个。</p><h2 id="页面数据缓存"><a href="#页面数据缓存" class="headerlink" title="页面数据缓存"></a>页面数据缓存</h2><p>我们知道，一个系统最宝贵的资源就是数据库资源，随着公司业务的发展壮大，数据库的存储量也会越来越大，并且要处理的请求也越来越多，当数据量和并发量到达一定级别之后，数据库就变成了拖慢系统运行的“罪魁祸首”，为了避免这种情况的发生，我们可以把查询结果放入缓存(Redis)中，让下次同样的查询直接去缓存系统取结果，而非查询数据库，这样既减少了数据库的压力，同时也提高了程序的运行速度。</p><p>介于以上这个思路，我们可以把文章详情页的数据放入缓存系统。具体的做法是先将文章详情页序列化为字符串存入缓存，再从缓存中读取到字符串，反序列化成对象，然后再赋值到页面进行显示 (当然也可以用哈希类型进行存储，这会在下一篇文章中讲到)，这样我们就实现了文章详情页的缓存功能，架构流程对比图如下所示。</p><p>原始系统运行流程图：</p><p><img src="https://s2.loli.net/2021/12/13/EC9VyiSKQF6fgOe.png" alt="字符串类型使用-1.png"></p><p>引入缓存系统后的流程图：</p><p><img src="https://s2.loli.net/2021/12/13/dYgAvkbGDHIMq39.png" alt="字符串类型使用-2.png"></p><h2 id="数字计算与统计"><a href="#数字计算与统计" class="headerlink" title="数字计算与统计"></a>数字计算与统计</h2><p>Redis 可以用来存储整数和浮点类型的数据，并且可以通过命令直接累加并存储整数信息，这样就省去了每次先要取数据、转换数据、拼加数据、再存入数据的麻烦，只需要使用一个命令就可以完成此流程，具体实现过程本文下半部分会讲。这样我们就可以使用此功能来实现访问量的统计，当有人访问时访问量 +1 就可以了。</p><h2 id="共享-Session-信息"><a href="#共享-Session-信息" class="headerlink" title="共享 Session 信息"></a>共享 Session 信息</h2><p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p><p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题。分布式系统每次会把请求随机分配到不同的服务器，因此我们需要借助缓存系统对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去统一的缓存系统获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p><p>分布式系统单独存储 Session 流程图：</p><p><img src="https://s2.loli.net/2021/12/13/1ULocYz76Iedxb4.png" alt="字符串类型使用-3.png"></p><p>分布式系统使用同一的缓存系统存储 Session 流程图：</p><p><img src="https://s2.loli.net/2021/12/13/qSjMmIB8xtCsT5c.png" alt="字符串类型使用-4.png"></p><h1 id="字符串如何使用？"><a href="#字符串如何使用？" class="headerlink" title="字符串如何使用？"></a>字符串如何使用？</h1><p>通常我们会使用两种方式来操作 Redis：第一种是使用命令行来操作，例如 redis-cli；另一种是使用代码的方式来操作，下面我们分别来看。</p><h2 id="命令行操作方式"><a href="#命令行操作方式" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h2><p>字符串的操作命令有很多，但大体可分为以下几类：</p><ul><li>单个键值对操作</li><li>多个键值对操作</li><li>数字统计</li></ul><p>我们本文使用 redis-cli 来实现对 Redis 的操作，在使用命令之前，先输入 <code>redis-cli</code> 来链接到 Redis 服务器。</p><h3 id="单个键值对操作"><a href="#单个键值对操作" class="headerlink" title="单个键值对操作"></a>单个键值对操作</h3><h4 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h4><p>语法：set key value [expiration EX seconds|PX milliseconds] [NX|XX] 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 val1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="获取键值对"><a href="#获取键值对" class="headerlink" title="获取键值对"></a>获取键值对</h4><p>语法：get key 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;val1&quot;</span><br></pre></td></tr></table></figure><h4 id="给元素追加值"><a href="#给元素追加值" class="headerlink" title="给元素追加值"></a>给元素追加值</h4><p>语法：append key value 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; append k1 append</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;v1append&quot;</span></span><br></pre></td></tr></table></figure><h4 id="查询字符串的长度"><a href="#查询字符串的长度" class="headerlink" title="查询字符串的长度"></a>查询字符串的长度</h4><p>语法：strlen key 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; strlen k1</span><br><span class="line">(integer) <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="多个键值对操作"><a href="#多个键值对操作" class="headerlink" title="多个键值对操作"></a>多个键值对操作</h3><h4 id="创建一个或多个键值对"><a href="#创建一个或多个键值对" class="headerlink" title="创建一个或多个键值对"></a>创建一个或多个键值对</h4><p>语法：mset key value [key value …] 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset k2 v2 k3 v3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：mset 是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，不会出现某些 key 被更新，而另一些 key 没被更新的情况。</p></blockquote><h4 id="查询一个或多个元素"><a href="#查询一个或多个元素" class="headerlink" title="查询一个或多个元素"></a>查询一个或多个元素</h4><p>语法：mget key [key …] 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget k2 k3</span><br><span class="line">1) &quot;v2&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br></pre></td></tr></table></figure><h3 id="数字统计"><a href="#数字统计" class="headerlink" title="数字统计"></a>数字统计</h3><p>在 Redis 中可以直接操作整型和浮点型，例如可以直接使用命令来加、减值。</p><h4 id="给整数类型的值加-1"><a href="#给整数类型的值加-1" class="headerlink" title="给整数类型的值加 1"></a>给整数类型的值加 1</h4><p>语法：incr key 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr k1</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure><h4 id="给整数类型的值减-1"><a href="#给整数类型的值减-1" class="headerlink" title="给整数类型的值减 1"></a>给整数类型的值减 1</h4><p>语法：decr key 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; decr k1</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><h4 id="根据-key-减去指定的值"><a href="#根据-key-减去指定的值" class="headerlink" title="根据 key 减去指定的值"></a>根据 key 减去指定的值</h4><p>语法：decrby key decrement 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; decrby k1 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><p>如果 key 不存在，则会先初始化此 key 为 0 ，然后再执行减法操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; decrby k2 3</span><br><span class="line">(integer) -3</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">&quot;-3&quot;</span><br></pre></td></tr></table></figure><h4 id="根据-key-加指定的整数值"><a href="#根据-key-加指定的整数值" class="headerlink" title="根据 key 加指定的整数值"></a>根据 key 加指定的整数值</h4><p>语法：incrby key increment 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrby k1 2</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>如果 key 不存在，则会先初始化此 key 为 0 ，然后再执行加整数值的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; incrby k3 5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">&quot;5&quot;</span><br></pre></td></tr></table></figure><h4 id="根据-key-加上指定的浮点数"><a href="#根据-key-加上指定的浮点数" class="headerlink" title="根据 key 加上指定的浮点数"></a>根据 key 加上指定的浮点数</h4><p>语法：incrbyfloat key increment 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">&quot;5&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat k3 4.9</span><br><span class="line">&quot;9.9&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">&quot;9.9&quot;</span><br></pre></td></tr></table></figure><p>如果 key 不存在，则会先初始化此 key 为 0 ，然后再执行加浮点数的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat k4 4.4</span><br><span class="line">&quot;4.4&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">&quot;4.4&quot;</span><br></pre></td></tr></table></figure><h2 id="代码操作方式"><a href="#代码操作方式" class="headerlink" title="代码操作方式"></a>代码操作方式</h2><p>本文我们使用 Java 语言来实现对 Redis 的操作，首先我们在项目中添加对 Jedis 框架的引用，如果是 Maven 项目，我们会在 pom.xml 文件中添加如下信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Jedis 是 Redis 官方推荐的 Java 客户端开发包，用于实现快速简单的操作 Redis。添加完 Jedis 之后，我们来写具体的操作代码，操作函数与命令方式的调用比较相似，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// jedis.auth(&quot;xxx&quot;); // 输入密码，没有密码，可以不设置</span></span><br><span class="line">        <span class="comment">// 添加一个元素</span></span><br><span class="line">        jedis.set(<span class="string">&quot;mystr&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        String myStr = jedis.get(<span class="string">&quot;mystr&quot;</span>);</span><br><span class="line">        System.out.println(myStr); <span class="comment">// 输出：redis</span></span><br><span class="line">        <span class="comment">// 添加多个元素(key,value,key2,value2)</span></span><br><span class="line">        jedis.mset(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;lang&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取多个元素</span></span><br><span class="line">        List&lt;String&gt; mlist = jedis.mget(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;lang&quot;</span>);</span><br><span class="line">        System.out.println(mlist);  <span class="comment">// 输出：[redis, java]</span></span><br><span class="line">        <span class="comment">// 给元素追加字符串</span></span><br><span class="line">        jedis.append(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;,mysql&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印追加的字符串</span></span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;db&quot;</span>)); <span class="comment">// 输出：redis,mysql</span></span><br><span class="line">        <span class="comment">// 当 key 不存在时，赋值键值</span></span><br><span class="line">        Long setnx = jedis.setnx(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;db2&quot;</span>);</span><br><span class="line">        <span class="comment">// 因为 db 元素已经存在，所以会返回 0 条修改</span></span><br><span class="line">        System.out.println(setnx); <span class="comment">// 输出：0</span></span><br><span class="line">        <span class="comment">// 字符串截取</span></span><br><span class="line">        String range = jedis.getrange(<span class="string">&quot;db&quot;</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(range); <span class="comment">// 输出：red</span></span><br><span class="line">        <span class="comment">// 添加键值并设置过期时间(单位：毫秒)</span></span><br><span class="line">        String setex = jedis.setex(<span class="string">&quot;db&quot;</span>, <span class="number">1000</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        System.out.println(setex); <span class="comment">// 输出：ok</span></span><br><span class="line">        <span class="comment">// 查询键值的过期时间</span></span><br><span class="line">        Long ttl = jedis.ttl(<span class="string">&quot;db&quot;</span>);</span><br><span class="line">        System.out.println(ttl); <span class="comment">// 输出：1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>本文的上半部分我们讲到了字符串的很多种使用场景，本小节就以字符串存储用户对象信息为例，我们先将用户对象信息序列化为字符串存储在 Redis，再从 Redis 中取出字符串并反序列化为对象信息为例，使用 Java 语言来实现。</p><p>首先添加 JSON 转换类，用于对象和字符串之间的序列化和反序列化，我们这里采用 Google 的 Gson 来实现，首先在 pom.xml 文件中添加如下引用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加完 Gson 引用之后，我们来写具体的业务代码，先见用户信息序列化之后存储在 Redis 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"><span class="comment">// 构建用户数据</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setId(<span class="number">1</span>);</span><br><span class="line">user.setName(<span class="string">&quot;Redis&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">10</span>);</span><br><span class="line">String jsonUser = gson.toJson(user);</span><br><span class="line"><span class="comment">// 打印用户信息(json)</span></span><br><span class="line">System.out.println(jsonUser); <span class="comment">// 输出：&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Redis&quot;,&quot;age&quot;:10&#125;</span></span><br><span class="line"><span class="comment">// 把字符串存入 Redis</span></span><br><span class="line">jedis.set(<span class="string">&quot;user&quot;</span>, jsonUser);</span><br></pre></td></tr></table></figure><p>当使用用户信息时，我们从 Redis 反序列化出来，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String getUserData = jedis.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">User userData = gson.fromJson(getUserData, User.class);</span><br><span class="line"><span class="comment">// 打印对象属性信息</span></span><br><span class="line">System.out.println(userData.getId() + <span class="string">&quot;:&quot;</span> + userData.getName()); <span class="comment">// 输出结果：1:Redis</span></span><br></pre></td></tr></table></figure><p>以上两个步骤就完成了用户信息存放至 Redis 中的过程，也是常用的经典使用场景之一。</p><h1 id="字符串的内部实现"><a href="#字符串的内部实现" class="headerlink" title="字符串的内部实现"></a>字符串的内部实现</h1><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>Redis 3.2 之前 SDS 源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sds</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">// 已占用的字节数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">// 剩余可以字节数</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 存储字符串的数据空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 Redis 3.2 之前 SDS 内部是一个带有长度信息的字节数组，存储结构如下图所示：</p><p><img src="https://s2.loli.net/2021/12/13/yS6nH1es9oatCqX.png" alt="字符串存储结构图.png"></p><p>为了更加有效的利用内存，Redis 3.2 优化了 SDS 的存储结构，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;5</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;8</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* 已使用长度，1 字节存储 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* 总长度 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 真正存储字符串的数据空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;16</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* 已使用长度，2 字节存储 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;32</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* 已使用长度，4 字节存储 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;64</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* 已使用长度，8 字节存储 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就可以针对不同长度的字符串申请相应的存储类型，从而有效的节约了内存使用。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>我们可以使用 <code>object encoding key</code> 命令来查看对象(键值对)存储的数据类型，当我们使用此命令来查询 SDS 对象时，发现 SDS 对象竟然包含了三种不同的数据类型：int、embstr 和 raw。</p><h3 id="int-类型"><a href="#int-类型" class="headerlink" title="int 类型"></a>int 类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 666</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure><h3 id="embstr-类型"><a href="#embstr-类型" class="headerlink" title="embstr 类型"></a>embstr 类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key abc</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure><h3 id="raw-类型"><a href="#raw-类型" class="headerlink" title="raw 类型"></a>raw 类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key abcdefghigklmnopqrstyvwxyzabcdefghigklmnopqrs</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure><p>int 类型很好理解，整数类型对应的就是 int 类型，而字符串则对应是 embstr 类型，当字符串长度大于 44 字节时，会变为 raw 类型存储。</p><h2 id="为什么是-44-字节？"><a href="#为什么是-44-字节？" class="headerlink" title="为什么是 44 字节？"></a>为什么是 44 字节？</h2><p>在 Redis 中，如果 SDS 的存储值大于 64 字节时，Redis 的内存分配器会认为此对象为大字符串，并使用 raw 类型来存储，当数据小于 64 字节时(字符串类型)，会使用 embstr 类型存储。既然内存分配器的判断标准是 64 字节，那为什么 embstr 类型和 raw 类型的存储判断值是 44 字节？</p><p>这是因为 Redis 在存储对象时，会创建此对象的关联信息，redisObject 对象头和 SDS 自身属性信息，这些信息都会占用一定的存储空间，因此长度判断标准就从 64 字节变成了 44 字节。</p><p>在 Redis 中，所有的对象都会包含 redisObject 对象头。我们先来看 redisObject 对象的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 4 bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 4 bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">// 3 个字节</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">// 4 个字节</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 8 个字节</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>它的参数说明如下：</p><ul><li>type：对象的数据类型，例如：string、list、hash 等，占用 4 bits 也就是半个字符的大小；</li><li>encoding：对象数据编码，占用 4 bits；</li><li>lru：记录对象的 LRU(Least Recently Used 的缩写，即最近最少使用)信息，内存回收时会用到此属性，占用 24 bits(3 字节)；</li><li>refcount：引用计数器，占用 32 bits(4 字节)；</li><li>*ptr：对象指针用于指向具体的内容，占用 64 bits(8 字节)。</li></ul><p>redisObject 总共占用 0.5 bytes + 0.5 bytes + 3 bytes + 4 bytes + 8 bytes = 16 bytes(字节)。</p><p>了解了 redisObject 之后，我们再来看 SDS 自身的数据结构，从 SDS 的源码可以看出，SDS 的存储类型一共有 5 种：SDS<em>TYPE</em>5、SDS<em>TYPE</em>8、SDS<em>TYPE</em>16、SDS<em>TYPE</em>32、SDS<em>TYPE</em>64，在这些类型中最小的存储类型为 SDS<em>TYPE</em>５，但 SDS<em>TYPE</em>５ 类型会默认转成 SDS<em>TYPE</em>8，以下源码可以证明，如下图所示：<img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/assets/2020-02-28-031223.png" alt="SDS-0116-1.png"></p><p>那我们直接来看 SDS<em>TYPE</em>8 的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出除了内容数组(buf)之外，其他三个属性分别占用了 1 个字节，最终分隔字符等于 64 字节，减去 redisObject 的 16 个字节，再减去 SDS 自身的 3 个字节，再减去结束符 <code>\0</code> 结束符占用 1 个字节，最终的结果是 44 字节(64-16-3-1=44)，内存占用如下图所示：</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/assets/2020-02-28-031224.png" alt="44字节说明图.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了字符串的定义及其使用，它的使用主要分为：单键值对操作、多键值对操作、数字统计、键值对过期操作、字符串操作进阶等。同时也介绍了字符串使用的三个场景，字符串类型可用作为：页面数据缓存，可以缓存一些文章详情信息等；数字计算与统计，例如计算页面的访问次数；也可以用作 Session 共享，用来记录管理员的登录信息等。同时我们深入的介绍了字符串的五种数据存储结构，以及字符串的三种内部数据类型，如下图所示：</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/assets/2020-02-28-031225.png" alt="字符串总结图.png"></p><p>同时我们也知道了 embstr 类型向 raw 类型转化，是因为每个 Redis 对象都包含了一个 redisObject 对象头和 SDS 自身属性占用了一定的空间，最终导致数据类型的判断长度是 44 字节。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis问题汇总和相关解决方案</title>
      <link href="posts/Redis%20%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E5%92%8C%E7%9B%B8%E5%85%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>posts/Redis%20%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E5%92%8C%E7%9B%B8%E5%85%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>本文收集了一些 Redis 使用中经常遇到的一些问题，和与之相对应的解决方案。</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩是指在短时间内，有大量缓存同时过期，导致大量的请求直接查询数据库，从而对数据库造成了巨大的压力，严重情况下可能会导致数据库宕机的情况叫做缓存雪崩。</p><p>我们先来看下正常情况下和缓存雪崩时程序的执行流程图，正常情况下系统的执行流程如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/H2OLK9VjZUTz1Wd.png" alt="正常访问图片.png"></p><p>缓存雪崩的执行流程，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/U4V6PT9yLv5WqpB.png" alt="缓存雪崩.png"></p><p>以上对比图可以看出缓存雪崩对系统造成的影响，那如何解决缓存雪崩的问题？</p><p>缓存雪崩的<strong>常用解决方案</strong>有以下几个。</p><h2 id="加锁排队"><a href="#加锁排队" class="headerlink" title="加锁排队"></a><strong>加锁排队</strong></h2><p>加锁排队可以起到缓冲的作用，防止大量的请求同时操作数据库，但它的缺点是增加了系统的响应时间，降低了系统的吞吐量，牺牲了一部分用户体验。</p><p>加锁排队的代码实现，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存 key</span></span><br><span class="line">String cacheKey = <span class="string">&quot;userlist&quot;</span>;</span><br><span class="line"><span class="comment">// 查询缓存</span></span><br><span class="line">String data = jedis.get(cacheKey);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotBlank(data)) &#123;</span><br><span class="line">    <span class="comment">// 查询到数据，直接返回结果</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 先排队查询数据库，在放入缓存</span></span><br><span class="line">    <span class="keyword">synchronized</span> (cacheKey) &#123;</span><br><span class="line">        data = jedis.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isNotBlank(data)) &#123; <span class="comment">// 双重判断</span></span><br><span class="line">            <span class="comment">// 查询数据库</span></span><br><span class="line">            data = findUserInfo();</span><br><span class="line">            <span class="comment">// 放入缓存</span></span><br><span class="line">            jedis.set(cacheKey, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为加锁排队的实现示例，读者可根据自己的实际项目情况做相应的修改。</p><h2 id="随机化过期时间"><a href="#随机化过期时间" class="headerlink" title="随机化过期时间"></a><strong>随机化过期时间</strong></h2><p>为了避免缓存同时过期，可在设置缓存时添加随机时间，这样就可以极大的避免大量的缓存同时失效。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存原本的失效时间</span></span><br><span class="line"><span class="keyword">int</span> exTime = <span class="number">10</span> * <span class="number">60</span>;</span><br><span class="line"><span class="comment">// 随机数生成类</span></span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">// 缓存设置</span></span><br><span class="line">jedis.setex(cacheKey, exTime+random.nextInt(<span class="number">1000</span>) , value);</span><br></pre></td></tr></table></figure><h2 id="设置二级缓存"><a href="#设置二级缓存" class="headerlink" title="设置二级缓存"></a><strong>设置二级缓存</strong></h2><p>二级缓存指的是除了 Redis 本身的缓存，再设置一层缓存，当 Redis 失效之后，先去查询二级缓存。</p><p>例如可以设置一个本地缓存，在 Redis 缓存失效的时候先去查询本地缓存而非查询数据库。</p><p>加入二级缓存之后程序执行流程，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/HdZKbFwXs4Tjuyi.png" alt="3.png"></p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透是指查询数据库和缓存都无数据，因为数据库查询无数据，出于容错考虑，不会将结果保存到缓存中，因此每次请求都会去查询数据库，这种情况就叫做缓存穿透。</p><p>缓存穿透执行流程如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/roPediRZIA1nu43.png" alt="缓存雪崩-缓存穿透.png"></p><p>其中红色路径表示缓存穿透的执行路径，可以看出缓存穿透会给数据库造成很大的压力。</p><p>缓存穿透的解决方案有以下几个。</p><h2 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a><strong>使用过滤器</strong></h2><p>我们可以使用过滤器来减少对数据库的请求，例如使用我们前面章节所学的布隆过滤器，我们这里简单复习一下布隆过滤器，它的原理是将数据库的数据哈希到 bitmap 中，每次查询之前，先使用布隆过滤器过滤掉一定不存在的无效请求，从而避免了无效请求给数据库带来的查询压力。</p><h2 id="缓存空结果"><a href="#缓存空结果" class="headerlink" title="缓存空结果"></a><strong>缓存空结果</strong></h2><p>另一种方式是我们可以把每次从数据库查询的数据都保存到缓存中，为了提高前台用户的使用体验 (解决长时间内查询不到任何信息的情况)，我们可以将空结果的缓存时间设置得短一些，例如 3~5 分钟。</p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存击穿指的是某个热点缓存，在某一时刻恰好失效了，然后此时刚好有大量的并发请求，此时这些请求将会给数据库造成巨大的压力，这种情况就叫做缓存击穿。</p><p>缓存击穿的执行流程如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/C8mJyo3RLDAXdTM.png" alt="5.png"></p><p>它的解决方案有以下 2 个。</p><h2 id="加锁排队-1"><a href="#加锁排队-1" class="headerlink" title="加锁排队"></a><strong>加锁排队</strong></h2><p>此处理方式和缓存雪崩加锁排队的方法类似，都是在查询数据库时加锁排队，缓冲操作请求以此来减少服务器的运行压力。</p><h2 id="设置永不过期"><a href="#设置永不过期" class="headerlink" title="设置永不过期"></a><strong>设置永不过期</strong></h2><p>对于某些热点缓存，我们可以设置永不过期，这样就能保证缓存的稳定性，但需要注意在数据更改之后，要及时更新此热点缓存，不然就会造成查询结果的误差。</p><h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>首先来说，缓存预热并不是一个问题，而是使用缓存时的一个优化方案，它可以提高前台用户的使用体验。</p><p>缓存预热指的是在系统启动的时候，先把查询结果预存到缓存中，以便用户后面查询时可以直接从缓存中读取，以节约用户的等待时间。</p><p>缓存预热的执行流程，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/cKPwrp5qtWB6Lgx.png" alt="6.png"></p><p>缓存预热的实现思路有以下三种：</p><ol><li>把需要缓存的方法写在系统初始化的方法中，这样系统在启动的时候就会自动的加载数据并缓存数据；</li><li>把需要缓存的方法挂载到某个页面或后端接口上，手动触发缓存预热；</li><li>设置定时任务，定时自动进行缓存预热。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了缓存雪崩产生的原因是因为短时间内大量缓存同时失效，而导致大量请求直接查询数据库的情况，解决方案是加锁、随机设置过期时间和设置二级缓存等；还介绍了查询数据库无数据时会导致的每次空查询都不走缓存的缓存穿透问题，解决方案是使用布隆过滤器和缓存空结果等；同时还介绍了缓存在某一个高并发时刻突然失效导致的缓存击穿问题，以及解决方案——加锁、设置永不过期等方案，最后还介绍了优化系统性能的手段缓存预热。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从同步</title>
      <link href="posts/Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
      <url>posts/Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>主从同步（主从复制）是 Redis 高可用服务的基石，也是多机运行中最基础的一个。我们把主要存储数据的节点叫做主节点 (master），把其他通过复制主节点数据的副本节点叫做从节点 (slave），如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/PJNIuYQb3S7GBCt.png" alt="主从同步.png"></p><p>在 Redis 中一个主节点可以拥有多个从节点，一个从节点也可以是其他服务器的主节点，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/bIfMaL4PTVvt5dB.png" alt="主从同步-从从模式.png"></p><h1 id="主从同步的优点"><a href="#主从同步的优点" class="headerlink" title="主从同步的优点"></a>主从同步的优点</h1><p>主从同步具有以下三个优点：</p><ul><li>性能方面：有了主从同步之后，可以把查询任务分配给从服务器，用主服务器来执行写操作，这样极大的提高了程序运行的效率，把所有压力分摊到各个服务器了；</li><li>高可用：当有了主从同步之后，当主服务器节点宕机之后，可以很迅速的把从节点提升为主节点，为 Redis 服务器的宕机恢复节省了宝贵的时间；</li><li>防止数据丢失：当主服务器磁盘坏掉之后，其他从服务器还保留着相关的数据，不至于数据全部丢失。</li></ul><p>既然主从同步有这么多的优点，那接下来我们来看如何开启和使用主从同步功能。</p><h1 id="开启主从同步"><a href="#开启主从同步" class="headerlink" title="开启主从同步"></a>开启主从同步</h1><h2 id="运行中设置从服务器"><a href="#运行中设置从服务器" class="headerlink" title="运行中设置从服务器"></a><strong>运行中设置从服务器</strong></h2><p>在 Redis 运行过程中，我们可以使用 <code>replicaof host port</code> 命令，把自己设置为目标 IP 的从服务器，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; replicaof 127.0.0.1 6380</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>如果主服务设置了密码，需要在从服务器输入主服务器的密码，使用 <code>config set masterauth 主服务密码</code> 命令的方式，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6377&gt; config set masterauth pwd654321</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><strong>1. 执行流程</strong></p><p>在执行完 replicaof 命令之后，从服务器的数据会被清空，主服务会把它的数据副本同步给从服务器。</p><p><strong>2. 测试同步功能</strong></p><p>主从服务器设置完同步之后，我们来测试一下主从数据同步，首先我们先在主服务器上执行保存数据操作，再去从服务器查询。</p><p>主服务器执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set lang redis</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>从服务执行查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get lang</span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></figure><p>可以看出数据已经被正常同步过来了。</p><h2 id="启动时设置从服务器"><a href="#启动时设置从服务器" class="headerlink" title="启动时设置从服务器"></a><strong>启动时设置从服务器</strong></h2><p>我们可以使用命令 <code>redis-server --port 6380 --replicaof 127.0.0.1 6379</code> 将自己设置成目标服务器的从服务器。</p><h1 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h1><h2 id="完整数据同步"><a href="#完整数据同步" class="headerlink" title="完整数据同步"></a><strong>完整数据同步</strong></h2><p>当有新的从服务器连接时，为了保障多个数据库的一致性，主服务器会执行一次 bgsave 命令生成一个 RDB 文件，然后再以 Socket 的方式发送给从服务器，从服务器收到 RDB 文件之后再把所有的数据加载到自己的程序中，就完成了一次全量的数据同步。</p><h2 id="部分数据同步"><a href="#部分数据同步" class="headerlink" title="部分数据同步"></a><strong>部分数据同步</strong></h2><p>在 Redis 2.8 之前每次从服务器离线再重新上线之前，主服务器会进行一次完整的数据同步，然后这种情况如果发生在离线时间比较短的情况下，只有少量的数据不同步却要同步所有的数据是非常笨拙和不划算的，在 Redis 2.8 这个功能得到了优化。</p><p>Redis 2.8 的优化方法是当从服务离线之后，主服务器会把离线之后的写入命令，存储在一个特定大小的队列中，队列是可以保证先进先出的执行顺序的，当从服务器重写恢复上线之后，主服务会判断离线这段时间内的命令是否还在队列中，如果在就直接把队列中的数据发送给从服务器，这样就避免了完整同步的资源浪费。</p><blockquote><p>小贴士：存储离线命令的队列大小默认是 1MB，使用者可以自行修改队列大小的配置项 repl-backlog-size。</p></blockquote><h2 id="无盘数据同步"><a href="#无盘数据同步" class="headerlink" title="无盘数据同步"></a><strong>无盘数据同步</strong></h2><p>从前面的内容我们可以得知，在第一次主从连接的时候，会先产生一个 RDB 文件，再把 RDB 文件发送给从服务器，如果主服务器是非固态硬盘的时候，系统的 I/O 操作是非常高的，为了缓解这个问题，Redis 2.8.18 新增了无盘复制功能，无盘复制功能不会在本地创建 RDB 文件，而是会派生出一个子进程，然后由子进程通过 Socket 的方式，直接将 RDB 文件写入到从服务器，这样主服务器就可以在不创建RDB文件的情况下，完成与从服务器的数据同步。</p><p>要使用无须复制功能，只需把配置项 repl-diskless-sync 的值设置为 yes 即可，它默认配置值为 no。</p><h1 id="查询服务器的角色"><a href="#查询服务器的角色" class="headerlink" title="查询服务器的角色"></a>查询服务器的角色</h1><p>我们使用 role 命令，来查询当前服务器的主从角色信息。</p><h2 id="主服务查看"><a href="#主服务查看" class="headerlink" title="主服务查看"></a><strong>主服务查看</strong></h2><p>在主服务器上执行 role 结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; role</span><br><span class="line">1) &quot;master&quot;</span><br><span class="line">2) (integer) 546</span><br><span class="line">3) 1) 1) &quot;172.17.0.1&quot;</span><br><span class="line">      2) &quot;6379&quot;</span><br><span class="line">      3) &quot;546&quot;</span><br></pre></td></tr></table></figure><p>master 表示主服务器，底下是从服务器的 IP、端口和连接时间。</p><h2 id="从服务器查看"><a href="#从服务器查看" class="headerlink" title="从服务器查看"></a><strong>从服务器查看</strong></h2><p>在从服务器执行 role 命令，执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; role</span><br><span class="line">1) &quot;slave&quot;</span><br><span class="line">2) &quot;192.168.1.71&quot;</span><br><span class="line">3) (integer) 6380</span><br><span class="line">4) &quot;connected&quot;</span><br><span class="line">5) (integer) 14</span><br></pre></td></tr></table></figure><p>slave 表示从服务器，底下主服务器的 IP、端口和连接时间。</p><h1 id="关闭主从同步"><a href="#关闭主从同步" class="headerlink" title="关闭主从同步"></a>关闭主从同步</h1><p>我们可以使用 <code>replicaof no one</code> 命令来停止从服务器的复制，操作命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; role #查询当前角色</span><br><span class="line">1) &quot;slave&quot; #从服务器</span><br><span class="line">2) &quot;192.168.1.71&quot;</span><br><span class="line">3) (integer) 6380</span><br><span class="line">4) &quot;connected&quot;</span><br><span class="line">5) (integer) 14</span><br><span class="line">127.0.0.1:6379&gt; replicaof no one #关闭同步</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; role #查询当前角色</span><br><span class="line">1) &quot;master&quot; #主服务器</span><br><span class="line">2) (integer) 1097</span><br><span class="line">3) (empty list or set)</span><br></pre></td></tr></table></figure><p>可以看出执行了 <code>replicaof no one</code> 命令之后，自己就从服务器变成主服务器了。</p><blockquote><p>小贴士：服务器类型的转换并不会影响数据，这台服务器的数据将会被保留。</p></blockquote><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>主从同步有一些需要注意的点，我们来看一下。</p><h2 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a><strong>数据一致性问题</strong></h2><p>当从服务器已经完成和主服务的数据同步之后，再新增的命令会以异步的方式发送至从服务器，在这个过程中主从同步会有短暂的数据不一致，如在这个异步同步发生之前主服务器宕机了，会造成数据不一致。</p><h2 id="从服务器只读性"><a href="#从服务器只读性" class="headerlink" title="从服务器只读性"></a><strong>从服务器只读性</strong></h2><p>默认在情况下，处于复制模式的主服务器既可以执行写操作也可以执行读操作，而从服务器则只能执行读操作。</p><p>可以在从服务器上执行 <code>config set replica-read-only no</code> 命令，使从服务器开启写模式，但需要注意以下几点：</p><ul><li>在从服务器上写的数据不会同步到主服务器；</li><li>当键值相同时主服务器上的数据可以覆盖从服务器；</li><li>在进行完整数据同步时，从服务器数据会被清空。</li></ul><h2 id="复制命令的变化"><a href="#复制命令的变化" class="headerlink" title="复制命令的变化"></a><strong>复制命令的变化</strong></h2><p>Redis 5.0 之前使用的复制命令是 slaveof，在 Redis 5.0 之后复制命令才被改为 replicaof，在高版本（Redis 5+）中我们应该尽量使用 replicaof，因为 slaveof 命令可能会被随时废弃掉。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文我们了解了 Redis 多机运行的基础功能主从同步，主从同步可以通过 <code>replicaof host port</code> 命令开启，知道了同步的三种方式：完整数据同步（第一次全量 RDB 同步），部分数据同步（Redis 2.8 对于短时间离线的同步功能优化），无盘同步（非 RDB 生成的方式同步数据），我们也可以使用 <code>replicaof no one</code> 命令来停止从服务器的复制功能。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis哨兵模式</title>
      <link href="posts/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
      <url>posts/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>主从复制模式，它是属于 Redis 多机运行的基础，但这种模式本身存在一个致命的问题，当主节点奔溃之后，需要人工干预才能恢复 Redis 的正常使用。</p><p>例如，我们有 3 台服务器做了主从复制，一个主服务器 A 和两个从服务器 B、C，当 A 发生故障之后，需要人工把 B 服务器设置为主服务器，同时再去 C 服务器设置成从服务器并且从主服务器 B 同步数据，如果是发生在晚上或者从服务器节点很多的情况下，对于人工来说想要立即实现恢复的难度很多，所以我们需要一个自动的工具——Redis Sentinel（哨兵模式）来把手动的过程变成自动的，让 Redis 拥有自动容灾恢复（failover）的能力。</p><p>哨兵模式如下所示：</p><p><img src="https://s2.loli.net/2021/12/14/PQnbiIoKjm3dwgl.png" alt="哨兵模式.png"></p><blockquote><p>小贴士：Redis Sentinel 的最小分配单位是一主一从。</p></blockquote><h1 id="Redis-Sentinel-搭建"><a href="#Redis-Sentinel-搭建" class="headerlink" title="Redis Sentinel 搭建"></a>Redis Sentinel 搭建</h1><p>Redis 官方提供了 Redis Sentinel 的功能，它的运行程序保存在 src 目录下，如图所示：</p><p><img src="https://s2.loli.net/2021/12/14/WQhNEynwb1RUClv.png" alt="image.png"></p><p>我们需要使用命令 <code>./src/redis-sentinel sentinel.conf</code> 来启动 Sentinel，可以看出我们在启动它时必须设置一个 sentinel.conf 文件，这个配置文件中必须包含监听的主节点信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor master-name ip port quorum</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>master-name 表示给监视的主节点起一个名称；</li><li>ip 表示主节点的 IP；</li><li>port 表示主节点的端口；</li><li>quorum 表示确认主节点下线的 Sentinel 数量，如果 quorum 设置为 1 表示只要有一台 Sentinel 判断它下线了，就可以确认它真的下线了。</li></ul><p>注意：如果主节点 Redis 服务器有密码，还必须在 sentinel.conf 中添加主节点的密码，不然会导致 Sentinel 不能自动监听到主节点下面的从节点。</p><p>所以如果 Redis 有密码，sentinel.conf 必须包含以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line">sentinel auth-pass mymaster pwd654321</span><br></pre></td></tr></table></figure><p>当我们配置好 sentinel.conf 并执行启动命令 <code>./src/redis-sentinel sentinel.conf</code> 之后，Redis Sentinel 就会被启动，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/otjm7MZLJu94USV.png" alt="3.png"></p><p>从上图可以看出 Sentinel 只需配置监听主节点的信息，它会自动监听对应的从节点。</p><h1 id="启动-Sentinel-集群"><a href="#启动-Sentinel-集群" class="headerlink" title="启动 Sentinel 集群"></a>启动 Sentinel 集群</h1><p>上面我们演示了单个 Sentinel 的启动，但生产环境我们不会只启动一台 Sentinel，因为如果启动一台 Sentinel 假如它不幸宕机的话，就不能提供自动容灾的服务了，不符合我们高可用的宗旨，所以我们会在不同的物理机上启动多个 Sentinel 来组成 Sentinel 集群，来保证 Redis 服务的高可用。</p><p>启动 Sentinel 集群的方法很简单，和上面启动单台的方式一样，我们只需要把多个 Sentinel 监听到一个主服务器节点，那么多个 Sentinel 就会自动发现彼此，并组成一个 Sentinel 集群。</p><p>我们启动第二个 Sentinel 来试一下，执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[@iZ2ze0nc5n41zomzyqtksmZ:redis2]$ ./src/redis-sentinel sentinel.conf</span><br><span class="line">5547:X 19 Feb 2020 20:29:30.047 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">5547:X 19 Feb 2020 20:29:30.047 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=5547, just started</span><br><span class="line">5547:X 19 Feb 2020 20:29:30.047 # Configuration loaded</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &#x27;&#x27;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 5.0.5 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._                                   </span><br><span class="line"> (    &#x27;      ,       .-`  | `,    )     Running in sentinel mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 26377</span><br><span class="line"> |    `-._   `._    /     _.-&#x27;    |     PID: 5547</span><br><span class="line">  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line">      `-._    `-.__.-&#x27;    _.-&#x27;                                       </span><br><span class="line">          `-._        _.-&#x27;                                           </span><br><span class="line">              `-.__.-&#x27;                                               </span><br><span class="line"></span><br><span class="line">5547:X 19 Feb 2020 20:29:30.049 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">5547:X 19 Feb 2020 20:29:30.049 # Sentinel ID is 6455f2f74614a71ce0a63398b2e48d6cd1cf0d06</span><br><span class="line">5547:X 19 Feb 2020 20:29:30.049 # +monitor master mymaster 127.0.0.1 6379 quorum 1</span><br><span class="line">5547:X 19 Feb 2020 20:29:30.049 * +slave slave 127.0.0.1:6377 127.0.0.1 6377 @ mymaster 127.0.0.1 6379</span><br><span class="line">5547:X 19 Feb 2020 20:29:30.052 * +slave slave 127.0.0.1:6378 127.0.0.1 6378 @ mymaster 127.0.0.1 6379</span><br><span class="line">5547:X 19 Feb 2020 20:29:30.345 * +sentinel sentinel 6455f2f74614a71ce0a63398b2e48d6cd1cf0d08 127.0.0.1 26379 @ mymaster 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>从以上启动命令可以看出，比单机模式多了最后一行发现其他 Sentinel 服务器的命令，说明这两个 Sentinel 已经组成一个集群了。</p><p>Sentinel 集群示意图如下：</p><p><img src="https://s2.loli.net/2021/12/14/YeOVNwt14UCMkT5.png" alt="哨兵模式-多哨兵.png"></p><p>一般情况下 Sentinel 集群的数量取大于 1 的奇数，例如 3、5、7、9，而 quorum 的配置要根据 Sentinel 的数量来发生变化，例如 Sentinel 是 3 台，那么对应的 quorum 最好是 2，如果 Sentinel 是 5 台，那么 quorum 最好是 3，它表示当有 3 台 Sentinel 都确认主节点下线了，就可以确定主节点真的下线了。</p><p>与 quorum 参数相关的有两个概念：主观下线和客观下线。</p><p>当 Sentinel 集群中，有一个 Sentinel 认为主服务器已经下线时，它会将这个主服务器标记为主观下线（Subjectively Down，SDOWN），然后询问集群中的其他 Sentinel，是否也认为该服务器已下线，当同意主服务器已下线的 Sentinel 数量达到 quorum 参数所指定的数量时，Sentinel 就会将相应的主服务器标记为客观下线（Objectively down，ODOWN），然后开始对其进行故障转移。</p><h1 id="自动容灾测试"><a href="#自动容灾测试" class="headerlink" title="自动容灾测试"></a>自动容灾测试</h1><p>前面我们已经搭建了 Redis Sentinel，接下来我们就尝试一下自动容灾的功能，为了模拟故障我们先把主节点手动 kill 掉，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[@iZ2ze0nc5n41zomzyqtksmZ:~]$ ps -ef|grep redis #找到主节点的进程id</span><br><span class="line">root      5186     1  0 16:54 ?        00:00:23 ./src/redis-server *:6377</span><br><span class="line">root      5200     1  0 16:56 ?        00:00:22 ./src/redis-server *:6378</span><br><span class="line">root      5304  5287  0 17:31 pts/2    00:00:00 redis-cli -a pwd654321</span><br><span class="line">root      5395  5255  0 18:26 pts/1    00:00:19 ./src/redis-sentinel *:26379 [sentinel]</span><br><span class="line">root      5547  5478  0 20:29 pts/4    00:00:02 ./src/redis-sentinel *:26377 [sentinel]</span><br><span class="line">root      5551  5517  0 20:29 pts/5    00:00:00 redis-cli -h 127.0.0.1 -p 26377 -a pwd654321</span><br><span class="line">root      5568  5371  0 20:48 pts/0    00:00:00 grep --color=auto redis</span><br><span class="line">root     28517     1  0 Feb13 ?        00:15:33 ./src/redis-server *:6379</span><br><span class="line">[@iZ2ze0nc5n41zomzyqtksmZ:~]$ kill -9 28517 #关闭主节点服务</span><br></pre></td></tr></table></figure><p>这个时候我们在连接上另一台 Redis 服务器，查看当前主从服务器信息，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[@iZ2ze0nc5n41zomzyqtksmZ:~]$ redis-cli -h 127.0.0.1 -p 6377 -a pwd654321 2&gt;/dev/null</span><br><span class="line">127.0.0.1:6377&gt; role</span><br><span class="line">1) &quot;master&quot;</span><br><span class="line">2) (integer) 770389</span><br><span class="line">3) 1) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) &quot;6378&quot;</span><br><span class="line">      3) &quot;770389&quot;</span><br></pre></td></tr></table></figure><p>可以看出之前的从服务 6377 被提升为主服务器了，还剩下一台从服务 6378，而之前的主服务器 6379 被我们手动下线了，可以看出 Sentinel 已经完美的完成的它的故障自动转移的任务。</p><h1 id="主服务竞选规则"><a href="#主服务竞选规则" class="headerlink" title="主服务竞选规则"></a>主服务竞选规则</h1><p>上面我们模拟了 Redis Sentinel 自动容灾恢复，那接下来我们来看一下，主服务器竞选的规则和相关设置项。</p><h2 id="新主节点竞选优先级设置"><a href="#新主节点竞选优先级设置" class="headerlink" title="新主节点竞选优先级设置"></a><strong>新主节点竞选优先级设置</strong></h2><p>我们可以 redis.conf 中的 replica-priority 选项来设置竞选新主节点的优先级，它的默认值是 100，它的最大值也是 100，这个值越小它的权重就越高，例如从节点 A 的 replica-priority 值为 100，从节点 B 的值为 50，从节点 C 的值为 5，那么在竞选时从节点 C 会作为新的主节点。</p><h2 id="新主节点竞选规则"><a href="#新主节点竞选规则" class="headerlink" title="新主节点竞选规则"></a><strong>新主节点竞选规则</strong></h2><p>新主节点的竞选会排除不符合条件的从节点，然后再剩余的从节点按照优先级来挑选。首先来说，存在以下条件的从节点会被排除：</p><ol><li>排除所有已经下线以及长时间没有回复心跳检测的疑似已下线从服务器；</li><li>排除所有长时间没有与主服务器通信，数据状态过时的从服务器；</li><li>排除所有优先级（replica-priority）为 0 的服务器。</li></ol><p>符合条件的从节点竞选顺序：</p><ol><li>优先级最高的从节点将会作为新主节点；</li><li>优先级相等则判断复制偏移量，偏移量最大的从节点获胜；</li><li>如果以上两个条件都相同，选择 Redis 运行时随机生成 ID 最小那个为新的主服务器。</li></ol><h2 id="旧主节点恢复上线"><a href="#旧主节点恢复上线" class="headerlink" title="旧主节点恢复上线"></a><strong>旧主节点恢复上线</strong></h2><p>如果之前的旧主节点恢复上线，会作为从节点运行在主从服务器模式中。</p><h1 id="哨兵工作原理"><a href="#哨兵工作原理" class="headerlink" title="哨兵工作原理"></a>哨兵工作原理</h1><p>哨兵的工作原理是这样的，首先每个 Sentinel 会以每秒钟 1 次的频率，向已知的主服务器、从服务器和以及其他 Sentinel 实例，发送一个 PING 命令。</p><p>如果最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 所配置的值（默认 30s），那么这个实例会被 Sentinel 标记为主观下线。</p><p>如果一个主服务器被标记为主观下线，那么正在监视这个主服务器的所有 Sentinel 节点，要以每秒 1 次的频率确认 主服务器的确进入了主观下线状态。</p><p>如果有足够数量（quorum 配置值）的 Sentinel 在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。此时所有的 Sentinel 会按照规则协商自动选出新的主节点。</p><blockquote><p>注意：一个有效的 PING 回复可以是：+PONG、-LOADING 或者 -MASTERDOWN。如果返回值非以上三种回复，或者在指定时间内没有回复 PING 命令， 那么 Sentinel 认为服务器返回的回复无效（non-valid)。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文我们讲了主从模式的步骤，需要手动切换故障服务器的弊端，引出了 Sentinel 模式，可以实现监控和自动容灾，我们通过 Redis 提供的 Redis-Sentinel 来启动哨兵模式，当我们启动多个哨兵模式监视同一个主节点时，它们就会彼此发现形成一个新的高可用的 Sentinel 网络。同时我们讲了 Sentinel 的工作原理是通过 PING 命令来检查节点是否存活的，并通过配置项和复制偏移量 ID 来确定新主节点。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群模式</title>
      <link href="posts/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>posts/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Redis Cluster 是 Redis 3.0 版本推出的 Redis 集群方案，它将数据分布在不同的服务区上，以此来降低系统对单主节点的依赖，并且可以大大的提高 Redis 服务的读写性能。</p><p>Redis 将所有的数据分为 16384 个 slots（槽），每个节点负责其中的一部分槽位，当有 Redis 客户端连接集群时，会得到一份集群的槽位配置信息，这样它就可以直接把请求命令发送给对应的节点进行处理。</p><p>Redis Cluster 是无代理模式去中心化的运行模式，客户端发送的绝大数命令会直接交给相关节点执行，这样大部分情况请求命令无需转发，或仅转发一次的情况下就能完成请求与响应，所以集群单个节点的性能与单机 Redis 服务器的性能是非常接近的，因此在理论情况下，当水平扩展一倍的主节点就相当于请求处理的性能也提高了一倍，所以 Redis Cluster 的性能是非常高的。</p><p>Redis Cluster 架构图如下所示：</p><p><img src="https://s2.loli.net/2021/12/14/WyctFV8RAj7J1Tm.png" alt="1.png"></p><h1 id="搭建-Redis-Cluster"><a href="#搭建-Redis-Cluster" class="headerlink" title="搭建 Redis Cluster"></a>搭建 Redis Cluster</h1><p>Redis Cluster 的搭建方式有两种，一种是使用 Redis 源码中提供的 create-cluster 工具快速的搭建 Redis 集群环境，另一种是配置文件的方式手动创建 Redis 集群环境。</p><h2 id="快速搭建-Redis-Cluster"><a href="#快速搭建-Redis-Cluster" class="headerlink" title="快速搭建 Redis Cluster"></a><strong>快速搭建 Redis Cluster</strong></h2><p>create-cluster 工具在 utils/create-cluster 目录下，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/OsN9qHtJiSyhR8j.png" alt="2.png"></p><p>使用命令 <code>./create-cluster start</code> 就可以急速创建一个 Redis 集群，执行如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./create-cluster start <span class="comment"># 创建集群</span></span></span><br><span class="line">Starting 30001</span><br><span class="line">Starting 30002</span><br><span class="line">Starting 30003</span><br><span class="line">Starting 30004</span><br><span class="line">Starting 30005</span><br><span class="line">Starting 30006</span><br></pre></td></tr></table></figure><p>接下来我们需要把以上创建的 6 个节点通过 create 命令组成一个集群，执行如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[@iZ2ze0nc5n41zomzyqtksmZ:create-cluster]$ ./create-cluster create # 组建集群</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 127.0.0.1:30005 to 127.0.0.1:30001</span><br><span class="line">Adding replica 127.0.0.1:30006 to 127.0.0.1:30002</span><br><span class="line">Adding replica 127.0.0.1:30004 to 127.0.0.1:30003</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span></span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: 445f2a86fe36d397613839d8cc1ae6702c976593 127.0.0.1:30001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 63bb14023c0bf58926738cbf857ea304bff8eb50 127.0.0.1:30002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc 127.0.0.1:30003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 64828ab44566fc5ad656e831fd33de87be1387a0 127.0.0.1:30004</span><br><span class="line">   replicates 445f2a86fe36d397613839d8cc1ae6702c976593</span><br><span class="line">S: 0b17b00542706343583aa73149ec5ff63419f140 127.0.0.1:30005</span><br><span class="line">   replicates 63bb14023c0bf58926738cbf857ea304bff8eb50</span><br><span class="line">S: e35f06ca9b700073472d72001a39ea4dfcb541cd 127.0.0.1:30006</span><br><span class="line">   replicates 864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:30001)</span></span><br><span class="line">M: 445f2a86fe36d397613839d8cc1ae6702c976593 127.0.0.1:30001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc 127.0.0.1:30003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e35f06ca9b700073472d72001a39ea4dfcb541cd 127.0.0.1:30006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc</span><br><span class="line">S: 0b17b00542706343583aa73149ec5ff63419f140 127.0.0.1:30005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 63bb14023c0bf58926738cbf857ea304bff8eb50</span><br><span class="line">M: 63bb14023c0bf58926738cbf857ea304bff8eb50 127.0.0.1:30002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 64828ab44566fc5ad656e831fd33de87be1387a0 127.0.0.1:30004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 445f2a86fe36d397613839d8cc1ae6702c976593</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>在执行的过程中会询问你是否通过把 30001、30002、30003 作为主节点，把 30004、30005、30006 作为它们的从节点，输入 <code>yes</code> 后会执行完成。</p><p>我们可以先使用 redis-cli 连接到集群，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -c -p 30001</span></span><br></pre></td></tr></table></figure><p>在使用 nodes 命令来查看集群的节点信息，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:30001&gt; cluster nodes</span><br><span class="line">864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc 127.0.0.1:30003@40003 master - 0 1585125835078 3 connected 10923-16383</span><br><span class="line">e35f06ca9b700073472d72001a39ea4dfcb541cd 127.0.0.1:30006@40006 slave 864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc 0 1585125835078 6 connected</span><br><span class="line">0b17b00542706343583aa73149ec5ff63419f140 127.0.0.1:30005@40005 slave 63bb14023c0bf58926738cbf857ea304bff8eb50 0 1585125835078 5 connected</span><br><span class="line">63bb14023c0bf58926738cbf857ea304bff8eb50 127.0.0.1:30002@40002 master - 0 1585125834175 2 connected 5461-10922</span><br><span class="line">445f2a86fe36d397613839d8cc1ae6702c976593 127.0.0.1:30001@40001 myself,master - 0 1585125835000 1 connected 0-5460</span><br><span class="line">64828ab44566fc5ad656e831fd33de87be1387a0 127.0.0.1:30004@40004 slave 445f2a86fe36d397613839d8cc1ae6702c976593 0 1585125835000 4 connected</span><br></pre></td></tr></table></figure><p>可以看出 30001、30002、30003 都为主节点，30001 对应的槽位是 0<del>5460，30002 对应的槽位是 5461</del>10922，30003 对应的槽位是 10923<del>16383，总共有槽位 16384 个（0</del>16383）。</p><p>create-cluster 搭建的方式虽然速度很快，但是该方式搭建的集群主从节点数量固定以及槽位分配模式固定，并且安装在同一台服务器上，所以只能用于测试环境。</p><p>我们测试完成之后，可以<strong>使用以下命令，关闭并清理集群</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./create-cluster stop <span class="comment"># 关闭集群</span></span></span><br><span class="line">Stopping 30001</span><br><span class="line">Stopping 30002</span><br><span class="line">Stopping 30003</span><br><span class="line">Stopping 30004</span><br><span class="line">Stopping 30005</span><br><span class="line">Stopping 30006</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./create-cluster clean <span class="comment"># 清理集群</span></span></span><br></pre></td></tr></table></figure><h2 id="手动搭建-Redis-Cluster"><a href="#手动搭建-Redis-Cluster" class="headerlink" title="手动搭建 Redis Cluster"></a><strong>手动搭建 Redis Cluster</strong></h2><p>由于 create-cluster 本身的限制，在实际生产环境中我们需要使用手动添加配置的方式搭建 Redis 集群，为此我们先要把 Redis 安装包复制到 node1 到 node6 文件中，因为我们要安装 6 个节点，3 主 3 从，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/VrMS3qYoKy5Uzl1.png" alt="3.png"></p><p><img src="https://s2.loli.net/2021/12/14/NdKM7VyTYcZevJC.png" alt="4.png"></p><p>接下来我们进行配置并启动 Redis 集群。</p><p><strong>1. 设置配置文件</strong></p><p>我们需要修改每个节点内的 redis.conf 文件，设置 <code>cluster-enabled yes</code> 表示开启集群模式，并且修改各自的端口，我们继续使用 30001 到 30006，通过 <code>port 3000X</code> 设置。</p><p><strong>2. 启动各个节点</strong></p><p>redis.conf 配置好之后，我们就可以启动所有的节点了，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/soft/mycluster/node1 </span><br><span class="line">./src/redis-server redis.conf</span><br></pre></td></tr></table></figure><p><strong>3. 创建集群并分配槽位</strong></p><p>之前我们已经启动了 6 个节点，但这些节点都在各自的集群之内并未互联互通，因此接下来我们需要把这些节点串连成一个集群，并为它们指定对应的槽位，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 127.0.0.1:30001 127.0.0.1:30002 127.0.0.1:30003 127.0.0.1:30004 127.0.0.1:30005 127.0.0.1:30006 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p>其中 create 后面跟多个节点，表示把这些节点作为整个集群的节点，而 cluster-replicas 表示给集群中的主节点指定从节点的数量，1 表示为每个主节点设置一个从节点。</p><p>在执行了 create 命令之后，系统会为我们指定节点的角色和槽位分配计划，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 127.0.0.1:30005 to 127.0.0.1:30001</span><br><span class="line">Adding replica 127.0.0.1:30006 to 127.0.0.1:30002</span><br><span class="line">Adding replica 127.0.0.1:30004 to 127.0.0.1:30003</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span></span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: bdd1c913f87eacbdfeabc71befd0d06c913c891c 127.0.0.1:30001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: bdd1c913f87eacbdfeabc71befd0d06c913c891c 127.0.0.1:30002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: bdd1c913f87eacbdfeabc71befd0d06c913c891c 127.0.0.1:30003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: bdd1c913f87eacbdfeabc71befd0d06c913c891c 127.0.0.1:30004</span><br><span class="line">   replicates bdd1c913f87eacbdfeabc71befd0d06c913c891c</span><br><span class="line">S: bdd1c913f87eacbdfeabc71befd0d06c913c891c 127.0.0.1:30005</span><br><span class="line">   replicates bdd1c913f87eacbdfeabc71befd0d06c913c891c</span><br><span class="line">S: bdd1c913f87eacbdfeabc71befd0d06c913c891c 127.0.0.1:30006</span><br><span class="line">   replicates bdd1c913f87eacbdfeabc71befd0d06c913c891c</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): </span><br></pre></td></tr></table></figure><p>从以上信息可以看出，Redis 打算把 30001、30002、30003 设置为主节点，并为他们分配的槽位，30001 对应的槽位是 0<del>5460，30002 对应的槽位是 5461</del>10922，30003 对应的槽位是 10923~16383，并且把 30005 设置为 30001 的从节点、30006 设置为 30002 的从节点、30004 设置为 30003 的从节点，我们只需要输入 <code>yes</code> 即可确认并执行分配，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">....</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:30001)</span></span><br><span class="line">M: 887397e6fefe8ad19ea7569e99f5eb8a803e3785 127.0.0.1:30001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: abec9f98f9c01208ba77346959bc35e8e274b6a3 127.0.0.1:30005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 887397e6fefe8ad19ea7569e99f5eb8a803e3785</span><br><span class="line">S: 1a324d828430f61be6eaca7eb2a90728dd5049de 127.0.0.1:30004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates f5958382af41d4e1f5b0217c1413fe19f390b55f</span><br><span class="line">S: dc0702625743c48c75ea935c87813c4060547cef 127.0.0.1:30006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 3da35c40c43b457a113b539259f17e7ed616d13d</span><br><span class="line">M: 3da35c40c43b457a113b539259f17e7ed616d13d 127.0.0.1:30002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: f5958382af41d4e1f5b0217c1413fe19f390b55f 127.0.0.1:30003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>显示 OK 表示整个集群就已经成功启动了。</p><p>接下来，我们使用 redis-cli 连接并测试一下集群的运行状态，代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -c -p 30001 <span class="comment"># 连接到集群</span></span></span><br><span class="line">127.0.0.1:30001&gt; cluster info # 查看集群信息</span><br><span class="line">cluster_state:ok # 状态正常</span><br><span class="line">cluster_slots_assigned:16384 # 槽位数</span><br><span class="line">cluster_slots_ok:16384 # 正常的槽位数</span><br><span class="line">cluster_slots_pfail:0 </span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6 # 集群的节点数</span><br><span class="line">cluster_size:3 # 集群主节点数</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:130</span><br><span class="line">cluster_stats_messages_pong_sent:127</span><br><span class="line">cluster_stats_messages_sent:257</span><br><span class="line">cluster_stats_messages_ping_received:122</span><br><span class="line">cluster_stats_messages_pong_received:130</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:257</span><br></pre></td></tr></table></figure><p>相关字段的说明已经标识在上述的代码中了，这里就不再赘述。</p><h1 id="动态增删节点"><a href="#动态增删节点" class="headerlink" title="动态增删节点"></a>动态增删节点</h1><p>某些情况下，我们需要根据实际的业务情况，对已经在运行的集群进行动态的添加或删除节点，那我们就需要进行以下操作。</p><h2 id="增加主节点"><a href="#增加主节点" class="headerlink" title="增加主节点"></a><strong>增加主节点</strong></h2><p><strong>添加方式一：cluster meet</strong></p><p>使用 <code>cluster meet ip:port</code> 命令就可以把一个节点加入到集群中，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:30001&gt; cluster meet 127.0.0.1 30007</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:30001&gt; cluster nodes</span><br><span class="line">dc0702625743c48c75ea935c87813c4060547cef 127.0.0.1:30006@40006 slave 3da35c40c43b457a113b539259f17e7ed616d13d 0 1585142916000 6 connected</span><br><span class="line">df0190853a53d8e078205d0e2fa56046f20362a7 127.0.0.1:30007@40007 master - 0 1585142917740 0 connected</span><br><span class="line">f5958382af41d4e1f5b0217c1413fe19f390b55f 127.0.0.1:30003@40003 master - 0 1585142916738 3 connected 10923-16383</span><br><span class="line">3da35c40c43b457a113b539259f17e7ed616d13d 127.0.0.1:30002@40002 master - 0 1585142913000 2 connected 5461-10922</span><br><span class="line">abec9f98f9c01208ba77346959bc35e8e274b6a3 127.0.0.1:30005@40005 slave 887397e6fefe8ad19ea7569e99f5eb8a803e3785 0 1585142917000 5 connected</span><br><span class="line">887397e6fefe8ad19ea7569e99f5eb8a803e3785 127.0.0.1:30001@40001 myself,master - 0 1585142915000 1 connected 0-5460</span><br><span class="line">1a324d828430f61be6eaca7eb2a90728dd5049de 127.0.0.1:30004@40004 slave f5958382af41d4e1f5b0217c1413fe19f390b55f 0 1585142916000 4 connected</span><br></pre></td></tr></table></figure><p>可以看出端口为 30007 的节点并加入到集群中，并设置成了主节点。</p><p><strong>添加方式二：add-node</strong></p><p>使用 <code>redis-cli --cluster add-node 添加节点ip:port 集群某节点ip:port</code> 也可以把一个节点添加到集群中，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli --cluster add-node 127.0.0.1:30008 127.0.0.1:30001</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Adding node 127.0.0.1:30008 to cluster 127.0.0.1:30001</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:30001)</span></span><br><span class="line">M: 887397e6fefe8ad19ea7569e99f5eb8a803e3785 127.0.0.1:30001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: dc0702625743c48c75ea935c87813c4060547cef 127.0.0.1:30006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 3da35c40c43b457a113b539259f17e7ed616d13d</span><br><span class="line">M: df0190853a53d8e078205d0e2fa56046f20362a7 127.0.0.1:30007</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">M: f5958382af41d4e1f5b0217c1413fe19f390b55f 127.0.0.1:30003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 1d09d26fd755298709efe60278457eaa09cefc26 127.0.0.1:30008</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">M: 3da35c40c43b457a113b539259f17e7ed616d13d 127.0.0.1:30002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: abec9f98f9c01208ba77346959bc35e8e274b6a3 127.0.0.1:30005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 887397e6fefe8ad19ea7569e99f5eb8a803e3785</span><br><span class="line">S: 1a324d828430f61be6eaca7eb2a90728dd5049de 127.0.0.1:30004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates f5958382af41d4e1f5b0217c1413fe19f390b55f</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">[ERR] Node 127.0.0.1:30008 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.</span><br></pre></td></tr></table></figure><p>从以上结果可以看出 30008 节点也被设置成了主节点。</p><h2 id="添加从节点"><a href="#添加从节点" class="headerlink" title="添加从节点"></a><strong>添加从节点</strong></h2><p>使用 <code>cluster replicate nodeId</code> 命令就可以把当前节点设置为目标节点的从节点，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:30008&gt; cluster replicate df0190853a53d8e078205d0e2fa56046f20362a7</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:30008&gt; cluster nodes</span><br><span class="line">df0190853a53d8e078205d0e2fa56046f20362a7 127.0.0.1:30007@40007 master - 0 1585147827000 0 connected</span><br><span class="line">abec9f98f9c01208ba77346959bc35e8e274b6a3 127.0.0.1:30005@40005 slave 887397e6fefe8ad19ea7569e99f5eb8a803e3785 0 1585147827000 1 connected</span><br><span class="line">1a324d828430f61be6eaca7eb2a90728dd5049de 127.0.0.1:30004@40004 slave f5958382af41d4e1f5b0217c1413fe19f390b55f 0 1585147823000 3 connected</span><br><span class="line">887397e6fefe8ad19ea7569e99f5eb8a803e3785 127.0.0.1:30001@40001 master - 0 1585147826000 1 connected 0-5460</span><br><span class="line">dc0702625743c48c75ea935c87813c4060547cef 127.0.0.1:30006@40006 slave 3da35c40c43b457a113b539259f17e7ed616d13d 0 1585147826930 2 connected</span><br><span class="line">f5958382af41d4e1f5b0217c1413fe19f390b55f 127.0.0.1:30003@40003 master - 0 1585147826000 3 connected 10923-16383</span><br><span class="line">1d09d26fd755298709efe60278457eaa09cefc26 127.0.0.1:30008@40008 myself,slave df0190853a53d8e078205d0e2fa56046f20362a7 0 1585147823000 7 connected</span><br><span class="line">3da35c40c43b457a113b539259f17e7ed616d13d 127.0.0.1:30002@40002 master - 0 1585147827933 2 connected 5461-10922</span><br></pre></td></tr></table></figure><p>可以看出 30008 已经变为 30007 的从节点了。</p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a><strong>删除节点</strong></h2><p>使用 <code>cluster forget nodeId</code> 命令就可以把一个节点从集群中移除。</p><p>此命令和 meet 命令不同的时，删除节点需要把使用节点的 Id 进行删除，可以通过 <code>cluster nodes</code> 命令查看所有节点的 Id 信息，其中每一行的最前面的 40 位字母和数组的组合就是该节点的 Id，如下图所示：</p><p><img src="https://s2.loli.net/2021/12/14/GD2fygCYZIJx9sW.png" alt="5.png"></p><p>执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:30001&gt; cluster forget df0190853a53d8e078205d0e2fa56046f20362a7</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>此时我们使用 <code>cluster nodes</code> 命令查看集群的所有节点信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:30001&gt; cluster nodes</span><br><span class="line">dc0702625743c48c75ea935c87813c4060547cef 127.0.0.1:30006@40006 slave 3da35c40c43b457a113b539259f17e7ed616d13d 0 1585143789940 6 connected</span><br><span class="line">f5958382af41d4e1f5b0217c1413fe19f390b55f 127.0.0.1:30003@40003 master - 0 1585143791000 3 connected 10923-16383</span><br><span class="line">3da35c40c43b457a113b539259f17e7ed616d13d 127.0.0.1:30002@40002 master - 0 1585143789000 2 connected 5461-10922</span><br><span class="line">abec9f98f9c01208ba77346959bc35e8e274b6a3 127.0.0.1:30005@40005 slave 887397e6fefe8ad19ea7569e99f5eb8a803e3785 0 1585143789000 5 connected</span><br><span class="line">887397e6fefe8ad19ea7569e99f5eb8a803e3785 127.0.0.1:30001@40001 myself,master - 0 1585143786000 1 connected 0-5460</span><br><span class="line">1a324d828430f61be6eaca7eb2a90728dd5049de 127.0.0.1:30004@40004 slave f5958382af41d4e1f5b0217c1413fe19f390b55f 0 1585143791945 4 connected</span><br></pre></td></tr></table></figure><p>可以看出之前的端口为 30007 的节点已经被我们成功的移除了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文讲了 Redis 集群的两种搭建方式：create-cluster start 和 cluster create，前一种方式虽然速度比较快，但它只能创建数量固定的主从节点，并且所有节点都在同一台服务器上，因此只能用于测试环境。我们还讲了 Redis 集群动态添加主、从节点和删除任意节点的功能。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出索引</title>
      <link href="posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/"/>
      <url>posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>提到数据库索引，大家都不陌生。比如某一个SQL查询比较慢，分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引，索引又是如何工作的呢？</p><p>一句话简单来说，<strong>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样</strong>。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p><h1 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h1><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是<strong>哈希表、有序数组和搜索树</strong>。</p><p>下面主要从使用的角度，简单分析一下这三种模型的区别。</p><p>哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。</p><p>不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p><p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p><p><img src="https://s2.loli.net/2021/12/15/igONsabJLoe2wWX.png" alt="哈希表示意图"></p><p>图中，User2和User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设，这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函数算出N；然后，按顺序遍历，找到User2。</p><p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</p><p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。</p><p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如Memcached及其他一些NoSQL引擎。</p><p>而<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p><p><img src="https://s2.loli.net/2021/12/15/QrclqxYNebLjgFC.png" alt="有序数组示意图"></p><p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。</p><p>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。</p><p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p><p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p><p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p><p><img src="https://s2.loli.net/2021/12/15/c7kbgLHN2KoFIxq.png" alt="二叉搜索树示意图"></p><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个时间复杂度是O(log(N))。</p><p>当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。</p><p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。</p><p>以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><p>N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p><p>不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里就不再一一展开了。</p><p>心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p><p>截止到这里，我用了半篇文章的篇幅和你介绍了不同的数据结构，以及它们的适用场景，你可能会觉得有些枯燥。但是，我建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理数据的核心概念之一，在分析问题的时候会经常用到。当你理解了索引的模型后，就会发现在分析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。</p><p>现在，我们一起进入相对偏实战的内容吧。</p><p>在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于InnoDB存储引擎在MySQL数据库中使用最为广泛，所以下面我就以InnoDB为例，和你分析一下其中的索引模型。</p><h1 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h1><p><strong>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表</strong>。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</p><p><strong>每一个索引在InnoDB里面对应一棵B+树。</strong></p><p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。</p><p>这个表的建表语句是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。</p><p><img src="https://s2.loli.net/2021/12/15/iKg1FHNmqf8ypSD.png" alt="InnoDB的索引组织结构"></p><p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在InnoDB里，<strong>主键索引也被称为聚簇索引</strong>（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p><p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，<strong>基于非主键索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p><h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p><p>而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p><p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>基于上面的索引维护过程说明，我们来讨论一个案例：</p><blockquote><p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p></blockquote><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p><p>插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。</p><p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p><p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p><p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p><ol><li>只有一个索引；</li><li>该索引必须是唯一索引。</li></ol><p>你一定看出来了，这就是典型的KV场景。</p><p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p><p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p><p>在上一篇文章中，我和你介绍了InnoDB索引的数据结构模型，今天我们再继续聊聊跟MySQL索引有关的概念。</p><p>在开始这篇文章之前，我们先来看一下这个问题：</p><p>在下面这个表T中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？</p><p>下面是这个表的初始化语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">index k(k))</span><br><span class="line">engine&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;);</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="img"></p><p>图1 InnoDB的索引组织结构</p><p>现在，我们一起来看看这条SQL查询语句的执行流程：</p><ol><li>在k索引树上找到k=3的记录，取得 ID = 300；</li><li>再到ID索引树查到ID=300对应的R3；</li><li>在k索引树取下一个值k=5，取得ID=500；</li><li>再回到ID索引树查到ID=500对应的R4；</li><li>在k索引树取下一个值k=6，不满足条件，循环结束。</li></ol><p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。</p><p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</p><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><p>需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。</p><blockquote><p>备注：关于如何查看扫描行数的问题，我将会在第16文章《如何正确地显示随机消息？》中，和你详细讨论。</p></blockquote><p>基于上面覆盖索引的说明，我们来讨论一个问题：<strong>在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</strong></p><p>假设这个市民表的定义是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tuser&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;id_card&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;name&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;ismale&#96; tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;id_card&#96; (&#96;id_card&#96;),</span><br><span class="line">  KEY &#96;name_age&#96; (&#96;name&#96;,&#96;age&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure><p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p><p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p><p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务DBA，或者称为业务数据架构师的工作。</p><h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><p>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</p><p>这里，我先和你说结论吧。<strong>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p><p>为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。</p><p><img src="https://s2.loli.net/2021/12/15/e9jTA6JWUcCbO2y.jpg" alt="（name，age）索引示意图"></p><p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p><p>如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是”where name like ‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</p><p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><p>基于上面对最左前缀索引的说明，我们来讨论一个问题：<strong>在建立联合索引的时候，如何安排索引内的字段顺序。</strong></p><p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p><p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建(身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p><p>那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b) 这两个索引。</p><p>这时候，我们要<strong>考虑的原则就是空间</strong>了。比如上面这个市民表的情况，name字段是比age字段大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。</p><h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p><p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#39;张%&#39; and age&#x3D;10 and ismale&#x3D;1;</span><br></pre></td></tr></table></figure><p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。</p><p>然后呢？</p><p>当然是判断其他条件是否满足。</p><p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><p>图3和图4，是这两个过程的执行流程图。</p><p><img src="https://s2.loli.net/2021/12/15/TLKzkt6xUJya1Rc.jpg" alt="无索引下推执行流程"></p><p>图3 无索引下推执行流程</p><p><img src="https://s2.loli.net/2021/12/15/5mMb3HpnvTUk2gE.jpg" alt="索引下推执行流程"></p><p>图4 </p><p>在图3和4这两个图里面，每一个虚线箭头表示回表一次。</p><p>图3中，在(name,age)索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。</p><p>图4跟图3的区别是，InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我跟你分析了数据库引擎可用的数据结构，介绍了InnoDB采用的B+树结构，以及为什么InnoDB要这么选择。B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</p><p>由于InnoDB是索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的空间最小。但事无绝对，我也跟你讨论了使用业务逻辑字段做主键的应用场景。</p><p>今天这篇文章，我和你继续讨论了数据库索引的概念，包括了覆盖索引、前缀索引、索引下推。你可以看到，在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。我们在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务隔离</title>
      <link href="posts/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
      <url>posts/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。</p><p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。</p><p><strong>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败</strong>。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</p><p>本文将会以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给出相应的实践建议，加深对MySQL事务原理的理解。</p><h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>其中“读提交”和“可重复读”比较难理解，用一个例子说明这几种隔离级别。假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(c <span class="type">int</span>) engine<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/15/shaCWzoeHkBqRfc.png" alt="1.png"><br>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。</p><ul><li>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。</li><li>若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。</li><li>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</li></ul><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p><p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。</p><p>配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> READ<span class="operator">-</span>COMMITTED <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+----------------+</span></span><br></pre></td></tr></table></figure><p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想<strong>你可能会问那什么时候需要“可重复读”的场景呢</strong>？我们来看一个数据校对逻辑的案例。</p><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="https://s2.loli.net/2021/12/15/w9VTuzHpIgxjNof.png" alt="2.png"><br>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC)。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p><p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p><p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。</p><p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p><h1 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h1><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li><li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li></ol><p>有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p><p>因此，我会建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。</p><p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。</p><p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇文章里面，介绍了MySQL的事务隔离级别的现象和实现，根据实现原理分析了长事务存在的风险，以及如何用正确的方式避免长事务。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日志系统：一条SQL更新语句是如何执行的？</title>
      <link href="posts/MySQL%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
      <url>posts/MySQL%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一条更新语句的执行流程是怎样的呢？</p><p>之前你可能经常听 DBA 同事说，MySQL 可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？</p><p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(ID <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> update T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p><p><img src="https://s2.loli.net/2021/12/15/Vq8UuDXpnBQYfSC.png" alt="MySQL 的逻辑架构图"></p><p>执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）。如果接触 MySQL，那这两个词肯定是绕不过的。</p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是<strong>先写日志，再写磁盘</strong>，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p><img src="https://s2.loli.net/2021/12/15/pAbWwPKUGuo7jCt.jpg" alt="img"></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p>前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p><p>这两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p>这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p><p><img src="https://s2.loli.net/2021/12/15/xpDh57qeKTjOi2A.png" alt="update 语句执行流程"></p><p>你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。</p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p><p>前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li><li>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li></ul><p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p><p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><ol><li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li><li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p><p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p><p>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，介绍了 MySQL 里面最重要的两个日志，即物理日志 redo log 和逻辑日志 binlog。</p><p>redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p><p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数也建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p><p>还介绍了与 MySQL 日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使不做数据库内核开发，日常开发中也有可能会用到。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础架构：一条SQL查询语句是如何执行的？</title>
      <link href="posts/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
      <url>posts/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>平时我们使用数据库，看到的通常都是一个整体。比如，一个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure><p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。</p><p>下面给出的是 MySQL 的基本架构示意图，从中可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。</p><p><img src="https://s2.loli.net/2021/12/15/Vq8UuDXpnBQYfSC.png" alt="MySQL 的逻辑架构图"></p><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><p>也就是说，执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p><p>从图中不难看出，不同的存储引擎共用一个<strong>Server 层</strong>，也就是从连接器到执行器的部分。接下来结合开头提到的那条 SQL 语句，走一遍整个执行流程，依次看下每个组件的作用。</p><h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://s2.loli.net/2021/12/15/fEXrT7au9Aq3yDO.png" alt="img"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是<strong>尽量使用长连接</strong>。</p><p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li><strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p><strong>但是大多数情况下建议不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在 MySQL 也提供了这种“按需使用”的方式。可以将参数 <code>query_cache_type</code> 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure><p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p><h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> elect <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;elect * from t where ID=1&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h1><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">ERROR <span class="number">1142</span> (<span class="number">42000</span>): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">user</span> <span class="string">&#x27;b&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">&#x27;T&#x27;</span></span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟 rows_examined 并不是完全相同的。</strong></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>了解MySQL 的逻辑架构，对一个 SQL 语句完整执行流程的各个阶段有了一个初步的印象。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序的编译与优化</title>
      <link href="posts/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>posts/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>在Java技术下谈“编译期”而没有具体上下文语境的话，其实是一句很含糊的表述，因为它可能是指一个前端编译器把*.java文件转变成*.class文件的过程。也可能是指Java虚拟机的即时编译器运行期把字节码转变成本地机器码的过程。还可能是指使用静态的提前编译器直接把程序编译成与目标机器指令集相关的二进制代码的过程。下面列举了这3类编译过程里一些比较有代表性的编译器产品：</p><ol><li><strong>前端编译器：JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）；</strong></li><li><strong>即时编译器：HotSpot虚拟机的C1、C2编译器，Graal编译器；</strong></li><li><strong>提前编译器：JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET</strong>。限制了“编译期”的范围后，我们对于“优化”二字的定义也需要放宽一些，因为Javac这类前端编译器对代码的运行效率几乎没有任何优化措施可言，哪怕是编译器真的采取了优化措施也不会产生什么实质的效果。因为Java虚拟机设计团队选择把对性能的优化全部集中到运行期的即时编译器中，这样可以让那些不是由Javac产生的Class文件也同样能享受到编译器优化措施所带来的性能红利。</li></ol><h1 id="前端编译与优化"><a href="#前端编译与优化" class="headerlink" title="前端编译与优化"></a>前端编译与优化</h1><p>Java虚拟机规范中严格定义了Class文件格式的各种细节，可是对如何把Java源码编译为Class文件却描述得相当宽松。规范里尽管有专门的一章名为“Compiling for the Java Virtual Machine”，但这章也仅仅是以举例的形式来介绍怎样的Java代码应该被转换为怎样的字节码，并没有使用编译原理中常用的描述工具来对Java源码编译过程加以约束。这是给了Java前端编译器较大的实现灵活性，但也导致Class文件编译过程在某种程度上是与具体的JDK或编译器实现相关的，譬如在一些极端情况下，可能会出现某些代码在Javac编译器可以编译，但是ECJ编译器就不可以编译的问题。</p><p>从Javac代码的总体结构来看，编译过程大致可以分为<strong>1个准备过程和3个处理过程</strong>，它们分别如下所示：</p><ol><li>准备过程：初始化插入式注解处理器。</li><li>解析与填充符号表过程，包括：</li></ol><ul><li>词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。</li><li>填充符号表。产生符号地址和符号信息。</li></ul><ol start="3"><li>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段。</li><li>分析与字节码生成过程，包括：</li></ol><ul><li>标注检查。对语法的静态信息进行检查。</li><li>数据流及控制流分析。对程序动态运行过程进行检查。</li><li>解语法糖。将简化代码编写的语法糖还原为原有的形式。</li><li>字节码生成。将前面各个步骤所生成的信息转化成字节码。</li></ul><p>上述3个处理过程里，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号，从总体来看，三者之间的关系与交互顺序如下图所示。</p><p><img src="https://i.loli.net/2021/10/04/sogJEFIXMVGaBpe.png" alt="image-20211004104937506"></p><h1 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h1><p>如果我们把字节码看作是程序语言的一种中间表示形式的话，那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的后端。无论是提前编译器抑或即时编译器，都不是Java虚拟机必需的组成部分，Java虚拟机规范中从来没有规定过虚拟机内部必须要包含这些编译器，更没有限定或指导这些编译器应该如何去实现。但是，后端编译器编译性能的好坏、代码优化质量的高低却是衡量一款商用虚拟机优秀与否的关键指标之一，它们也是商业Java虚拟机中的核心，是最能体现技术水平与价值的功能。</p><h2 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h2><p>目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过解释器进行解释执行的，<strong>当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器（JIT，Just In Time）。</strong></p><p><strong>解释器与编译器</strong></p><p>目前主流的商用Java虚拟机，譬如HotSpot、OpenJ9等，内部都同时包含解释器与编译器。<strong>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。</strong></p><p>同时，<strong>解释器还可以作为编译器激进优化时后备的“逃生门”</strong>，让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”时可以通过逆优化退回到解释状态继续执行，因此在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作，其交互关系如下图所示。</p><p><img src="https://i.loli.net/2021/10/04/Ltfc2b9yXSHU3Gs.png" alt="image-20211004105139566"></p><p><strong>HotSpot虚拟机中内置了两个（或三个）即时编译器，其中有两个编译器存在已久，分别被称为客户端编译器（Client Compiler）和服务端编译器（Server Compiler），或者简称为C1编译器和C2编译器，第三个是在JDK 10时才出现的、长期目标是代替C2的Graal编译器。</strong></p><p>在分层编译的工作模式出现以前，HotSpot虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作，程序使用哪个编译器，只取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在客户端模式还是服务端模式。</p><p>无论采用的编译器是客户端编译器还是服务端编译器，解释器与编译器搭配使用的方式在虚拟机中被称为混合模式，用户也可以使用参数“-Xint”强制虚拟机运行于解释模式，这时候编译器完全不介入工作，全部代码都使用解释方式执行。另外，也可以使用参数“-Xcomp”强制虚拟机运行于编译模式，这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。</p><p>由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，所花费的时间便会越长。而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了分层编译的功能。<strong>分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次</strong>，其中包括</p><ul><li>第0层：程序纯解释执行，并且解释器不开启性能监控功能。</li><li>第1层：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。</li><li>第2层：仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。</li><li>第3层：仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li><li>第4层：使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</li></ul><p>以上层次并不是固定不变的，根据不同的运行参数和版本，虚拟机可以调整分层的数量。各层次编译之间的交互、转换关系如下图所示。</p><p><img src="https://i.loli.net/2021/10/04/Mki4oW5V1Fa9D3J.png" alt="image-20211004105349257"></p><p>在运行过程中会被即时编译器编译的目标是热点代码，这里所指的热点代码主要有两类，包括：</p><ul><li><strong>被多次调用的方法。</strong></li><li><strong>被多次执行的循环体。</strong><br>前者很好理解，一个方法被调用得多了，方法体内代码执行的次数自然就多，它成为“热点代码”是理所当然的。而后者则是为了解决当一个方法只被调用过一次或少量的几次，但是方法体内部存在循环次数较多的循环体，这样循环体的代码也被重复执行多次，因此这些代码也应该认为是“热点代码”。</li></ul><p><strong>编译对象与触发条件</strong></p><p>对于这两种情况，<strong>编译的目标对象都是整个方法体，而不会是单独的循环体</strong>。第一种情况，由于是依靠方法调用触发的编译，那编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的即时编译方式。而对于后一种情况，尽管编译动作是由循环体所触发的，热点只是方法的一部分，但编译器依然必须以整个方法作为编译对象，只是执行入口（从方法第几条字节码指令开始执行）会稍有不同，编译时会传入执行入口点字节码序号。<strong>这种编译方式因为编译发生在方法执行的过程中，因此被很形象地称为“栈上替换”，即方法的栈帧还在栈上，方法就被替换了。</strong></p><p>要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为“热点探测”，其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主流的热点探测判定方式有两种，分别是：</p><ul><li><strong>基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是“热点方法”</strong>。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li><strong>基于计数器的热点探测：采用这种方法的虚拟机会为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”</strong>。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</li></ul><p>这两种探测手段在商用Java虚拟机中都有使用到，譬如J9用过第一种采样热点探测，而在HotSpot虚拟机中使用的是第二种基于计数器的热点探测方法，为了实现热点计数，HotSpot为每个方法准备了两类计数器：方法调用计数器和回边计数器（回边的意思是指在循环边界往回跳转）。当虚拟机运行参数确定的前提下，这两个计数器都有一个明确的阈值，计数器阈值一旦溢出，就会触发即时编译。</p><p>我们首先来看看方法调用计数器。顾名思义，这个计数器就是用于统计方法被调用的次数，它的默认阈值在客户端模式下是1500次，在服务端模式下是10000次，这个阈值可以通过虚拟机参数-XX:CompileThreshold来人为设定。当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。</p><p><strong>在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期，</strong>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样只要系统运行时间足够长，程序中绝大部分方法都会被编译成本地代码。另外还可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p><p>整个即时编译的交互过程如下图所示：</p><p><img src="https://i.loli.net/2021/10/04/MpKoRVxhD51NUjz.png" alt="image-20211004110201956"></p><p>现在我们再来看看另外一个计数器——回边计数器，它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为“回边”，很显然建立回边计数器统计的目的是为了触发栈上的替换编译。</p><p>关于回边计数器的阈值，虽然HotSpot虚拟机也提供了一个类似于方法调用计数器阈值-XX:CompileThreshold的参数-XX:BackEdgeThreshold供用户设置，但是当前的HotSpot虚拟机实际上并未使用此参数，我们必须设置另外一个参数-XX:OnStackReplacePercentage来间接调整回边计数器的阈值。</p><p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个栈上替换编译请求，并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果，整个执行过程如下图所示。</p><p><img src="https://i.loli.net/2021/10/04/72qpNs1jFHEaJxX.png" alt="image-20211004110309371"></p><p>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p><h2 id="提前编译器"><a href="#提前编译器" class="headerlink" title="提前编译器"></a>提前编译器</h2><p>提前编译在Java技术体系中并不是新事物。1996年JDK 1.0发布，Java有了正式的运行环境，第一个可以使用外挂即时编译器的Java版本是1996年7月发布的JDK 1.0.2，而Java提前编译器的诞生并没有比这晚多少。仅几个月后，IBM公司就推出了第一款用于Java语言的提前编译器。在1998年，GNU组织公布了著名的GCC家族的新成员GNU Compiler for Java（GCJ），这也是一款Java的提前编译器，而且曾经被广泛应用。</p><p>在OpenJDK流行起来之前，各种Linux发行版带的Java实现通常就是GCJ。GCJ出现之后在长达15年的时间里，提前编译这条故事线上基本就再没有什么大的新闻和进展了。类似的状况一直持续至2013年，直到在Android的世界里，剑走偏锋使用提前编译的ART（Android Runtime）横空出世。ART一诞生马上就把使用即时编译的Dalvik虚拟机按在地上使劲蹂躏，仅经过Android 4.4一个版本的短暂交锋之后，ART就迅速终结了Dalvik的性命，把它从Android系统里扫地出门。</p><p><strong>提前编译的优劣得失</strong></p><p>现在提前编译产品和对其的研究有着两条明显的分支，一条分支是做与传统C、C++编译器类似的，在程序运行之前把程序代码编译成机器码的静态翻译工作。另外一条分支是把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码时直接把它加载进来使用。</p><p>我们先来说第一条，这是传统的提前编译应用形式，它在Java中存在的价值直指即时编译的最大弱点：即时编译要占用程序运行时间和运算资源。即使现在先进的即时编译器已经足够快，以至于能够容忍相当高的优化复杂度了。即使现在先进的即时编译器架构有了分层编译的支持，可以先用快速但低质量的即时编译器为高质量的即时编译器争取出更多编译时间，但是，无论如何，即时编译消耗的时间都是原本可用于程序运行的时间，消耗的运算资源都是原本可用于程序运行的资源，这个约束从未减弱，更不会消失，始终是悬在即时编译头顶的达摩克利斯之剑。</p><p>关于提前编译的第二条路径，<strong>本质是给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题。</strong>这种提前编译被称为动态提前编译或者索性就大大方方地直接叫即时编译缓存。在目前的Java技术体系里，这条路径的提前编译已经完全被主流的商用JDK支持。真正引起业界普遍关注的是OpenJDK/OracleJDK 9中所带的Jaotc提前编译器，这是一个基于Graal编译器实现的新工具，目的是让用户可以针对目标机器，为应用程序进行提前编译。HotSpot运行时可以直接加载这些编译的结果，实现加快程序启动速度，减少程序达到全速运行状态所需时间的目的。提前编译因为没有执行时间和资源限制的压力，能够毫无顾忌地使用重负载的优化手段，这当然是一个极大的优势，但即时编译难道就没有能与其竞争的强项了吗？当然是有的，尽管即时编译在时间和运算资源方面的劣势是无法忽视的，但其依然有自己的优势。</p><p><strong>首先，是性能分析制导优化</strong>。上一节介绍HotSpot的即时编译器时就多次提及在解释器或者客户端编译器运行过程中，会不断收集性能监控信息，譬如某个程序点抽象类通常会是什么实际类型、条件判断通常会走哪条分支、方法调用通常会选择哪个版本、循环通常会进行多少次等，这些数据一般在静态分析时是无法得到的，或者不可能存在确定且唯一的解，最多只能依照一些启发性的条件去进行猜测。但<strong>在动态运行时却能看出它们具有非常明显的偏好性</strong>。如果一个条件分支的某一条路径执行特别频繁，而其他路径鲜有问津，那就可以把热的代码集中放到一起，集中优化和分配更好的资源给它。</p><p><strong>其次，是激进预测性优化，这也已经成为很多即时编译优化措施的基础。</strong>相对于提前编译来说，<strong>即时编译的策略就可以不必过于保守</strong>，如果性能监控信息能够支持它做出一些正确的可能性很大但无法保证绝对正确的预测判断，就已经可以大胆地按照高概率的假设进行优化，万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行，并不会出现无法挽救的后果。只要出错概率足够低，这样的优化往往能够大幅度降低目标程序的复杂度，输出运行速度非常高的代码。</p><p><strong>最后，是链接时优化</strong>。Java语言天生就是动态链接的，<strong>一个个Class文件在运行期被加载到虚拟机内存当中，然后在即时编译器里产生优化后的本地代码，</strong>这类事情在Java程序员眼里看起来毫无违和之处。但如果类似的场景出现在使用提前编译的语言和程序上，譬如C、C++的程序要调用某个动态链接库的某个方法，就会出现很明显的边界隔阂，还难以优化。这是因为主程序与动态链接库的代码在它们编译时是完全独立的，两者各自编译、优化自己的代码。这些代码的作者、编译的时间，以及编译器甚至很可能都是不同的，当出现跨链接库边界的调用时，那些理论上应该要做的优化，就会执行起来相当的困难。</p><h2 id="编译器优化技术"><a href="#编译器优化技术" class="headerlink" title="编译器优化技术"></a>编译器优化技术</h2><p>OpenJDK的官方Wiki上，HotSpot虚拟机设计团队列出了一个相对比较全面的、即时编译器中采用的优化技术列表，如下表所示，其中有不少经典编译器的优化手段，也有许多针对Java语言，或者说针对运行在Java虚拟机上的所有语言进行的优化。</p><p><img src="https://i.loli.net/2021/10/04/JHSapITK64nhqEX.png" alt="image-20211004110725423"></p><p><img src="https://i.loli.net/2021/10/04/8VnfitRyxzjJDgM.png" alt="image-20211004110734604"></p><p><strong>优化示例：</strong></p><p>第一步，从原始代码开始，如下所示：</p><p><img src="https://i.loli.net/2021/10/04/OL5ZR3rnBWa4sfi.png" alt="image-20211004110831359"></p><p>第一个要进行的优化是方法内联，它的主要目的有两个：一是去除方法调用的成本，二是为其他优化建立良好的基础。方法内联膨胀之后可以便于在更大范围上进行后续的优化手段，可以获取更好的优化效果。因此各种编译器一般都会把内联优化放在优化序列最靠前的位置。内联后的代码如下所示：</p><p><img src="https://i.loli.net/2021/10/04/zulmeh6Q8ENkKjx.png" alt="image-20211004110856414"></p><p>第二步进行冗余访问消除，假设代码中间注释掉的“… do stuff …”所代表的操作不会改变b.value的值，那么就可以把“z=b.value”替换为“z=y”，因为上一句“y=b.value”已经保证了变量y与b.value是一致的，这样就可以不再去访问对象b的局部变量了。如果把b.value看作一个表达式，那么也可以把这项优化看作一种公共子表达式消除，优化后的代码如下所示：</p><p><img src="https://i.loli.net/2021/10/04/chP5xm9Flv2zQdq.png" alt="image-20211004110944390"></p><p>第三步进行复写传播，因为这段程序的逻辑之中没有必要使用一个额外的变量z，它与变量y是完全相等的，因此我们可以使用y来代替z。复写传播之后的程序如下所示：</p><p><img src="https://i.loli.net/2021/10/04/DsngfLVe5rcF93v.png" alt="image-20211004111002641"></p><p>第四步进行无用代码消除，无用代码可能是永远不会被执行的代码，也可能是完全没有意义的代码。因此它又被很形象地称为“Dead Code”，在第三步的代码中，“y=y”是没有意义的，把它消除后的程序如下所示：</p><p><img src="https://i.loli.net/2021/10/04/5ROlnymrcfMW9d6.png" alt="image-20211004111034776"></p><p>经过四次优化之后，最终代码与原始代码所达到的效果是一致的，但是前者比后者省略了许多语句，体现在字节码和机器码指令上的差距会更大，执行效率的差距也会更高。</p><p>注意，即时编译器对这些代码优化变换是建立在代码的中间表示或者是机器码之上的，绝不是直接在Java源码上去做的，但是为了方便讲解，我们使用Java语言的语法来表示这些优化技术所发挥的作用。</p><p><strong>经典优化技术</strong></p><p>接下来，我们挑选四项有代表性的优化技术，一起观察它们是如何运作的。它们分别是：</p><ol><li>最重要的优化技术之一：方法内联。</li><li>最前沿的优化技术之一：逃逸分析。</li><li>语言无关的经典优化技术之一：公共子表达式消除。</li><li>语言相关的经典优化技术之一：数组边界检查消除。</li></ol><h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>方法内联的优化行为理解起来是没有任何困难的，不过<strong>就是把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免发生真实的方法调用而已</strong>。但实际上Java虚拟机中的内联过程却远没有想象中容易，甚至如果不是即时编译器做了一些特殊的努力，按照经典编译原理的优化理论，大多数的Java方法都无法进行内联。</p><p><strong>只有使用invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析</strong>。除了上述四种方法之外（最多再除去被final修饰的方法这种特殊情况），其他的Java方法调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，<strong>简而言之，Java语言中默认的实例方法是虚方法。</strong></p><p>解决虚方法的内联问题，<strong>Java虚拟机首先引入了一种名为类型继承关系分析（CHA）的技术，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息</strong>。这样，编译器在进行内联时就会分不同情况采取不同的处理：如果是非虚方法，那么直接进行内联就可以了，这种的内联是有百分百安全保障的；如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择，如果查询到只有一个版本，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为守护内联。不过由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于激进预测性优化，必须预留好“逃生门”，即当假设条件不成立时的“退路”。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析是目前Java虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。<strong>逃逸分析的基本原理是：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；</strong>从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</p><p>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化。</p><p>栈上分配：如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。栈上分配可以支持方法逃逸，但不能支持线程逃逸。</p><p>标量替换：若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型都不能再进一步分解了，那么这些数据就可以被称为标量。如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上分配和读写之外，还可以为后续进一步的优化手段创建条件。</p><p>同步消除：线程同步本身是一个相对耗时的过程，<strong>如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。</strong></p><h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>公共子表达式消除是一项非常经典的、普遍应用于各种编译器的优化技术，它的含义是：如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。<strong>对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E。</strong>如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除，如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除。</p><h3 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h3><p>数组边界检查消除是即时编译器中的一项语言相关的经典优化技术。Java语言是一门动态安全的语言，对数组的读写访问也不像C、C++那样实质上就是裸指针操作。如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界的范围检查，即i必须满足“i&gt;=0&amp;&amp;i&lt;foo.length”的访问条件，否则将抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException。这对软件开发者来说是一件很友好的事情，即使程序员没有专门编写防御代码，也能够避免大多数的溢出攻击。但是对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这必定是一种性能负担。</p><p>无论如何，为了安全，数组边界检查肯定是要做的，但数组边界检查是不是必须在运行期间一次不漏地进行则是可以“商量”的事情。例如下面这个简单的情况：<strong>数组下标是一个常量，如foo[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下标“3”没有越界，执行的时候就无须判断了</strong>。更加常见的情况是，数组访问发生在循环之中，并且使用循环变量来进行数组的访问。<strong>如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0，foo.length)之内，那么在循环中就可以把整个数组的上下界检查消除掉，这可以节省很多次的条件判断操作。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="posts/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>posts/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><h3 id="判断类是否“相等”"><a href="#判断类是否“相等”" class="headerlink" title="判断类是否“相等”"></a>判断类是否“相等”</h3><p>任意一个类，都由<strong>加载它的类加载器</strong>和这个<strong>类本身</strong>一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。</p><p>因此，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。</p><p>这里的“相等”，包括代表类的 Class 对象的 <code>equals()</code> 方法、<code>isInstance()</code> 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。</p><h3 id="加载器种类"><a href="#加载器种类" class="headerlink" title="加载器种类"></a>加载器种类</h3><p>系统提供了 3 种类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）： 负责将存放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。</li><li>扩展类加载器（Extension ClassLoader）： 负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录中的所有类库，开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器（Application ClassLoader）： 由于这个类加载器是 ClassLoader 中的 <code>getSystemClassLoader()</code> 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/classloader.png" alt="ClassLoader"></p><p>当然，如果有必要，还可以加入自己定义的类加载器。</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h3><p>双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。</p><p>在 java.lang.ClassLoader 中的 <code>loadClass</code> 方法中实现该过程。</p><h3 id="为什么使用双亲委派模型"><a href="#为什么使用双亲委派模型" class="headerlink" title="为什么使用双亲委派模型"></a>为什么使用双亲委派模型</h3><p>像 java.lang.Object 这些存放在 rt.jar 中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的 Object 类都是同一个。</p><p>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载的过程</title>
      <link href="posts/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>posts/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>类加载过程包括 5 个阶段：加载、验证、准备、解析和初始化。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h3 id="加载的过程"><a href="#加载的过程" class="headerlink" title="加载的过程"></a>加载的过程</h3><p>“加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成 3 件事：</p><ul><li>通过类的全限定名获取该类的二进制字节流。</li><li>将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。</li><li>在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ul><h3 id="获取二进制字节流"><a href="#获取二进制字节流" class="headerlink" title="获取二进制字节流"></a>获取二进制字节流</h3><p>对于 Class 文件，虚拟机没有指明要从哪里获取、怎样获取。除了直接从编译好的 .class 文件中读取，还有以下几种方式：</p><ul><li>从 zip 包中读取，如 jar、war 等</li><li>从网络中获取，如 Applet</li><li>通过动态代理技术生成代理类的二进制字节流</li><li>由 JSP 文件生成对应的 Class 类</li><li>从数据库中读取，如 有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li></ul><h3 id="“非数组类”与“数组类”加载比较"><a href="#“非数组类”与“数组类”加载比较" class="headerlink" title="“非数组类”与“数组类”加载比较"></a>“非数组类”与“数组类”加载比较</h3><ul><li>非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器控制字节流的获取方式（如重写一个类加载器的 <code>loadClass()</code> 方法）</li><li>数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的，再由类加载器创建数组中的元素类。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>虚拟机规范未规定 Class 对象的存储位置，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但存放在方法区中。</li><li>加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始了。但这两个阶段的开始时间仍然保持着固定的先后顺序。</li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="验证的重要性"><a href="#验证的重要性" class="headerlink" title="验证的重要性"></a>验证的重要性</h3><p>验证阶段确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3 id="验证的过程"><a href="#验证的过程" class="headerlink" title="验证的过程"></a>验证的过程</h3><ul><li>文件格式验证 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：<ul><li>是否以魔数 0XCAFEBABE 开头</li><li>主次版本号是否在当前虚拟机处理范围内</li><li>常量池是否有不被支持的常量类型</li><li>指向常量的索引值是否指向了不存在的常量</li><li>CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据</li><li>……</li></ul></li><li>元数据验证 对字节码描述信息进行语义分析，确保其符合 Java 语法规范。</li><li>字节码验证 本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。</li><li>符号引用验证 本阶段发生在解析阶段，确保解析正常执行。</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。</p><p>初始值“通常情况下”是数据类型的零值（0, null…），假设一个类变量的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>那么变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法。</p><p>存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，那么在准备阶段 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>那么在准备阶段虚拟机会根据 ConstantValue 的设置将 value 赋值为 123。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类初始化阶段是类加载过程的最后一步，是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</p><p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。</p><p>静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;  <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.println(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>&lt;clinit&gt;()</code> 方法不需要显式调用父类构造器，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p><p>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Sub.B); <span class="comment">// 输出 2</span></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>&lt;clinit&gt;()</code> 方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code> 方法。</p><p>接口中不能使用静态代码块，但接口也需要通过 <code>&lt;clinit&gt;()</code> 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父类的 <code>&lt;clinit&gt;()</code> 方法，只有当父接口中定义的变量使用时，父接口才会初始化。</p><p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载的时机</title>
      <link href="posts/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA/"/>
      <url>posts/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段：</p><ul><li>加载</li><li>验证</li><li>准备</li><li>解析</li><li>初始化</li><li>使用</li><li>卸载</li></ul><p>验证、准备、解析 3 个阶段统称为连接。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/loadclass.png" alt="Load Class"></p><p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始（注意是“开始”，而不是“进行”或“完成”），而解析阶段则不一定：它在某些情况下可以在初始化后再开始，这是为了支持 Java 语言的运行时绑定。</p><h2 id="类加载过程中“初始化”开始的时机"><a href="#类加载过程中“初始化”开始的时机" class="headerlink" title="类加载过程中“初始化”开始的时机"></a>类加载过程中“初始化”开始的时机</h2><p>Java 虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但对于“初始化”阶段，有着严格的规定。有且仅有 5 种情况必须立即对类进行“初始化”：</p><ul><li>在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。</li><li>对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。</li><li>初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。</li><li>虚拟机启动时，用于需要指定一个包含 <code>main()</code> 方法的主类，虚拟机会先初始化这个主类。</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。</li></ul><p>这 5 种场景中的行为称为对一个类进行<strong>主动引用</strong>，除此之外，其它所有引用类的方式都不会触发初始化，称为<strong>被动引用</strong>。</p><h2 id="被动引用演示-Demo"><a href="#被动引用演示-Demo" class="headerlink" title="被动引用演示 Demo"></a>被动引用演示 Demo</h2><h3 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动引用 Demo1:</span></span><br><span class="line"><span class="comment"> * 通过子类引用父类的静态字段，不会导致子类初始化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ylb</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">        <span class="comment">// SuperClass init!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><h3 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动引用 Demo2:</span></span><br><span class="line"><span class="comment"> * 通过数组定义来引用类，不会触发此类的初始化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ylb</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperClass[] superClasses = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这段代码不会触发父类的初始化，但会触发“[L 全类名”这个类的初始化，它由虚拟机自动生成，直接继承自 java.lang.Object，创建动作由字节码指令 newarray 触发。</p><h3 id="Demo3"><a href="#Demo3" class="headerlink" title="Demo3"></a>Demo3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动引用 Demo3:</span></span><br><span class="line"><span class="comment"> * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ylb</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLO_BINGO = <span class="string">&quot;Hello Bingo&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLO_BINGO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>编译通过之后，常量存储到 NotInitialization 类的常量池中，NotInitialization 的 Class 文件中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就没有任何联系了。</p><h2 id="接口的加载过程"><a href="#接口的加载过程" class="headerlink" title="接口的加载过程"></a>接口的加载过程</h2><p>接口加载过程与类加载过程稍有不同。</p><p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类文件结构</title>
      <link href="posts/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>posts/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="JVM-的“无关性”"><a href="#JVM-的“无关性”" class="headerlink" title="JVM 的“无关性”"></a>JVM 的“无关性”</h2><p>谈论 JVM 的无关性，主要有以下两个：</p><ul><li>平台无关性：任何操作系统都能运行 Java 代码</li><li>语言无关性： JVM 能运行除 Java 以外的其他代码</li></ul><p>Java 源代码首先需要使用 Javac 编译器编译成 .class 文件，然后由 JVM 执行 .class 文件，从而程序开始运行。</p><p>JVM 只认识 .class 文件，它不关心是何种语言生成了 .class 文件，只要 .class 文件符合 JVM 的规范就能运行。 目前已经有 JRuby、Jython、Scala 等语言能够在 JVM 上运行。它们有各自的语法规则，不过它们的编译器 都能将各自的源码编译成符合 JVM 规范的 .class 文件，从而能够借助 JVM 运行它们。</p><blockquote><p>Java 语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的， 因此字节码命令所能提供的语义描述能力肯定会比      ; Java 语言本身更加强大。 因此，有一些 Java 语言本身无法有效支持的语言特性，不代表字节码本身无法有效支持。</p></blockquote><h2 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h2><p>Class 文件是二进制文件，它的内容具有严格的规范，文件中没有任何空格，全都是连续的 0/1。Class 文件 中的所有内容被分为两种类型：无符号数、表。</p><ul><li>无符号数 无符号数表示 Class 文件中的值，这些值没有任何类型，但有不同的长度。u1、u2、u4、u8 分别代表 1/2/4/8 字节的无符号数。</li><li>表 由多个无符号数或者其他表作为数据项构成的复合数据类型。</li></ul><p>Class 文件具体由以下几个构成:</p><ul><li>魔数</li><li>版本信息</li><li>常量池</li><li>访问标志</li><li>类索引、父类索引、接口索引集合</li><li>字段表集合</li><li>方法表集合</li><li>属性表集合</li></ul><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>Class 文件的头 4 个字节称为魔数，用来表示这个 Class 文件的类型。</p><p>Class 文件的魔数是用 16 进制表示的“CAFE BABE”，是不是很具有浪漫色彩？</p><blockquote><p>魔数相当于文件后缀名，只不过后缀名容易被修改，不安全，因此在 Class 文件中标识文件类型比较合适。</p></blockquote><h3 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h3><p>紧接着魔数的 4 个字节是版本信息，5-6 字节表示次版本号，7-8 字节表示主版本号，它们表示当前 Class 文件中使用的是哪个版本的 JDK。</p><p>高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式并未发生任何变化，虚拟机也必需拒绝执行超过其版本号的 Class 文件。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>版本信息之后就是常量池，常量池中存放两种类型的常量：</p><ul><li><p>字面值常量</p><p>字面值常量就是我们在程序中定义的字符串、被 final 修饰的值。</p></li><li><p>符号引用</p><p>符号引用就是我们定义的各种名字：类和接口的全限定名、字段的名字和描述符、方法的名字和描述符。</p></li></ul><h4 id="常量池的特点"><a href="#常量池的特点" class="headerlink" title="常量池的特点"></a>常量池的特点</h4><ul><li>常量池中常量数量不固定，因此常量池开头放置一个 u2 类型的无符号数，用来存储当前常量池的容量。</li><li>常量池的每一项常量都是一个表，表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型。</li></ul><h4 id="常量池中常量类型"><a href="#常量池中常量类型" class="headerlink" title="常量池中常量类型"></a>常量池中常量类型</h4><table><thead><tr><th>类型</th><th>tag</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8 编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标识方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p>对于 CONSTANT_Class_info（此类型的常量代表一个类或者接口的符号引用），它的二维表结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u1</td><td>tag</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr></tbody></table><p>tag 是标志位，用于区分常量类型；name_index 是一个索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型常量，此常量代表这个类（或接口）的全限定名，这里 name_index 值若为 0x0002，也即是指向了常量池中的第二项常量。</p><p>CONSTANT_Utf8_info 型常量的结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u1</td><td>tag</td><td>1</td></tr><tr><td>u2</td><td>length</td><td>1</td></tr><tr><td>u1</td><td>bytes</td><td>length</td></tr></tbody></table><p>tag 是当前常量的类型；length 表示这个字符串的长度；bytes 是这个字符串的内容（采用缩略的 UTF8 编码）</p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否被 abstract/final 修饰。</p><h3 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h3><p>类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p><p>由于 Java 不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。一个类可能实现了多个接口，因此用接口索引集合来描述。这个集合第一项为 u2 类型的数据，表示索引表的容量，接下来就是接口的名字索引。</p><p>类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过该常量总的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。</p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表集合存储本类涉及到的成员变量，包括实例变量和类变量，但不包括方法中的局部变量。</p><p>每一个字段表只表示一个成员变量，本类中的所有成员变量构成了字段表集合。字段表结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>说明</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td><td>字段的访问标志，与类稍有不同</td></tr><tr><td>u2</td><td>name_index</td><td>1</td><td>字段名字的索引</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td><td>描述符，用于描述字段的数据类型。 基本数据类型用大写字母表示； 对象类型用“L 对象类型的全限定名”表示。</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td><td>属性表集合的长度</td></tr><tr><td>u2</td><td>attributes</td><td>attributes_count</td><td>属性表集合，用于存放属性的额外信息，如属性的值。</td></tr></tbody></table><blockquote><p>字段表集合中不会出现从父类（或接口）中继承而来的字段，但有可能出现原本 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p></blockquote><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>方法表结构与属性表类似。</p><p>volatile 关键字 和 transient 关键字不能修饰方法，所以方法表的访问标志中没有 ACC_VOLATILE 和 ACC_TRANSIENT 标志。</p><p>方法表的属性表集合中有一张 Code 属性表，用于存储当前方法经编译器编译后的字节码指令。</p><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>每个属性对应一张属性表，属性表的结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 性能调优</title>
      <link href="posts/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
      <url>posts/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-性能调优"><a href="#JVM-性能调优" class="headerlink" title="JVM 性能调优"></a>JVM 性能调优</h1><p>在高性能硬件上部署程序，目前主要有两种方式：</p><ul><li>通过 64 位 JDK 来使用大内存；</li><li>使用若干个 32 位虚拟机建立逻辑集群来利用硬件资源。</li></ul><h2 id="使用-64-位-JDK-管理大内存"><a href="#使用-64-位-JDK-管理大内存" class="headerlink" title="使用 64 位 JDK 管理大内存"></a>使用 64 位 JDK 管理大内存</h2><p>堆内存变大后，虽然垃圾收集的频率减少了，但每次垃圾回收的时间变长。 如果堆内存为 14 G，那么每次 Full GC 将长达数十秒。如果 Full GC 频繁发生，那么对于一个网站来说是无法忍受的。</p><p>对于用户交互性强、对停顿时间敏感的系统，可以给 Java 虚拟机分配超大堆的前提是有把握把应用程序的 Full GC 频率控制得足够低，至少要低到不会影响用户使用。</p><p>可能面临的问题：</p><ul><li>内存回收导致的长时间停顿；</li><li>现阶段，64 位 JDK 的性能普遍比 32 位 JDK 低；</li><li>需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生超过 10GB 的 Dump 文件），哪怕产生了快照也几乎无法进行分析；</li><li>相同程序在 64 位 JDK 消耗的内存一般比 32 位 JDK 大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。</li></ul><h2 id="使用-32-位-JVM-建立逻辑集群"><a href="#使用-32-位-JVM-建立逻辑集群" class="headerlink" title="使用 32 位 JVM 建立逻辑集群"></a>使用 32 位 JVM 建立逻辑集群</h2><p>在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同端口， 然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。</p><p>考虑到在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，并不需要关心状态保留、热转移之类的高可用性能需求， 也不需要保证每个虚拟机进程有绝对的均衡负载，因此使用无 Session 复制的亲合式集群是一个不错的选择。 我们仅仅需要保障集群具备亲合性，也就是均衡器按一定的规则算法（一般根据 SessionID 分配） 将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可。</p><p>可能遇到的问题：</p><ul><li>尽量避免节点竞争全局资源，如磁盘竞争，各个节点如果同时访问某个磁盘文件的话，很可能导致 IO 异常；</li><li>很难高效利用资源池，如连接池，一般都是在节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余；</li><li>各个节点受到 32 位的内存限制；</li><li>大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点都有一份缓存，这时候可以考虑把本地缓存改成集中式缓存。</li></ul><h2 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h2><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>一个小型系统，使用 32 位 JDK，4G 内存，测试期间发现服务端不定时抛出内存溢出异常。 加入 -XX:+HeapDumpOnOutOfMemoryError（添加这个参数后，堆内存溢出时就会输出异常日志）， 但再次发生内存溢出时，没有生成相关异常日志。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在 32 位 JDK 上，1.6G 分配给堆，还有一部分分配给 JVM 的其他内存，直接内存最大也只能在剩余的 0.4G 空间中分出一部分， 如果使用了 NIO，JVM 会在 JVM 内存之外分配内存空间，那么就要小心“直接内存”不足时发生内存溢出异常了。</p><h3 id="直接内存的回收过程"><a href="#直接内存的回收过程" class="headerlink" title="直接内存的回收过程"></a>直接内存的回收过程</h3><p>直接内存虽然不是 JVM 内存空间，但它的垃圾回收也由 JVM 负责。</p><p>垃圾收集进行时，虚拟机虽然会对直接内存进行回收， 但是直接内存却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收， 它只能等老年代满了后 Full GC，然后“顺便”帮它清理掉内存的废弃对象。 否则只能一直等到抛出内存溢出异常时，先 catch 掉，再在 catch 块里大喊 “<code>System.gc()</code>”。 要是虚拟机还是不听，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分配与回收策略</title>
      <link href="posts/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
      <url>posts/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><p>对象的内存分配，就是在堆上分配（也可能经过 JIT 编译后被拆散为标量类型并间接在栈上分配），对象主要分配在新生代的 Eden 区上，少数情况下可能直接分配在老年代，<strong>分配规则不固定</strong>，取决于当前使用的垃圾收集器组合以及相关的参数配置。</p><p>以下列举几条最普遍的内存分配规则，供大家学习。</p><h2 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h2><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><p>👇<strong>Minor GC</strong> vs <strong>Major GC</strong>/<strong>Full GC</strong>：</p><ul><li>Minor GC：回收新生代（包括 Eden 和 Survivor 区域），因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li><li>Major GC / Full GC: 回收老年代，出现了 Major GC，经常会伴随至少一次的 Minor GC，但这并非绝对。Major GC 的速度一般会比 Minor GC 慢 10 倍 以上。</li></ul><blockquote><p>在 JVM 规范中，Major GC 和 Full GC 都没有一个正式的定义，所以有人也简单地认为 Major GC 清理老年代，而 Full GC 清理整个内存堆。</p></blockquote><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>大对象是指需要大量连续内存空间的 Java 对象，如很长的字符串或数据。</p><p>一个大对象能够存入 Eden 区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及大量的复制，就会造成效率低下。</p><p>虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。（还记得吗，新生代采用复制算法回收垃圾）</p><h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>JVM 给每个对象定义了一个对象年龄计数器。当新生代发生一次 Minor GC 后，存活下来的对象年龄 +1，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。</p><p>使用 -XXMaxTenuringThreshold 设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。</p><h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>如果当前新生代的 Survivor 中，相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄 &gt;= 该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p><h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>JDK 6 Update 24 之前的规则是这样的：<br>在发生 Minor GC 之前，虚拟机会先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>， 如果这个条件成立，Minor GC 可以确保是安全的； 如果不成立，则虚拟机会查看 HandlePromotionFailure 值是否设置为允许担保失败， 如果是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于，将尝试进行一次 Minor GC,尽管这次 Minor GC 是有风险的； 如果小于，或者 HandlePromotionFailure 设置不允许冒险，那此时也要改为进行一次 Full GC。</p><p>JDK 6 Update 24 之后的规则变为：<br>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p><p>通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。</p><p>这个过程就是分配担保。</p><hr><p>👇 总结一下有哪些情况可能会触发 JVM 进行 Full GC。</p><ol><li>System.gc() 方法的调用<br>此方法的调用是建议 JVM 进行 Full GC，注意这<strong>只是建议而非一定</strong>，但在很多情况下它会触发 Full GC，从而增加 Full GC 的频率。通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过 -XX:+ DisableExplicitGC 来禁止调用 System.gc()。</li><li>老年代空间不足<br>老年代空间不足会触发 Full GC 操作，若进行该操作后空间依然不足，则会抛出如下错误：<br><code>java.lang.OutOfMemoryError: Java heap space</code></li><li>永久代空间不足<br>JVM 规范中运行时数据区域中的方法区，在 HotSpot 虚拟机中也称为永久代（Permanet Generation），存放一些类信息、常量、静态变量等数据，当系统要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，会触发 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：<br><code>java.lang.OutOfMemoryError: PermGen space </code></li><li>CMS GC 时出现 promotion failed 和 concurrent mode failure<br>promotion failed，就是上文所说的担保失败，而 concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。</li><li>统计得到的 Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot 垃圾收集器</title>
      <link href="posts/HotSpot%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>posts/HotSpot%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="HotSpot-垃圾收集器"><a href="#HotSpot-垃圾收集器" class="headerlink" title="HotSpot 垃圾收集器"></a>HotSpot 垃圾收集器</h1><p>HotSpot 虚拟机提供了多种垃圾收集器，每种收集器都有各自的特点，虽然我们要对各个收集器进行比较，但并非为了挑选出一个最好的收集器。我们选择的只是对具体应用最合适的收集器。</p><h2 id="新生代垃圾收集器"><a href="#新生代垃圾收集器" class="headerlink" title="新生代垃圾收集器"></a>新生代垃圾收集器</h2><h3 id="Serial-垃圾收集器（单线程）"><a href="#Serial-垃圾收集器（单线程）" class="headerlink" title="Serial 垃圾收集器（单线程）"></a>Serial 垃圾收集器（单线程）</h3><p>只开启<strong>一条</strong> GC 线程进行垃圾回收，并且在垃圾收集过程中停止一切用户线程(Stop The World)。</p><p>一般客户端应用所需内存较小，不会创建太多对象，而且堆内存不大，因此垃圾收集器回收时间短，即使在这段时间停止一切用户线程，也不会感觉明显卡顿。因此 Serial 垃圾收集器<strong>适合客户端</strong>使用。</p><p>由于 Serial 收集器只使用一条 GC 线程，避免了线程切换的开销，从而简单高效。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/serial.png" alt="Serial"></p><h3 id="ParNew-垃圾收集器（多线程）"><a href="#ParNew-垃圾收集器（多线程）" class="headerlink" title="ParNew 垃圾收集器（多线程）"></a>ParNew 垃圾收集器（多线程）</h3><p>ParNew 是 Serial 的多线程版本。由多条 GC 线程并行地进行垃圾清理。但清理过程依然需要 Stop The World。</p><p>ParNew 追求“<strong>低停顿时间</strong>”,与 Serial 唯一区别就是使用了多线程进行垃圾收集，在多 CPU 环境下性能比 Serial 会有一定程度的提升；但<strong>线程切换需要额外的开销</strong>，因此在单 CPU 环境中表现不如 Serial。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/parnew.png" alt="ParNew"></p><h3 id="Parallel-Scavenge-垃圾收集器（多线程）"><a href="#Parallel-Scavenge-垃圾收集器（多线程）" class="headerlink" title="Parallel Scavenge 垃圾收集器（多线程）"></a>Parallel Scavenge 垃圾收集器（多线程）</h3><p>Parallel Scavenge 和 ParNew 一样，都是多线程、新生代垃圾收集器。但是两者有巨大的不同点：</p><ul><li>Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。</li><li>ParNew：追求降低用户停顿时间，适合交互式应用。</li></ul><p>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</p><p>追求高吞吐量，可以通过减少 GC 执行实际工作的时间，然而，仅仅偶尔运行 GC 意味着每当 GC 运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。单个 GC 需要花更多的时间来完成，从而导致更高的暂停时间。而考虑到低暂停时间，最好频繁运行 GC 以便更快速完成，反过来又导致吞吐量下降。</p><ul><li>通过参数 -XX:GCTimeRadio 设置垃圾回收时间占总 CPU 时间的百分比。</li><li>通过参数 -XX:MaxGCPauseMillis 设置垃圾处理过程最久停顿时间。</li><li>通过命令 -XX:+UseAdaptiveSizePolicy 开启自适应策略。我们只要设置好堆的大小和 MaxGCPauseMillis 或 GCTimeRadio，收集器会自动调整新生代的大小、Eden 和 Survivor 的比例、对象进入老年代的年龄，以最大程度上接近我们设置的 MaxGCPauseMillis 或 GCTimeRadio。</li></ul><h2 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h2><h3 id="Serial-Old-垃圾收集器（单线程）"><a href="#Serial-Old-垃圾收集器（单线程）" class="headerlink" title="Serial Old 垃圾收集器（单线程）"></a>Serial Old 垃圾收集器（单线程）</h3><p>Serial Old 收集器是 Serial 的老年代版本，都是单线程收集器，只启用一条 GC 线程，都适合客户端应用。它们唯一的区别就是：Serial Old 工作在老年代，使用“标记-整理”算法；Serial 工作在新生代，使用“复制”算法。</p><h3 id="Parallel-Old-垃圾收集器（多线程）"><a href="#Parallel-Old-垃圾收集器（多线程）" class="headerlink" title="Parallel Old 垃圾收集器（多线程）"></a>Parallel Old 垃圾收集器（多线程）</h3><p>Parallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。</p><h3 id="CMS-垃圾收集器"><a href="#CMS-垃圾收集器" class="headerlink" title="CMS 垃圾收集器"></a>CMS 垃圾收集器</h3><p>CMS(Concurrent Mark Sweep，并发标记清除)收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。</p><ul><li>初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。</li><li>并发标记：使用<strong>多条</strong>标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。</li><li>重新标记：Stop The World，使用多条标记线程并发执行，将刚才并发标记过程中新出现的废弃对象标记出来。</li><li>并发清除：只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。</li></ul><p>并发标记与并发清除过程耗时最长，且可以与用户线程一起工作，因此，<strong>总体上说</strong>，CMS 收集器的内存回收过程是与用户线程<strong>一起并发执行</strong>的。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/cms.png" alt="CMS"></p><p>CMS 的缺点：</p><ul><li>吞吐量低</li><li>无法处理浮动垃圾，导致频繁 Full GC</li><li>使用“标记-清除”算法产生碎片空间</li></ul><p>对于产生碎片空间的问题，可以通过开启 -XX:+UseCMSCompactAtFullCollection，在每次 Full GC 完成后都会进行一次内存压缩整理，将零散在各处的对象整理到一块。设置参数 -XX:CMSFullGCsBeforeCompaction 告诉 CMS，经过了 N 次 Full GC 之后再进行一次内存整理。</p><h2 id="G1-通用垃圾收集器"><a href="#G1-通用垃圾收集器" class="headerlink" title="G1 通用垃圾收集器"></a>G1 通用垃圾收集器</h2><p>G1 是一款面向服务端应用的垃圾收集器，它没有新生代和老年代的概念，而是将堆划分为一块块独立的 Region。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收，因此可以获得最大的回收效率。</p><p>从整体上看， G1 是基于“标记-整理”算法实现的收集器，从局部（两个 Region 之间）上看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</p><p>这里抛个问题 👇<br>一个对象和它内部所引用的对象可能不在同一个 Region 中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次可达性分析？</p><p>并不！每个 Region 都有一个 Remembered Set，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在 GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历。</p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的工作过程分为以下几个步骤：</p><ul><li>初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。</li><li>并发标记：使用<strong>一条</strong>标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。</li><li>最终标记：Stop The World，使用多条标记线程并发执行。</li><li>筛选回收：回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集策略与算法</title>
      <link href="posts/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>posts/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；栈帧随着方法的开始而入栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>而对于 Java 堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的正是这部分内存。</p><h1 id="判定对象是否存活"><a href="#判定对象是否存活" class="headerlink" title="判定对象是否存活"></a>判定对象是否存活</h1><p>若一个对象不被任何对象或变量引用，那么它就是无效对象，需要被回收。</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。</p><p>引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题。</p><blockquote><p>举个栗子 👉 对象 objA 和 objB 都有字段 instance，令 objA.instance = objB 并且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。</p></blockquote><h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。</p><p>GC Roots 是指：</p><ul><li>Java 虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中常量引用的对象</li><li>方法区中类静态属性引用的对象</li></ul><p>GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。</p><h1 id="引用的种类"><a href="#引用的种类" class="headerlink" title="引用的种类"></a>引用的种类</h1><p>判定对象是否存活与“引用”有关。在 JDK 1.2 以前，Java 中的引用定义很传统，一个对象只有被引用或者没有被引用两种状态，我们希望能描述这一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种。不同的引用类型，主要体现的是对象不同的可达性状态<code>reachable</code>和垃圾收集的影响。</p><h2 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h2><p>类似 “Object obj = new Object()” 这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。但是，如果我们<strong>错误地保持了强引用</strong>，比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。</p><h2 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h2><p>软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来<strong>实现内存敏感的缓存</strong>，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><h2 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h2><p>弱引用的<strong>强度比软引用更弱</strong>一些。当 JVM 进行垃圾回收时，<strong>无论内存是否充足，都会回收</strong>只被弱引用关联的对象。</p><h2 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h2><p>虚引用也称幽灵引用或者幻影引用，它是<strong>最弱</strong>的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。</p><h1 id="回收堆中无效对象"><a href="#回收堆中无效对象" class="headerlink" title="回收堆中无效对象"></a>回收堆中无效对象</h1><p>对于可达性分析中不可达的对象，也并不是没有存活的可能。</p><h2 id="判定-finalize-是否有必要执行"><a href="#判定-finalize-是否有必要执行" class="headerlink" title="判定 finalize() 是否有必要执行"></a>判定 finalize() 是否有必要执行</h2><p>JVM 会判断此对象是否有必要执行 finalize() 方法，如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么视为“没有必要执行”。那么对象基本上就真的被回收了。</p><p>如果对象被判定为有必要执行 finalize() 方法，那么对象会被放入一个 F-Queue 队列中，虚拟机会以较低的优先级执行这些 finalize()方法，但不会确保所有的 finalize() 方法都会执行结束。如果 finalize() 方法出现耗时操作，虚拟机就直接停止指向该方法，将对象清除。</p><h2 id="对象重生或死亡"><a href="#对象重生或死亡" class="headerlink" title="对象重生或死亡"></a>对象重生或死亡</h2><p>如果在执行 finalize() 方法时，将 this 赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。</p><blockquote><p>任何一个对象的 finalize() 方法只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，想继续在 finalize() 中自救就失效了。</p></blockquote><h1 id="回收方法区内存"><a href="#回收方法区内存" class="headerlink" title="回收方法区内存"></a>回收方法区内存</h1><p>方法区中存放生命周期较长的类信息、常量、静态变量，每次垃圾收集只有少量的垃圾被清除。方法区中主要清除两种垃圾：</p><ul><li>废弃常量</li><li>无用的类</li></ul><h2 id="判定废弃常量"><a href="#判定废弃常量" class="headerlink" title="判定废弃常量"></a>判定废弃常量</h2><p>只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。比如，一个字符串 “bingo” 进入了常量池，但是当前系统没有任何一个 String 对象引用常量池中的 “bingo” 常量，也没有其它地方引用这个字面量，必要的话，”bingo”常量会被清理出常量池。</p><h2 id="判定无用的类"><a href="#判定无用的类" class="headerlink" title="判定无用的类"></a>判定无用的类</h2><p>判定一个类是否是“无用的类”，条件较为苛刻。</p><ul><li>该类的所有对象都已经被清除</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><blockquote><p>一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除。</p></blockquote><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>学会了如何判定无效对象、无用类、废弃常量之后，剩余工作就是回收这些垃圾。常见的垃圾收集算法有以下几个：</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p><strong>标记</strong>的过程是：遍历所有的 <code>GC Roots</code>，然后将所有 <code>GC Roots</code> 可达的对象<strong>标记为存活的对象</strong>。</p><p><strong>清除</strong>的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。</p><p>这种方法有两个<strong>不足</strong>：</p><ul><li>效率问题：标记和清除两个过程的效率都不高。</li><li>空间问题：标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h2 id="复制算法（新生代）"><a href="#复制算法（新生代）" class="headerlink" title="复制算法（新生代）"></a>复制算法（新生代）</h2><p>为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。这种算法有优有劣：</p><ul><li>优点：不会有内存碎片的问题。</li><li>缺点：内存缩小为原来的一半，浪费空间。</li></ul><p>为了解决空间利用率问题，可以将内存分为三块： Eden、From Survivor、To Survivor，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。</p><p>但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保。</p><h3 id="分配担保"><a href="#分配担保" class="headerlink" title="分配担保"></a>分配担保</h3><p>为对象分配内存空间时，如果 Eden+Survivor 中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 Minor GC 过后依然有超过 10% 的对象存活，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区。</p><h2 id="标记-整理算法（老年代）"><a href="#标记-整理算法（老年代）" class="headerlink" title="标记-整理算法（老年代）"></a>标记-整理算法（老年代）</h2><p><strong>标记</strong>：它的第一个阶段与<strong>标记/清除算法</strong>是一模一样的，均是遍历 <code>GC Roots</code>，然后将存活的对象标记。</p><p><strong>整理</strong>：移动所有<strong>存活的对象</strong>，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。</p><p>这是一种老年代的垃圾收集算法。老年代的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次需要复制大量存活的对象，效率很低。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。</p><ul><li>新生代：复制算法</li><li>老年代：标记-清除算法、标记-整理算法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot 虚拟机对象探秘</title>
      <link href="posts/HotSpot%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/"/>
      <url>posts/HotSpot%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>在 HotSpot 虚拟机中，对象的内存布局分为以下 3 块区域：</p><ul><li>对象头（Header）</li><li>实例数据（Instance Data）</li><li>对齐填充（Padding）  </li></ul><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/object-memory-layout.png" alt="object-memory-layout.png"></p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象头记录了对象在运行过程中所需要使用的一些数据：</p><ul><li>哈希码</li><li>GC 分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程 ID</li><li>偏向时间戳</li></ul><p>对象头可能包含类型指针，通过该指针能确定对象属于哪个类。如果对象是一个数组，那么对象头还会包括数组长度。</p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>实例数据部分就是成员变量的值，其中包括父类成员变量和本类成员变量。</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>用于确保对象的总长度为 8 字节的整数倍。</p><p>HotSpot VM 的自动内存管理系统要求对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><blockquote><p>对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。</p></blockquote><h1 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h1><h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h2><p>虚拟机在解析<code>.class</code>文件时，若遇到一条 new 指令，首先它会去检查常量池中是否有这个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。</p><h2 id="为新生对象分配内存"><a href="#为新生对象分配内存" class="headerlink" title="为新生对象分配内存"></a>为新生对象分配内存</h2><p>对象所需内存的大小在类加载完成后便可完全确定，接下来从堆中划分一块对应大小的内存空间给新的对象。分配堆中内存有两种方式：</p><ul><li><strong>指针碰撞</strong><br>如果 Java <strong>堆中内存绝对规整</strong>（说明采用的是“<strong>复制算法</strong>”或“<strong>标记整理法</strong>”），空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式称为“<strong>指针碰撞</strong>”。</li><li><strong>空闲列表</strong><br>如果 Java <strong>堆中内存并不规整</strong>，已使用的内存和空闲内存交错（说明采用的是<strong>标记-清除法</strong>，有碎片），此时没法简单进行指针碰撞， VM 必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。这种方式称为“<strong>空闲列表</strong>”。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>分配完内存后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。</p><p>至此，整个对象的创建过程就完成了。</p><h1 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h1><p>所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。也就是说在建立一个对象时两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。 那么根据引用存放的地址类型的不同，对象有不同的访问方式。</p><h2 id="句柄访问方式"><a href="#句柄访问方式" class="headerlink" title="句柄访问方式"></a>句柄访问方式</h2><p>堆中需要有一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p>引用类型的变量存放的是该对象的句柄地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/handle-access.jpg" alt="handle-access"></p><h2 id="直接指针访问方式"><a href="#直接指针访问方式" class="headerlink" title="直接指针访问方式"></a>直接指针访问方式</h2><p>引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/direct-pointer.jpg" alt="direct-pointer"></p><p>需要说明的是，HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要<strong>额外的策略</strong>来存储对象在方法区中类信息的地址。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存结构</title>
      <link href="posts/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>posts/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>Java 虚拟机的内存空间分为 5 个部分：</p><ul><li>程序计数器</li><li>Java 虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/jvm-memory-structure.jpg" alt="jvm-memory-structure"></p><p>JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。</p><h1 id="程序计数器（PC-寄存器）"><a href="#程序计数器（PC-寄存器）" class="headerlink" title="程序计数器（PC 寄存器）"></a>程序计数器（PC 寄存器）</h1><h2 id="程序计数器的定义"><a href="#程序计数器的定义" class="headerlink" title="程序计数器的定义"></a>程序计数器的定义</h2><p>程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为<code>Undefined</code>。</p><h2 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h2><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li><li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。</li></ul><h2 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h2><ul><li>是一块较小的内存空间。</li><li>线程私有，每条线程都有自己的程序计数器。</li><li>生命周期：随着线程的创建而创建，随着线程的结束而销毁。</li><li>是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。</li></ul><h1 id="Java-虚拟机栈（Java-栈）"><a href="#Java-虚拟机栈（Java-栈）" class="headerlink" title="Java 虚拟机栈（Java 栈）"></a>Java 虚拟机栈（Java 栈）</h1><h2 id="Java-虚拟机栈的定义"><a href="#Java-虚拟机栈的定义" class="headerlink" title="Java 虚拟机栈的定义"></a>Java 虚拟机栈的定义</h2><p>Java 虚拟机栈是描述 Java 方法运行过程的内存模型。</p><p>Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口信息</li><li>……</li></ul><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/jvm-stack.jpg" alt="jvm-stack"></p><h2 id="压栈出栈过程"><a href="#压栈出栈过程" class="headerlink" title="压栈出栈过程"></a>压栈出栈过程</h2><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p><p>Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p><p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p><blockquote><p>由于 Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。</p></blockquote><h2 id="Java-虚拟机栈的特点"><a href="#Java-虚拟机栈的特点" class="headerlink" title="Java 虚拟机栈的特点"></a>Java 虚拟机栈的特点</h2><ul><li>局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</li><li>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。<ul><li>StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</li><li>OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。</li></ul></li><li>Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。</li></ul><blockquote><p>出现 StackOverFlowError 时，内存空间可能还有很多。</p></blockquote><h1 id="本地方法栈（C-栈）"><a href="#本地方法栈（C-栈）" class="headerlink" title="本地方法栈（C 栈）"></a>本地方法栈（C 栈）</h1><h2 id="本地方法栈的定义"><a href="#本地方法栈的定义" class="headerlink" title="本地方法栈的定义"></a>本地方法栈的定义</h2><p>本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p><h2 id="栈帧变化过程"><a href="#栈帧变化过程" class="headerlink" title="栈帧变化过程"></a>栈帧变化过程</h2><p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。</p><p>方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。</p><blockquote><p>如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。</p></blockquote><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><p>堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。</p><h2 id="堆的特点"><a href="#堆的特点" class="headerlink" title="堆的特点"></a>堆的特点</h2><ul><li>线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。</li><li>在虚拟机启动时创建。</li><li>是垃圾回收的主要场所。</li><li>进一步可分为：新生代（Eden 区：<code>From Survior</code>，<code>To Survivor</code>）、老年代。</li></ul><p>不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。</p><p>堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。</p><blockquote><p>Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。</p></blockquote><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="方法区的定义"><a href="#方法区的定义" class="headerlink" title="方法区的定义"></a>方法区的定义</h2><p>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：</p><ul><li>已经被虚拟机加载的类信息</li><li>常量</li><li>静态变量</li><li>即时编译器编译后的代码</li></ul><h2 id="方法区的特点"><a href="#方法区的特点" class="headerlink" title="方法区的特点"></a>方法区的特点</h2><ul><li>线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。</li><li>永久代。 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。</li><li>内存回收效率低。 方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。</li><li>Java 虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。</li></ul><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。</p><p>当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 <code>intern()</code> 方法就能在运行期间向常量池中添加字符串常量。</p><h1 id="直接内存（堆外内存）"><a href="#直接内存（堆外内存）" class="headerlink" title="直接内存（堆外内存）"></a>直接内存（堆外内存）</h1><p>直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。</p><h2 id="操作直接内存"><a href="#操作直接内存" class="headerlink" title="操作直接内存"></a>操作直接内存</h2><p>在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的<code>DirectByteBuffer</code>对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。</p><p>直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。</p><h2 id="直接内存与堆内存比较"><a href="#直接内存与堆内存比较" class="headerlink" title="直接内存与堆内存比较"></a>直接内存与堆内存比较</h2><ul><li>直接内存申请空间耗费更高的性能</li><li>直接内存读取 IO 的性能要优于普通的堆内存。</li><li>直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO</li><li>堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO</li></ul><blockquote><p>服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现<code>OutOfMemoryError</code>异常。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS 原理以及 AQS 同步组件总结</title>
      <link href="posts/AQS%20%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%20AQS%20%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93/"/>
      <url>posts/AQS%20%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%20AQS%20%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="AQS-简单介绍"><a href="#AQS-简单介绍" class="headerlink" title="AQS 简单介绍"></a>AQS 简单介绍</h2><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。</p><p>![enter image description here](<a href="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java">https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java</a> 程序员必备：并发知识系统总结/AQS.png)</p><p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AQS 为构建锁和同步器提供了一些通用功能的是实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code>(jdk1.7) 等等皆是基于 AQS 的。</p><h1 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h1><blockquote><p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p></blockquote><p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p><h2 id="AQS-原理概览"><a href="#AQS-原理概览" class="headerlink" title="AQS 原理概览"></a>AQS 原理概览</h2><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>看个 AQS(<code>AbstractQueuedSynchronizer</code>)原理图：</p><p>![enter image description here](<a href="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java">https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java</a> 程序员必备：并发知识系统总结/CLH.png)</p><p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>状态信息通过 <code>protected</code> 类型的<code>getState()</code>，<code>setState()</code>，<code>compareAndSetState()</code> 进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h3><p>AQS 定义两种资源共享方式</p><p><strong>1)Exclusive</strong>（独占）</p><p>只有一个线程能执行，如 <code>ReentrantLock</code>。又可分为公平锁和非公平锁，<code>ReentrantLock</code> 同时支持两种锁，下面以 <code>ReentrantLock</code> 对这两种锁的定义做介绍：</p><ul><li><strong>公平锁</strong> ：按照线程在队列中的排队顺序，先到者先拿到锁</li><li><strong>非公平锁</strong> ：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li></ul><blockquote><p>说明：下面这部分关于 <code>ReentrantLock</code> 源代码内容节选自：<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2">https://www.javadoop.com/post/AbstractQueuedSynchronizer-2</a> ，这是一篇很不错文章，推荐阅读。</p></blockquote><p><strong>下面来看 <code>ReentrantLock</code> 中相关的源代码：</strong></p><p><code>ReentrantLock</code> 默认采用非公平锁，因为考虑获得更好的性能，通过 <code>boolean</code> 来决定是否用公平锁（传入 true 用公平锁）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code> 中公平锁的 <code>lock</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; AbstractQueuedSynchronizer.acquire(int arg)</span><br><span class="line">    public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc &#x3D; c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非公平锁的 <code>lock</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        &#x2F;&#x2F; 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; AbstractQueuedSynchronizer.acquire(int arg)</span><br><span class="line">    public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="line"> * subclasses, but both need nonfair try for trylock method.</span><br><span class="line"> *&#x2F;</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里没有对阻塞队列进行判断</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：公平锁和非公平锁只有两处不同：</p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 <code>tryAcquire</code> 方法，在 <code>tryAcquire</code> 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><p><strong>2)Share</strong>（共享）</p><p>多个线程可同时执行，如 <code>Semaphore/CountDownLatch</code>。<code>Semaphore</code>、<code>CountDownLatCh</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 我们都会在后面讲到。</p><p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p><h3 id="AQS-底层使用了模板方法模式"><a href="#AQS-底层使用了模板方法模式" class="headerlink" title="AQS 底层使用了模板方法模式"></a>AQS 底层使用了模板方法模式</h3><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。</p><blockquote><p>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。</p><p>举个很简单的例子假如我们要去一个地方的步骤是：购票 <code>buyTicket()</code>-&gt;安检 <code>securityCheck()</code>-&gt;乘坐某某工具回家 <code>ride()</code> -&gt;到达目的地 <code>arrive()</code>。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了<code>ride()</code>方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 <code>ride()</code>方法。</p></blockquote><p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()&#x2F;&#x2F;该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">tryAcquire(int)&#x2F;&#x2F;独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br><span class="line">tryRelease(int)&#x2F;&#x2F;独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br><span class="line">tryAcquireShared(int)&#x2F;&#x2F;共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">tryReleaseShared(int)&#x2F;&#x2F;共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以 <code>ReentrantLock</code> 为例，state 初始化为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code>独占该锁并将 state+1。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p><p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，state 也初始化为 N（也可以不初始化为 N，不初始化为 N,state 减到 0 也会从 await()返回）。这 N 个子线程是并行执行的，每个子线程执行完后 <code>countDown()</code> 一次，state 会 CAS(Compare and Swap)减 1。等到 <code>state=0</code>，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p><p>所以 <code>CountDownLatch</code> 可以做倒计数器，减到 0 后唤醒的线程可以对线程池进行处理，比如关闭线程池。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码+底层数据结构分析</title>
      <link href="posts/ConcurrentHashMap%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>posts/ConcurrentHashMap%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ConcurrentHashMap-1-7"><a href="#ConcurrentHashMap-1-7" class="headerlink" title="ConcurrentHashMap 1.7"></a>ConcurrentHashMap 1.7</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="https://javaguide.cn/assets/img/image-20200405151029416.1a3ef546.png" alt="Java 7 ConcurrentHashMap 存储结构"></p><p>Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code>  组合，而每一个 <code>Segment</code> 是一个类似于 HashMap 的结构，所以每一个 <code>HashMap</code> 的内部可以进行扩容。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment"> * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认并发级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>接着看下这个有参构造函数的内部实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="comment">// 2的多少次方</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录段偏移量</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// 记录段掩码</span></span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，设置 segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li><li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 segmentShift 偏移量，这个值为【容量 =  2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li><li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.</li><li><strong>初始化 segments[0]<strong>，</strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩容。</li></ol><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>接着上面的初始化参数继续查看 put 方法源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment"> * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">// 判断 u 位置的 Segment 是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span></span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="comment">// 计算扩容阀值</span></span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        <span class="comment">// 创建一个 cap 容量的 HashEntry 数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 自旋检查 u 位置的 Segment 是否为null</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用CAS 赋值，只会成功一次</span></span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程。</p><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p></li><li><p>如果指定位置的 Segment 为空，则初始化这个 Segment.</p><p><strong>初始化 Segment 流程：</strong></p><ol><li>检查计算得到的位置的 Segment 是否为null.</li><li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li><li>再次检查计算得到的指定位置的 Segment 是否为null.</li><li>使用创建的 HashEntry 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li></ol></li><li><p>Segment.put 插入 key,value 值。</p></li></ol><p>上面探究了获取 Segment 段和初始化 Segment 段的操作。最后一行的 Segment 的 put 方法还没有查看，继续分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p>tryLock() 获取锁，获取不到使用  <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p></li><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p><p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接头插法插入。</li></ol><p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p><ol><li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li><li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接链表头插法插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p></li></ol><p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="comment">// 自旋获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            <span class="comment">// 自旋达到指定次数后，阻塞等到只到获取到锁</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容 rehash"></a>扩容 rehash</h2><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 老容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 新容量，扩大两倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的扩容阀值 </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 如果是链表了</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">                <span class="comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="keyword">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="comment">// 遍历剩余元素，头插法到指定 k 位置。</span></span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入新的节点</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。</p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>到这里就很简单了，get 方法只需要两步即可。</p><ol><li>计算得到 key 的存放位置。</li><li>遍历指定位置查找相同 key 的 value 值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 计算得到 key 的存放位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历查找到相同 key 的 value。</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ConcurrentHashMap-1-8"><a href="#ConcurrentHashMap-1-8" class="headerlink" title="ConcurrentHashMap 1.8"></a>ConcurrentHashMap 1.8</h1><h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="https://javaguide.cn/assets/img/java8_concurrenthashmap.772ed191.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）"></p><p>可以发现 Java8 的 ConcurrentHashMap  相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h2 id="初始化-initTable"><a href="#初始化-initTable" class="headerlink" title="初始化 initTable"></a>初始化 initTable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        ／／　如果 sizeCtl &lt; <span class="number">0</span> ,说明另外的线程执行CAS 成功，正在进行初始化。</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 让出 CPU 使用权</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从源码中可以发现 ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p><ol><li>-1  说明正在初始化</li><li>-N 说明有N-1个线程正在进行扩容</li><li>表示 table 初始化大小，如果 table 没有初始化</li><li>表示 table 容量，如果 table　已经初始化。</li></ol><h2 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h2><p>直接过一遍 put 源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key 和 value 不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f = 目标位置元素</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;<span class="comment">// fh 后面存放目标位置的元素 hash 值</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 使用 synchronized 加锁加入节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环加入新的或者覆盖节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ol><h2 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h2><p>get 流程比较简单，直接过一遍源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// key 所在的 hash 位置</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果指定位置元素存在，头结点hash值相同</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="comment">// key hash 值相等，key值相同，直接返回元素 value</span></span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 是链表，遍历查找</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结一下 get 过程：</p><ol><li>根据 hash 值计算位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li><li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li><li>如果是链表，遍历查找之。</li></ol><p>总结：</p><p>总的来说 ConcurrentHashMap 在 Java8 中相对于 Java7 来说变化还是挺大的，</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p><p>Java8 中的 ConcurrentHashMap  使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了  <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p><p>有些同学可能对 Synchronized 的性能存在疑问，其实 Synchronized 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 Synchronized 的<strong>锁升级</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程的基础</title>
      <link href="posts/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
      <url>posts/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h1><p>堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java中几乎所有的对象实例都在这里分配内存。</p><p>方法区与堆一样，也是各个线程共享的一块内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p><img src="https://i.loli.net/2021/09/22/GjdBHMhAmNk184a.png" alt="image-20210922084326941"></p><h1 id="并发编程难点"><a href="#并发编程难点" class="headerlink" title="并发编程难点"></a>并发编程难点</h1><h2 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h2><p>一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><ul><li>操作系统做任务切换，可以发生在任何一条CPU指令执行完成后；</li><li>CPU能保证的原子操作是指令级别的，而不是高级语言的操作符。</li></ul><p><img src="https://i.loli.net/2021/09/22/l39O6LVABmI85wr.png" alt="image-20210922084824324"></p><p>n++操作具体分三步：</p><ul><li>首先将n（0）加载到寄存器 </li><li>n执行加一操作</li><li>将n（1）写入内存</li></ul><p>假设此时系统中出现两个线程，线程1先将n（0）加载到寄存器中后进行了线程切换，线程2也将n（0）加载到寄存器中，接着线程2对n进行加一操作，将n（1）写入内存后进行线程切换，切换到线程1的时候需要恢复中断数据，即n （0），然后执行加一操作，将n（1）写入内存。</p><p>线程1和线程2都执行了n++操作，最终结果却为1，这就是出现了原子性问题。</p><h2 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h2><ul><li>可见性是指一个线程对共享变量的修改，另外一个线程能够立刻看到；</li><li>可见性问题是由CPU的缓存导致的，多核CPU均有各自的缓存，这些缓存均要与内存进行同步。</li></ul><p><img src="https://i.loli.net/2021/09/23/qQcmCTg2lSPfVAt.png" alt="image-20210923085407505"></p><p>假设有两个线程，线程A想要修改数据，需要先将内存的数据加载到缓存里，在缓存里修改X，最后同步到内存空间。线程B也做相同的操作。然而正是因为多线程，在各自缓存中修改，对其他不可见，从而产生问题。</p><h2 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h2><ul><li>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序；</li><li>重排序不会影响单线程的执行结果，但是在并发情况下，可能会出现诡异的BUG。</li></ul><p><img src="https://i.loli.net/2021/09/23/6OiNVdSL3kmMJE8.png" alt="image-20210923090719486"></p><p>基于图中代码，首先判断instance是否为null，如果是分配一块内存空间R，然后对R进行初始化，最后把R的地址给instance。在编译时，编译器可能处于性能的考虑对指令进行重排序，在单线程下不受影响，然而在多线程环境中，可能会出现问题。</p><p>假设有两个线程，在线程A中判断instance是否为null，如果是分配一块内存空间R，然后把R的地址赋给instance，在此时线程进行了切换，线程B中首先也需要判断instance是否为null，因为此时的instance已经分配内存，则线程B判断为否，返回instance。这样就发生了重排序的问题。</p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><h2 id="并发编程的关键目标"><a href="#并发编程的关键目标" class="headerlink" title="并发编程的关键目标"></a>并发编程的关键目标</h2><p>并发编程需要处理两个关键问题，即线程之间如何通信和同步。</p><ul><li>通信：指线程之间以何种机制来交换信息；</li><li>同步：指程序中用于控制不同线程之间的操作发生的相对顺序的机制。</li></ul><h2 id="并发编程的内存模型"><a href="#并发编程的内存模型" class="headerlink" title="并发编程的内存模型"></a>并发编程的内存模型</h2><p>共有两种并发编程模型：共享内存模型、消息传递模型，Java采用的是前者。</p><ul><li>在共享内存模型下，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信；</li><li>在共享内存模型下，同步是显示进行的，程序员必须显示指定某段代码需要在线程之间互斥执行。</li></ul><h2 id="内存模型JMM"><a href="#内存模型JMM" class="headerlink" title="内存模型JMM"></a>内存模型JMM</h2><p>JMM是Java Memory Model的缩写，Java线程之间的通信由JMM控制，即JMM决定一个线程对共享变量的写入何时对另一个线程可见。JMM定义了线程和主内存之间的抽象关系，通过控制主内存与每个本地内存（抽象概念）之间的交互，JMM为Java程序员提供了内存可见性的保证。</p><p>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p><img src="https://i.loli.net/2021/09/23/J8FpRl7iLcQq5Ea.png" alt="image-20210923093805995"></p><h2 id="源代码与指令间的重排序"><a href="#源代码与指令间的重排序" class="headerlink" title="源代码与指令间的重排序"></a>源代码与指令间的重排序</h2><p>为了提高性能，编译器和处理器常常会对指令做重排序。重排序有3种类型，其中后2种都是处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。</p><ol><li>编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p><img src="https://i.loli.net/2021/09/23/JvFpf61GXBtwR5W.png" alt="image-20210923100242051"></p><h2 id="重排序对可见性的影响"><a href="#重排序对可见性的影响" class="headerlink" title="重排序对可见性的影响"></a>重排序对可见性的影响</h2><p>参考下表，虽然处理器执行的顺序是A1-&gt;A2，但是从内存角度来看，实际发生的顺序是A2-&gt;A1。这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此它们都会允许对写-读操作执行重排序。</p><table><thead><tr><th align="center"></th><th align="center">Processor A</th><th align="center">Processor B</th></tr></thead><tbody><tr><td align="center">代码</td><td align="center">a = 1; // A1<br/>x = b; // A2</td><td align="center">b = 2; // B1<br/>y = a; // B2</td></tr><tr><td align="center">结果</td><td align="center">初始状态：a=0;b=0;<br/>可能出现：x=0;y=0;</td><td align="center"></td></tr></tbody></table><p><img src="https://i.loli.net/2021/09/23/14Dbd9anqwztCY8.png" alt="image-20210923100715113"></p><h2 id="如何解决重排序带来的问题"><a href="#如何解决重排序带来的问题" class="headerlink" title="如何解决重排序带来的问题"></a>如何解决重排序带来的问题</h2><p>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求编译器在生成指令序列时，插入特定类型的<strong>内存屏障</strong>（Memory Barries /Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。<br>由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不同。</p><p>​       CPU内存屏障：</p><ol><li><p>LoadLoad：禁止读和读的重排序；</p></li><li><p>StoreStore：禁止写和写的重排序；</p></li><li><p>LoadStore：禁止读和写的重排序；</p></li><li><p>StoreLoad：禁止写和读的重排序。</p></li></ol><p>  Java内存屏障：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>; <span class="comment">// LoadLoad + LoadStore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>; <span class="comment">// StoreStore + LoadStore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>; <span class="comment">// loadFence() + storeFence() + StoreLoad</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>JMM使用happens-before规则来阐述操作之间的内存可见性，以及什么时候不能重排序。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。换个角度来说，如果A happens-before B，则意味着A的执行结果必须对B可见，也就是保证跨线程的内存可见性。其中，前4条规则与程序员密切相关。</p><ol><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作；</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读；</li><li>synchronized规则：对一个锁的解锁，happens-before于随后对这个锁的加锁；</li><li>传递性：若A happens-before B，且B happens-before C，则A happens-before C；</li><li>start()规则：若线程A执行ThreadB.start()，则线程A的这个操作happens-before于线程B中的任意操作；</li><li>join()规则：若线程A执行ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()的成功返回。</li></ol><p>举个例子：<br>假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens-before规则，这个过程建立的happens-before关系可以<br>分为3类：</p><ol><li>根据顺序规则，1 happens-before 2，3 happens-before 4；</li><li>根据volatile规则，2 happens-before 3；</li><li>根据happens-before的传递性规则，1 happens-before 4。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">int</span> i = a; <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="volatile的基本特性"><a href="#volatile的基本特性" class="headerlink" title="volatile的基本特性"></a>volatile的基本特性</h2><ul><li>可见性：对一个volatile变量的读，总是能看到对这个volatile变量最后的写入；</li><li>原子性：对任意单个volatile变量的读/写具有原子性，但类似volatile++这种复合操作不具有原子性。</li></ul><h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><ul><li>写内存语义：当写一个volatile变量时，JMM会把该线程本地内存中的共享变量的值刷新到主内存；</li><li>读内存语义：当读一个volatile变量时，JMM会把该线程本地内存置为无效，使其从主内存中读取共<br>享变量。</li></ul><h2 id="volatile的实现机制"><a href="#volatile的实现机制" class="headerlink" title="volatile的实现机制"></a>volatile的实现机制</h2><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障；</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障；</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障；</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><h2 id="volatile与锁的对比"><a href="#volatile与锁的对比" class="headerlink" title="volatile与锁的对比"></a>volatile与锁的对比</h2><p>volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上锁比volatile更强大，在可伸缩性和执行性能上volatile更有优势。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><ul><li>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中；</li><li>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。</li></ul><h2 id="锁的实现机制"><a href="#锁的实现机制" class="headerlink" title="锁的实现机制"></a>锁的实现机制</h2><ul><li>synchronized：采用 “CAS + Mark Word” 实现，存在锁升级的情况；</li><li>Lock：采用 “CAS + volatile” 实现，存在锁降级的情况，核心是AQS。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码+底层数据结构分析</title>
      <link href="posts/HashMap%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>posts/HashMap%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h1><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p><p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><h1 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h1><h2 id="DK1-8-之前"><a href="#DK1-8-之前" class="headerlink" title="DK1.8 之前"></a>DK1.8 之前</h2><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="jdk1.8之前的内部结构"></p><h2 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h2><p>相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。</p><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。相关源码这里就不贴了，重点关注 <code>treeifyBin()</code>方法即可！</p><p><img src="https://oscimg.oschina.net/oscnet/up-bba283228693dae74e78da1ef7a9a04c684.png" alt="img"></p><p><strong>类的属性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>loadFactor 加载因子</strong></p><p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p></li><li><p><strong>threshold</strong></p><p><strong>threshold = capacity * loadFactor</strong>，<strong>当 Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p></li></ul><p><strong>Node 节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>树节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="keyword">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>putMapEntries 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对 putVal 方法添加元素的分析如下：</strong></p><ol><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ol><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/put%E6%96%B9%E6%B3%95.png" alt=" "></p><p>说明:上图有两个小问题：</p><ul><li>直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行（<a href="https://github.com/Snailclimb/JavaGuide/issues/608">issue#608</a></li></ul><p><a href="https://github.com/Snailclimb/JavaGuide/issues/608"> </a></p><p><a href="https://github.com/Snailclimb/JavaGuide/issues/608"> (opens new window)</a>）。</p><p>当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。参考 HashMap 的 <code>treeifyBin()</code> 方法（<a href="https://github.com/Snailclimb/JavaGuide/issues/1087">issue#1087</a></p><p><a href="https://github.com/Snailclimb/JavaGuide/issues/1087"> </a><a href="https://github.com/Snailclimb/JavaGuide/issues/1087"> (opens new window)</a>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>我们再来对比一下 JDK1.7 put 方法的代码</strong></p><p><strong>对于 put 方法的分析如下：</strong></p><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(table == EMPTY_TABLE)</span> </span>&#123;</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 先遍历</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 再插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h2><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HashMap-常用方法测试"><a href="#HashMap-常用方法测试" class="headerlink" title="HashMap 常用方法测试"></a>HashMap 常用方法测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 键不能重复，值可以重复</span></span><br><span class="line">        map.put(<span class="string">&quot;san&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wu&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王2&quot;</span>);<span class="comment">// 老王被覆盖</span></span><br><span class="line">        map.put(<span class="string">&quot;lao&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------直接输出hashmap:-------&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历HashMap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.获取Map中的所有键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 2.获取Map中所有值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">            System.out.print(value+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot;：&quot;</span> + map.get(key)+<span class="string">&quot;   &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span></span><br><span class="line"><span class="comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class="line">        <span class="comment">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class="line">        <span class="comment">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class="line">        <span class="comment">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap其他常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after map.size()：&quot;</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;san&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.remove()：&quot;</span>+map);</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        System.out.println(map.replace(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.replace(si, 李四2):&quot;</span>+map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyOnWriteArrayList 源码解析和设计思路</title>
      <link href="posts/Copy/"/>
      <url>posts/Copy/</url>
      
        <content type="html"><![CDATA[<p>在<code> ArrayList</code> 的类注释上，JDK 就提醒了我们，如果要把 ArrayList 作为共享变量的话，是线程不安全的，推荐我们自己加锁或者使用 <code>Collections.synchronizedList </code>方法，其实 JDK 还提供了另外一种线程安全的 <code>List</code>，叫做 <code>CopyOnWriteArrayList</code>，这个<code> List</code> 具有以下特征：</p><p>1.线程安全的，多线程环境下可以直接使用，无需加锁；</p><p>2.通过锁 + 数组拷贝 + volatile 关键字保证了线程安全；</p><p>3.每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>从整体架构上来说，<code>CopyOnWriteArrayList</code> 数据结构和<code> ArrayList</code> 是一致的，底层是个数组，只不过 <code>CopyOnWriteArrayList </code>在对数组进行操作的时候，基本会分四步走：</p><ol><li>加锁；</li><li>从原数组中拷贝出新数组；</li><li>在新数组上进行操作，并把新数组赋值给数组容器；</li><li>解锁。</li></ol><p>除了加锁之外，<code>CopyOnWriteArrayList</code> 的底层数组还被 volatile 关键字修饰，意思是一旦数组被修改，其它线程立马能够感知到，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>整体上来说，<code>CopyOnWriteArrayList </code>就是利用锁 + 数组拷贝 + volatile 关键字保证了 List 的线程安全。</p><h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><p>我们看看从<code>CopyOnWriteArrayList</code>的类注释上能得到哪些信息：</p><ol><li>所有的操作都是线程安全的，因为操作都是在新拷贝数组上进行的；</li><li>数组的拷贝虽然有一定的成本，但往往比一般的替代方案效率高；</li><li>迭代过程中，不会影响到原来的数组，也不会抛出 ConcurrentModificationException 异常。</li></ol><p>接着我们来看下 <code>CopyOnWriteArrayList</code> 的核心方法源码。</p><h1 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h1><p>新增有很多种情况，比如说：新增到数组尾部、新增到数组某一个索引位置、批量新增等等，操作的思路还是我们开头说的四步，我们拿新增到数组尾部的方法举例，来看看底层源码的实现：</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码+扩容机制分析</title>
      <link href="posts/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
      <url>posts/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList-简介"><a href="#ArrayList-简介" class="headerlink" title="ArrayList 简介"></a>ArrayList 简介</h1><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p><p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li><li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li></ul><h2 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别?"></a>Arraylist 和 Vector 的区别?</h2><ol><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[ ]</code>存储，线程安全的。</li></ol><h2 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h2><ol><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h1 id="ArrayList-核心源码解读"><a href="#ArrayList-核心源码解读" class="headerlink" title="ArrayList 核心源码解读"></a>ArrayList 核心源码解读</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">      <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，</span></span><br><span class="line"><span class="comment">     也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class="line"><span class="comment">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class="line"><span class="comment">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class="line"><span class="comment">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class="line"><span class="comment">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">            <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="comment">//从列表中删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     *返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class="line"><span class="comment">     *返回的迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="ArrayList-扩容机制分析"><a href="#ArrayList-扩容机制分析" class="headerlink" title="ArrayList 扩容机制分析"></a>ArrayList 扩容机制分析</h1><h2 id="先从-ArrayList-的构造函数说起"><a href="#先从-ArrayList-的构造函数说起" class="headerlink" title="先从 ArrayList 的构造函数说起"></a>先从 ArrayList 的构造函数说起</h2><p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p><blockquote><p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData 。</p></blockquote><h2 id="一步一步分析-ArrayList-扩容机制"><a href="#一步一步分析-ArrayList-扩容机制" class="headerlink" title="一步一步分析 ArrayList 扩容机制"></a>一步一步分析 ArrayList 扩容机制</h2><p>这里以无参构造函数创建的 ArrayList 为例分析</p><h3 id="先来看-add-方法"><a href="#先来看-add-方法" class="headerlink" title="先来看 add 方法"></a>先来看 <code>add</code> 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h3 id="再来看看-ensureCapacityInternal-方法"><a href="#再来看看-ensureCapacityInternal-方法" class="headerlink" title="再来看看 ensureCapacityInternal() 方法"></a>再来看看 <code>ensureCapacityInternal()</code> 方法</h3><p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p><blockquote><p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p></blockquote><h3 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a><code>ensureExplicitCapacity()</code> 方法</h3><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h3 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow() 方法"></a><code>grow()</code> 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>int  newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList  每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于  oldCapacity /2。对于大数据的 2  进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p><ul><li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity =  minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE  大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li><li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if  判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return  true,size 增为 11。</li><li>以此类推······</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li>Java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>Java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>Java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h3 id="hugeCapacity-方法。"><a href="#hugeCapacity-方法。" class="headerlink" title="hugeCapacity() 方法。"></a><code>hugeCapacity()</code> 方法。</h3><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="System-arraycopy-和-Arrays-copyOf-方法"><a href="#System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="System.arraycopy() 和 Arrays.copyOf()方法"></a><code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h2><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><h3 id="System-arraycopy-方法"><a href="#System-arraycopy-方法" class="headerlink" title="System.arraycopy() 方法"></a><code>System.arraycopy()</code> 方法</h3><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   复制数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> src 源数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> srcPos 源数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> destPos 目标数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 要复制的数组元素的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写一个简单的方法测试以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraycopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 99 2 3 0 0 0 0 0</span><br></pre></td></tr></table></figure><h3 id="Arrays-copyOf-方法"><a href="#Arrays-copyOf-方法" class="headerlink" title="Arrays.copyOf()方法"></a><code>Arrays.copyOf()</code>方法</h3><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOf(<span class="keyword">int</span>[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">   <span class="comment">// 申请一个新的数组</span></span><br><span class="line">       <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line"><span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span></span><br><span class="line">       System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                        Math.min(original.length, newLength));</span><br><span class="line">       <span class="keyword">return</span> copy;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayscopyOfTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;b.length&quot;</span>+b.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="两者联系和区别"><a href="#两者联系和区别" class="headerlink" title="两者联系和区别"></a>两者联系和区别</h3><p><strong>联系：</strong></p><p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h2 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a><code>ensureCapacity</code>方法</h2><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p><p>我们通过下面的代码实际测试以下这个方法的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnsureCapacityTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;使用ensureCapacity方法前：&quot;</span>+(endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">使用ensureCapacity方法前：2158</span><br><span class="line">public class EnsureCapacityTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;();</span><br><span class="line">        final int N = 10000000;</span><br><span class="line">        list = new ArrayList&lt;Object&gt;();</span><br><span class="line">        long startTime1 = System.currentTimeMillis();</span><br><span class="line">        list.ensureCapacity(N);</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;使用ensureCapacity方法后：&quot;+(endTime1 - startTime1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用ensureCapacity方法后：1773</span><br></pre></td></tr></table></figure><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>ArrayList的扩容：</strong></p><p>　　<strong>扩容可分为两种情况：</strong></p><p>　　<strong>第一种情况，当ArrayList的容量为0时，此时添加元素的话，需要扩容，三种构造方法创建的ArrayList在扩容时略有不同：</strong></p><p>　　　　1.无参构造，创建ArrayList后容量为0，添加第一个元素后，容量变为10，此后若需要扩容，则正常扩容。</p><p>　　　　2.传容量构造，当参数为0时，创建ArrayList后容量为0，添加第一个元素后，容量为1，此时ArrayList是满的，下次添加元素时需正常扩容。</p><p>　　　　3.传列表构造，当列表为空时，创建ArrayList后容量为0，添加第一个元素后，容量为1，此时ArrayList是满的，下次添加元素时需正常扩容。</p><p>　　<strong>第二种情况，当ArrayList的容量大于0，并且ArrayList是满的时，此时添加元素的话，进行正常扩容，每次扩容到原来的1.5倍。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射详解</title>
      <link href="posts/%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/"/>
      <url>posts/%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h1><p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p><p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getFullName</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果不能获得<code>Person</code>类，只有一个<code>Object</code>实例，比如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么办？有童鞋会说：强制转型啊！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Person p = (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用<code>Person</code>类。不然，去掉<code>import</code>语句，你看能不能编译通过？</p><p>所以，<strong>反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法</strong>。</p><h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>除了<code>int</code>等基本类型外，Java的其他类型全部都是<code>class</code>（包括<code>interface</code>）。例如：</p><ul><li><code>String</code></li><li><code>Object</code></li><li><code>Runnable</code></li><li><code>Exception</code></li><li>…</li></ul><p>仔细思考，我们可以得出结论：<code>class</code>（包括<code>interface</code>）的本质是数据类型（<code>Type</code>）。无继承关系的数据类型无法赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number n = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// OK</span></span><br><span class="line">String s = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>而<code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p><p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。注意：这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。它长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = <span class="keyword">new</span> Class(String);</span><br></pre></td></tr></table></figure><p>这个<code>Class</code>实例是JVM内部创建的，如果我们查看JDK源码，可以发现<code>Class</code>类的构造方法是<code>private</code>，只有JVM能创建<code>Class</code>实例，我们自己的Java程序是无法创建<code>Class</code>实例的。</p><p>所以，JVM持有的每个<code>Class</code>实例都指向一个数据类型（<code>class</code>或<code>interface</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.String&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Random</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.util.Random&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Runnable</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.Runnable&quot;│</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><p>一个<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.String&quot;  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│package &#x3D; &quot;java.lang&quot;      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│super &#x3D; &quot;java.lang.Object&quot; │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│interface &#x3D; CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field &#x3D; value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method &#x3D; indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p><p>这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。</p><p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p><p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class;</span><br></pre></td></tr></table></figure><p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure><p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class cls1 = String.class;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls2 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> sameClass = cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意一下<code>Class</code>实例比较和<code>instanceof</code>的差别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure><p>用<code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较。</p><p>通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</p><p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printObjectInfo</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Class cls = obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要从<code>Class</code>实例获取获取的基本信息，参考下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="keyword">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Class name: java.lang.String</span><br><span class="line">Simple name: String</span><br><span class="line">Package name: java.lang</span><br><span class="line">is interface: false</span><br><span class="line">is enum: false</span><br><span class="line">is array: <span class="keyword">false</span></span><br><span class="line">is primitive: <span class="keyword">false</span></span><br><span class="line">Class name: java.lang.Runnable</span><br><span class="line">Simple name: Runnable</span><br><span class="line">Package name: java.lang</span><br><span class="line">is interface: true</span><br><span class="line">is enum: false</span><br><span class="line">is array: <span class="keyword">false</span></span><br><span class="line">is primitive: <span class="keyword">false</span></span><br><span class="line">Class name: java.time.Month</span><br><span class="line">Simple name: Month</span><br><span class="line">Package name: java.time</span><br><span class="line">is interface: false</span><br><span class="line">is enum: true</span><br><span class="line">is array: <span class="keyword">false</span></span><br><span class="line">is primitive: <span class="keyword">false</span></span><br><span class="line">Class name: [Ljava.lang.String;</span><br><span class="line">Simple name: String[]</span><br><span class="line">is interface: false</span><br><span class="line">is enum: false</span><br><span class="line">is array: <span class="keyword">true</span></span><br><span class="line">is primitive: <span class="keyword">false</span></span><br><span class="line">Class name: <span class="keyword">int</span></span><br><span class="line">Simple name: <span class="keyword">int</span></span><br><span class="line">is interface: false</span><br><span class="line">is enum: false</span><br><span class="line">is array: <span class="keyword">false</span></span><br><span class="line">is primitive: <span class="keyword">true</span> </span><br></pre></td></tr></table></figure><p>注意到数组（例如<code>String[]</code>）也是一种<code>Class</code>，而且不同于<code>String.class</code>，它的类名是<code>[Ljava.lang.String</code>。此外，JVM为每一种基本类型如int也创建了<code>Class</code>，通过<code>int.class</code>访问。</p><p>如果获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line">Class cls = String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure><p>上述代码相当于<code>new String()</code>。通过<code>Class.newInstance()</code>可以创建类实例，它的局限是：只能调用<code>public</code>的无参数构造方法。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用。</p><h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>Main.java</code>时，由于用到了<code>Main</code>，因此，JVM首先会把<code>Main.class</code>加载到内存。然而，并不会加载<code>Person.class</code>，除非程序执行到<code>create()</code>方法，JVM发现需要加载<code>Person</code>类时，才会首次加载<code>Person.class</code>。如果没有执行<code>create()</code>方法，那么<code>Person.class</code>根本就不会被加载。</p><p>这就是JVM动态加载<code>class</code>的特性。</p><p>动态加载<code>class</code>的特性对于Java程序非常重要。利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line">LogFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClassPresent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JVM为每个加载的<code>class</code>及<code>interface</code>创建了对应的<code>Class</code>实例来保存<code>class</code>及<code>interface</code>的所有信息；</p><p>获取一个<code>class</code>对应的<code>Class</code>实例后，就可以获取该<code>class</code>的所有信息；</p><p>通过Class实例获取<code>class</code>信息的方法称为反射（Reflection）；</p><p>JVM总是动态加载<code>class</code>，可以在运行期根据条件来控制加载class。</p><h1 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h1><p>对任意的一个<code>Object</code>实例，只要我们获取了它的<code>Class</code>，就可以获取它的一切信息。</p><p>我们先看看如何通过<code>Class</code>实例获取字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getFields()：获取所有public的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码首先获取<code>Student</code>的<code>Class</code>实例，然后，分别获取<code>public</code>字段、继承的<code>public</code>字段以及<code>private</code>字段，打印出的<code>Field</code>类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.score</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.name</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.grade</span><br></pre></td></tr></table></figure><p>一个<code>Field</code>对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><p>以<code>String</code>类的<code>value</code>字段为例，它的定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用反射获取该字段的信息，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Field f = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h2><p>利用反射拿到字段的一个<code>Field</code>实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p><p>例如，对于一个<code>Person</code>实例，我们可以先拿到<code>name</code>字段对应的<code>Field</code>，再获取这个实例的<code>name</code>字段的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码先获取<code>Class</code>实例，再获取<code>Field</code>实例，然后，用<code>Field.get(Object)</code>获取指定实例的指定字段的值。</p><p>运行代码，如果不出意外，会得到一个<code>IllegalAccessException</code>，这是因为<code>name</code>被定义为一个<code>private</code>字段，正常情况下，<code>Main</code>类无法访问<code>Person</code>类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用<code>Object value = f.get(p);</code>前，先写一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p><p>可以试着加上上述语句，再运行代码，就可以打印出<code>private</code>字段的值。</p><p>有童鞋会问：如果使用反射可以获取<code>private</code>字段的值，那么类的封装还有什么意义？</p><p>答案是正常情况下，我们总是通过<code>p.name</code>来访问<code>Person</code>的<code>name</code>字段，编译器会根据<code>public</code>、<code>protected</code>和<code>private</code>决定是否允许访问字段，这样就达到了数据封装的目的。</p><p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p><h2 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h2><p>通过Field实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p><p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的，其中第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，打印的<code>name</code>字段从<code>Xiao Ming</code>变成了<code>Xiao Hong</code>，说明通过反射可以直接修改字段的值。</p><p>同样的，修改非<code>public</code>字段，需要首先调用<code>setAccessible(true)</code>。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p><p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p><p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p><p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p><h1 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h1><p>我们已经能通过<code>Class</code>实例获取所有<code>Field</code>对象，同样的，可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="keyword">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码首先获取<code>Student</code>的<code>Class</code>实例，然后，分别获取<code>public</code>方法、继承的<code>public</code>方法以及<code>private</code>方法，打印出的<code>Method</code>类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.getScore(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.getName()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.getGrade(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>一个<code>Method</code>对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><h2 id="调用方法-1"><a href="#调用方法-1" class="headerlink" title="调用方法"></a>调用方法</h2><p>当我们获取到一个<code>Method</code>对象时，就可以对它进行调用。我们以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">String r = s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>如果用反射来调用<code>substring</code>方法，需要以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world </span><br></pre></td></tr></table></figure><p>注意到<code>substring()</code>有两个重载方法，我们获取的是<code>String substring(int)</code>这个方法。思考一下如何获取<code>String substring(int, int)</code>方法。</p><p>对<code>Method</code>实例调用<code>invoke</code>就相当于调用该方法，<code>invoke</code>的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p><h2 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h2><p>如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为<code>null</code>。我们以<code>Integer.parseInt(String)</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        Method m = Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12345</span> </span><br></pre></td></tr></table></figure><h2 id="调用非public方法"><a href="#调用非public方法" class="headerlink" title="调用非public方法"></a>调用非public方法</h2><p>和Field类似，对于非public方法，我们虽然可以通过<code>Class.getDeclaredMethod()</code>获取该方法实例，但直接对其调用将得到一个<code>IllegalAccessException</code>。为了调用非public方法，我们通过<code>Method.setAccessible(true)</code>允许其调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Method m = p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bob</span><br></pre></td></tr></table></figure><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>我们来考察这样一种情况：一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也覆写了<code>hello()</code>方法，那么，从<code>Person.class</code>获取的<code>Method</code>，作用于<code>Student</code>实例时，调用的方法到底是哪个？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        Method h = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行上述代码，发现打印出的是<code>Student:hello</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method m = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> Student());</span><br></pre></td></tr></table></figure><p>实际上相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>Java的反射API提供的Method对象封装了方法的所有信息：</p><p>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</p><p>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</p><p>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</p><p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</p><p>通过反射调用方法时，仍然遵循多态原则。</p><h1 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h1><p>我们通常使用<code>new</code>操作符创建新的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = Person.class.newInstance();</span><br></pre></td></tr></table></figure><p>调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</p><p>为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过Class实例获取Constructor的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p>注意<code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p><p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p><code>Constructor</code>对象封装了构造方法的所有信息；</p><p>通过<code>Class</code>实例的方法可以获取<code>Constructor</code>实例：<code>getConstructor()</code>，<code>getConstructors()</code>，<code>getDeclaredConstructor()</code>，<code>getDeclaredConstructors()</code>；</p><p>通过<code>Constructor</code>实例可以创建一个实例对象：<code>newInstance(Object... parameters)</code>； 通过设置<code>setAccessible(true)</code>来访问非<code>public</code>构造方法。</p><h1 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h1><p>当我们获取到某个<code>Class</code>对象时，实际上就获取到了一个类的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class; <span class="comment">// 获取到String的Class</span></span><br></pre></td></tr></table></figure><p>还可以用实例的<code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">Class cls = s.getClass(); <span class="comment">// s是String，因此获取到String的Class</span></span><br></pre></td></tr></table></figure><p>最后一种获取<code>Class</code>的方法是通过<code>Class.forName(&quot;&quot;)</code>，传入<code>Class</code>的完整类名获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class s &#x3D; Class.forName(&quot;java.lang.String&quot;);</span><br></pre></td></tr></table></figure><p>这三种方式获取的<code>Class</code>实例都是同一个实例，因为JVM对每个加载的<code>Class</code>只创建一个<code>Class</code>实例来表示它的类型。</p><h2 id="获取父类的Class"><a href="#获取父类的Class" class="headerlink" title="获取父类的Class"></a>获取父类的Class</h2><p>有了<code>Class</code>实例，我们还可以获取它的父类的<code>Class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class i = Integer.class;</span><br><span class="line">        Class n = i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        Class o = n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行上述代码，可以看到，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code>。除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</p><h2 id="获取interface"><a href="#获取interface" class="headerlink" title="获取interface"></a>获取interface</h2><p>由于一个类可能实现一个或多个接口，通过<code>Class</code>我们就可以查询到实现的接口类型。例如，查询<code>Integer</code>实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行上述代码可知，<code>Integer</code>实现的接口有：</p><ul><li>java.lang.Comparable</li><li>java.lang.constant.Constable</li><li>java.lang.constant.ConstantDesc</li></ul><p>要特别注意：<code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class.getSuperclass();</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Integer</code>的父类是<code>Number</code>，<code>Number</code>实现的接口是<code>java.io.Serializable</code>。</p><p>此外，对所有<code>interface</code>的<code>Class</code>调用<code>getSuperclass()</code>返回的是<code>null</code>，获取接口的父接口要用<code>getInterfaces()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(java.io.DataInputStream.class.getSuperclass()); <span class="comment">// java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span></span><br><span class="line">System.out.println(java.io.Closeable.class.getSuperclass()); <span class="comment">// null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span></span><br></pre></td></tr></table></figure><p>如果一个类没有实现任何<code>interface</code>，那么<code>getInterfaces()</code>返回空数组。</p><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p>当我们判断一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object n = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDouble = n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> isInteger = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isNumber = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isSerializable = n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>通过<code>Class</code>对象可以获取继承关系：</p><ul><li><code>Class getSuperclass()</code>：获取父类类型；</li><li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li></ul><p>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>我们来比较Java的<code>class</code>和<code>interface</code>的区别：</p><ul><li>可以实例化<code>class</code>（非<code>abstract</code>）；</li><li>不能实例化<code>interface</code>。</li></ul><p>所有<code>interface</code>类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharSequence cs = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure><p>有没有可能不编写实现类，直接在运行期创建某个<code>interface</code>的实例呢？</p><p>这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p><p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例，转型为接口并调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello hello = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式就是我们通常编写代码的方式。</p><p>还有一种方式是动态代码，我们仍然先定义了接口<code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建了一个<code>Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p><p>一个最简单的动态代理实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在运行期动态创建一个<code>interface</code>实例的方法如下：</p><ol><li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li><li>通过<code>Proxy.newProxyInstance()</code>创建<code>interface</code>实例，它需要3个参数：<ol><li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li></ol></li><li>将返回的<code>Object</code>强制转型为接口。</li></ol><p>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDynamicProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDynamicProxy</span><span class="params">(InvocationHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="keyword">this</span>,</span><br><span class="line">           Hello.class.getMethod(<span class="string">&quot;morning&quot;</span>, String.class),</span><br><span class="line">           <span class="keyword">new</span> Object[] &#123; name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；</p><p>动态代理是通过<code>Proxy</code>创建代理对象，然后将接口方法“代理”给<code>InvocationHandler</code>完成的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="posts/Java%E9%9B%86%E5%90%88/"/>
      <url>posts/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h1><p>Java集合大致可分为Set、List、Queue和Map四种体系，其中Set代表无序、不可重复的集合；List代表有序、重复的集合；而Map则代表具有映射关系的集合，Java 5又增加了Queue体系集合，代表一种队列集合实现。集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所有的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，Java 5还在java.util.concurrent包下提供了一些多线程支持的集合类。</p><p><img src="https://i.loli.net/2021/11/02/sOa1Au53zKchGnL.png" alt="image-20211102092101320"></p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet是Set接口的典型实现，HashSet不能保证元素的排列顺序，它是非线程安全的，并且集合内元素的值可以是null。HashSet底层是由HashMap实现的，它将元素存到了HashMap的key上，而对应的value则是一个空对象。</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>TreeSet可以确保集合元素处于排序状态，TreeSet支持自然排序和定制排序两种排序方式，它的底层是由TreeMap实现的。TreeSet也是非线程安全的，但是它内部元素的值不能为null。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合使用注意事项</title>
      <link href="posts/Java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>posts/Java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</strong></p></blockquote><p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</p><p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 <code>java.util.concurrent</code> 包下的某些集合（<code>ConcurrentLinkedQueue</code> 、<code>ConcurrentHashMap</code>…）。</p><p>下面是 <code>ConcurrentHashMap</code> 的 <code>size()</code> 方法和 <code>isEmpty()</code> 方法的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sumCount() &lt;= <span class="number">0L</span>; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="集合转-Map"><a href="#集合转-Map" class="headerlink" title="集合转 Map"></a>集合转 Map</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">     <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; bookList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">bookList.add(<span class="keyword">new</span> Person(<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;18163138123&quot;</span>));</span><br><span class="line">bookList.add(<span class="keyword">new</span> Person(<span class="string">&quot;martin&quot;</span>,<span class="keyword">null</span>));</span><br><span class="line"><span class="comment">// 空指针异常</span></span><br><span class="line">bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们来解释一下原因。</p><p>首先，我们来看 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法 ，可以看到其内部调用了 <code>Map</code> 接口的 <code>merge()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U, M extends Map&lt;K, U&gt;&gt;</span><br><span class="line">Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">                            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; mergeFunction,</span><br><span class="line">                            Supplier&lt;M&gt; mapSupplier) &#123;</span><br><span class="line">    BiConsumer&lt;M, T&gt; accumulator</span><br><span class="line">            = (map, element) -&gt; map.merge(keyMapper.apply(element),</span><br><span class="line">                                          valueMapper.apply(element), mergeFunction);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Map</code> 接口的 <code>merge()</code> 方法如下，这个方法是接口中的默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    Objects.requireNonNull(value);</span><br><span class="line">    V oldValue = get(key);</span><br><span class="line">    V newValue = (oldValue == <span class="keyword">null</span>) ? value :</span><br><span class="line">               remappingFunction.apply(oldValue, value);</span><br><span class="line">    <span class="keyword">if</span>(newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>merge()</code> 方法会先调用 <code>Objects.requireNonNull()</code> 方法判断 value 是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</strong></p></blockquote><p>通过反编译你会发现 foreach 语法糖底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法</p><p>这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p><blockquote><p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</p></blockquote><p>Java8 开始，可以使用 <code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了上面介绍的直接使用 <code>Iterator</code> 进行遍历操作之外，你还可以：</p><ul><li>使用普通的 for 循环</li><li>使用 fail-safe 的集合类。<code>java.util</code>包下面的所有的集合类都是 fail-fast 的，而<code>java.util.concurrent</code>包下面的所有的类都是 fail-safe 的。</li><li>……</li></ul><h1 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</strong></p></blockquote><p>这里我们以 <code>HashSet</code> 和 <code>ArrayList</code> 为例说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set 去重代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">removeDuplicateBySet</span><span class="params">(List&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 去重代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">removeDuplicateByList</span><span class="params">(List&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(data.size());</span><br><span class="line">    <span class="keyword">for</span> (T current : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.contains(current)) &#123;</span><br><span class="line">            result.add(current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>两者的核心差别在于 <code>contains()</code> 方法的实现。</p><p><code>HashSet</code> 的 <code>contains()</code> 方法底部依赖的 <code>HashMap</code> 的 <code>containsKey()</code> 方法，时间复杂度接近于 O（1）（没有出现哈希冲突的时候为 O（1））。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们有 N 个元素插入进 Set 中，那时间复杂度就接近是 O (n)。</p><p><code>ArrayList</code> 的 <code>contains()</code> 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们的 <code>List</code> 有 N 个元素，那时间复杂度就接近是 O (n^2)。</p><h1 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</strong></p></blockquote><p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> String[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line"><span class="comment">//没有指定类型的话会报错</span></span><br><span class="line">s=list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。</p><h1 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</strong></p></blockquote><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 <code>List</code> 集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JDK 源码对于这个方法的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，</span></span><br><span class="line"><span class="comment">  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们来总结一下使用注意事项。</p><p><strong>1、<code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="keyword">int</span>[] array = (<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 <code>List</code> 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p>我们使用包装类型数组就可以解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下图是 <code>java.util.Arrays$ArrayList</code> 的简易源码，我们可以看到这个类重写的方法有哪些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们再看一下<code>java.util.AbstractList</code>的 <code>add/remove/clear</code> 方法就知道为什么会抛出 <code>UnsupportedOperationException</code> 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    add(size(), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    removeRange(<span class="number">0</span>, size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>那我们如何正确的将数组转换为 <code>ArrayList</code> ?</strong></p><p>1、手动实现工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.5+</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; l = <span class="keyword">new</span> ArrayList&lt;T&gt;(array.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> T s : array) &#123;</span><br><span class="line">    l.add(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">System.out.println(arrayToList(myArray).getClass());<span class="comment">//class java.util.ArrayList</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、最简便的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、使用 Java8 的 <code>Stream</code>(推荐)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="keyword">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、使用 Guava</p><p>对于不可变集合，你可以使用<code>ImmutableList</code>类及其<code>of</code>与[<code>copyOf()</code>工厂方法：（参数不能为空）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于可变集合，你可以使用<code>Lists</code>类及其<code>newArrayList()</code>工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">&quot;or&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>); <span class="comment">// from varargs</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、使用 Apache Commons Collections</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list, str);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6、 使用 Java9 的 <code>List.of()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本操作</title>
      <link href="posts/Linux%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>posts/Linux%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p>配置主机名： <code>vi /etc/sysconfig/network</code> ， 修改<code>HOSTNAME=node01</code> 。</p><p>配置网络：到  <code>/etc/sysconfig/network-scripts/</code>  下修改 <code>ifcfg-eth0</code> 文件。</p><p><img src="https://i.loli.net/2021/05/23/5a8EcOAZTXIm2qC.png" alt="1543321660241"></p><p>主动配置， 需要删除 <code>/etc/udev/rules.d/70-persistent-net.rules</code> ,  以下是该文件的内容：</p><p><img src="https://i.loli.net/2021/05/23/NKqAbXQV8Gm1BTZ.png" alt="1543322092630"></p><p>重启， 这样一台机器的网络就配置完成。</p><h2 id="配置克隆"><a href="#配置克隆" class="headerlink" title="配置克隆"></a>配置克隆</h2><p>对已经配置好的机器进行克隆， 完成多台机器的网络配置。</p><p>网络配置如1所示。</p><h2 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h2><p><code>type</code> ：被用于判断一个命令是否是内置命令。</p><p>如：<code>type ifconfig</code> ， 可以查看到该命令的位置。</p><p><img src="https://i.loli.net/2021/05/23/dIykZTFmesAQRDv.png" alt="1543390891824"></p><p><img src="https://i.loli.net/2021/05/23/mKseJzPSrRx1gYv.png" alt="1543392122498"></p><p>通过 <code>man yum</code> 可以查看yum帮助手册。</p><p><img src="https://i.loli.net/2021/05/23/CDV9augM3RT87Bl.png" alt="1543392202098"></p><p>通过<code>help cd</code> 查看内部命令的帮助手册。</p><p><code>whereis</code>  ：定位命令位置。</p><p><code>file</code> ：查看文件类型。</p><p><img src="https://i.loli.net/2021/05/23/hTHNxEpQLPJWG4M.png" alt="1543393267168"></p><p><code>echo</code> ： 打印到标准输出。</p><p><code>$PATH</code> ： 环境变量路径。</p><p><code>$LANG</code> ：系统语言。</p><p><img src="https://i.loli.net/2021/05/23/okG8bWRxt1KyDMT.png" alt="1543393742900"></p><p><img src="https://i.loli.net/2021/05/23/OouBDL184Xn6hd5.png" alt="1543394922834"></p><p><code>ps -ef</code> ： 显示所有进程。</p><p><img src="https://i.loli.net/2021/05/23/9I2BHRutkXNphFD.png" alt="1543394106383"></p><p><code>echo $$</code> ： 当前shell的PID。</p><p><img src="https://i.loli.net/2021/05/23/R6vfMLGY4NrUuWV.png" alt="1543404790980"></p><p><img src="https://i.loli.net/2021/05/23/pnRsdZQMPqDmeiO.png" alt="1543404810070"></p><p><code>man</code> ： 使用帮助手册。</p><p>​    1：用户命令(/bin, /usr/bin, /usr/local/bin)</p><p>​    2：系统调用</p><p>​    3：库用户</p><p>​    4：特殊文件(设备文件)</p><p>​    5：文件格式(配置文件的语法)</p><p>​    6：游戏</p><p>​    7：杂项(Miscellaneous)</p><p>​    8: 管理命令(/sbin, /usr/sbin, /usr/local/sbin)</p><p>如<code>ls</code> 命令为用户命令。</p><p><img src="https://i.loli.net/2021/05/23/RoxgjLIOrSnlT6Q.png" alt="1543405468245"></p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>查看根目录的目录结构<code>ll</code></p><p><img src="https://i.loli.net/2021/05/23/79pu2Ww5agsivMd.png" alt="1543459021711"></p><p>/boot: 系统启动相关的文件，如内核、initrd，以及grub(bootloader)</p><p>/dev: 设备文件  </p><p>/etc：配置文件</p><p>/home：用户的家目录，每一个用户的家目录通常默认为/home/USERNAME</p><p>/root：管理员的家目录；</p><p>/lib：库文件</p><p>/media：挂载点目录，移动设备</p><p>/mnt：挂载点目录，额外的临时文件系统</p><p>/opt：可选目录，第三方程序的安装目录</p><p>/proc：伪文件系统，内核映射文件</p><p>/sys：伪文件系统，跟硬件设备相关的属性映射文件</p><p>/tmp：临时文件, /var/tmp</p><p>/var：可变化的文件</p><p>/bin: 可执行文件, 用户命令</p><p>/sbin：管理命令</p><h2 id="文件系统命令"><a href="#文件系统命令" class="headerlink" title="文件系统命令"></a>文件系统命令</h2><p><code>df</code> ：显示磁盘使用情况</p><p><code>du</code> ：显示文件系统使用情况</p><p><code>ls</code> ：显示目录</p><p><code>cd</code> ：切换工作目录</p><p><code>pwd</code>：显示当前工作目录</p><p><code>mkdir</code> ：创建目录</p><p><code>rm</code> ：删除</p><p><code>cp</code> ：拷贝</p><p><code>mv</code> ：移动</p><p><code>ln </code> ：链接</p><p><code>stat</code> ：元数据</p><p><code>touch</code> ：创建文件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="posts/%E5%89%91%E6%8C%87offer/"/>
      <url>posts/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h1><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot; </span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><p><strong>题解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(Character c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h1><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><p><strong>题解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先计数</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        cur = head;</span><br><span class="line">        count --;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; count &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            arr[count--] = cur.val;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li></ul><p><strong>题解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        A.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty()) <span class="keyword">return</span> B.removeLast();</span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!A.isEmpty())</span><br><span class="line">            B.addLast(A.removeLast());</span><br><span class="line">        <span class="keyword">return</span> B.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a>剑指 Offer 20. 表示数值的字符串</h1><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li><li>若干空格</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一： <ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分<strong>数值</strong>列举如下：</p><ul><li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li></ul><p>部分<strong>非数值</strong>列举如下：</p><ul><li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;e&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;    .1  &quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，空格 <code>&#39; &#39;</code> 或者点 <code>&#39;.&#39;</code> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map[] states = &#123;</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>); put(<span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); &#125;&#125;, <span class="comment">// 0.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); &#125;&#125;,                           <span class="comment">// 1.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;, <span class="comment">// 2.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;,              <span class="comment">// 3.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); &#125;&#125;,                                        <span class="comment">// 4.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;s&#x27;</span>, <span class="number">6</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); &#125;&#125;,                           <span class="comment">// 5.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); &#125;&#125;,                                        <span class="comment">// 6.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;,                           <span class="comment">// 7.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;                                         <span class="comment">// 8.</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) t = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) t = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span>) t = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span> || c == <span class="string">&#x27; &#x27;</span>) t = c;</span><br><span class="line">            <span class="keyword">else</span> t = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!states[p].containsKey(t)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            p = (<span class="keyword">int</span>)states[p].get(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="number">2</span> || p == <span class="number">3</span> || p == <span class="number">7</span> || p == <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>零食秒杀项目</title>
      <link href="posts/%E7%A7%92%E6%9D%80/"/>
      <url>posts/%E7%A7%92%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><p>后端项目部署在应用服务器上，这里用的是Tomcat</p><p>数据层用的Mybatis框架用来进行数据访问</p><p>视图层用的SpringMVC</p><p>Spring 对整个Bean进行管理，Controller解析前端请求数据，完成取数据，业务层将数据返回给Controller，ViewResolve需要得到Controller传输的Model数据进行处理，最终返回JSON给前端</p><p>前端静态资源部署在Nginx服务器上</p><p>具体访问步骤：例如当浏览器访问某个商品的详情页，输入地址/item/detail/101发出了请求，首先请求到了Nginx服务器，Nginx将需要的静态资源等返回给浏览器，拿到item.html，看到图片文字等静态资源，如何跟服务端通信得到动态数据呢？这就需要Ajax发送异步请求给视图层，Controller调用业务层再调用数据层得到数据，经过加工返回给Controller，Controller将数据传给ViewResolver，最后ViewResolver将JSON数据传送给Ajax，Ajax回调函数接收到JSON数据渲染到页面。</p><p><img src="https://i.loli.net/2021/06/11/cneDpudU9v31hEx.png" alt="项目架构"></p><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p>设计如下几张表</p><p><img src="http://tva2.sinaimg.cn/large/c0cb27b0ly1grekab61udj205s05ea9x.jpg"></p><p>用户表user_info：包括用户id，电话，密码，昵称，性别，年龄</p><p><img src="http://tva3.sinaimg.cn/large/003wTNsYly1grekep9xovj60gx00qdfm02.jpg"></p><p>商品表item：包括商品id，商品名，商品价格，已售卖，图片，描述</p><p><img src="http://tvax2.sinaimg.cn/large/c0cb27b0ly1grekhb9jz8j20is00ndfm.jpg"></p><p>商品库存表item_stock：id，商品id，库存数</p><p><img src="http://tva3.sinaimg.cn/large/c0cb27b0ly1grekjn2harj206f00o0sh.jpg"></p><p>活动表promotion：id，名称，开始时间，结束时间，商品id，活动价格</p><p><img src="http://tva1.sinaimg.cn/large/c0cb27b0ly1grekl1ifbxj20k200smwy.jpg"></p><p>订单详情表order_info：id，用户id，商品id，活动id，下单价格，下单数量，下单总数，下单时间</p><p><img src="http://tva3.sinaimg.cn/large/c0cb27b0ly1grekkt0gh4j20r200pa9v.jpg"></p><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><h2 id="后端结构"><a href="#后端结构" class="headerlink" title="后端结构"></a>后端结构</h2><p>项目结构如下：</p><p><img src="https://tvax4.sinaimg.cn/large/c0cb27b0ly1grejlg3yjoj206i05jq2t.jpg" alt="image"></p><p>common包：放一些公共类。业务异常类、错误编码接口、给浏览器返回数据模板、工具类。</p><p><img src="http://tvax4.sinaimg.cn/large/c0cb27b0ly1grejrakdtdj206d03kwec.jpg" alt="image"></p><p>BusinessException: 公共的业务异常类，当程序中发生异常，统一通过该类向外抛出异常</p><p>component包：需要spring管理的公共对象</p><p><img src="http://tvax1.sinaimg.cn/large/c0cb27b0ly1grejvjtjx0j206201ba9u.jpg" alt="image"></p><p>configuration包：存放配置类</p><p><img src="http://tvax1.sinaimg.cn/large/c0cb27b0ly1grejwzt4ohj207e01kt8i.jpg"></p><p>controller包：controller层代码</p><p><img src="http://tvax1.sinaimg.cn/large/c0cb27b0ly1grek0djyr4j207d046glh.jpg"></p><p>dao包：数据访问层</p><p><img src="http://tva1.sinaimg.cn/large/c0cb27b0ly1grek1pgi1sj207r052mx2.jpg"></p><p>service包：存放业务层</p><p><img src="http://tvax2.sinaimg.cn/large/c0cb27b0ly1grek3ywek6j207o03g744.jpg"></p><p>entity包：存放实体类</p><p><img src="http://tva2.sinaimg.cn/large/c0cb27b0ly1grek2esvo2j206s0500sl.jpg"></p><h2 id="前端结构"><a href="#前端结构" class="headerlink" title="前端结构"></a>前端结构</h2><p><img src="C:\Users\miao\Desktop\项目\秒杀项目图片\image-20210715115443122.png" alt="image-20210715115443122"></p><h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><h2 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h2><p>打包项目(跳过所写的测试代码)：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>写一个start.sh文件来启动项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid=`ps aux | grep seckill | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"><span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">nohup java -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=512m -jar seckill-0.0.1-SNAPSHOT.jar --spring.profiles.active=<span class="built_in">test</span> &amp;</span><br></pre></td></tr></table></figure><p>赋予start.sh执行权限并执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 startup.sh</span><br><span class="line">sh start.sh</span><br></pre></td></tr></table></figure><p>至此，后端项目启动完成，可通过路径访问得到JSON数据。</p><h2 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h2><p>接下来需要对前端进行部署</p><p>启动nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/07/mXZopMy9FPq1nbc.png" alt="image-20210607140554066"></p><p>将前端项目上传至服务器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /usr/share/nginx/html/</span><br></pre></td></tr></table></figure><p>配置nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/07/9ClGvLrpE7nJNZ8.png" alt="image-20210607142058655"></p><p><img src="https://i.loli.net/2021/06/07/BYuViTh9z7p1mDo.png" alt="image-20210607145018262"></p><p>配置完毕重新启动nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>商品详情页压测</p><p><img src="https://i.loli.net/2021/06/07/O2neJXGxq9L76iv.png" alt="image-20210607162022974"></p><p>200个线程</p><p><img src="https://i.loli.net/2021/06/07/1NvJcWEm5tPKlRs.png" alt="image-20210607162104253"></p><p><img src="https://i.loli.net/2021/06/07/dKbQJnL1gEFCvRf.png" alt="image-20210607162134318"></p><p>对下单页面进行压测</p><p><img src="https://i.loli.net/2021/06/07/Xe9OMIc7dY85fLx.png" alt="image-20210607163606744"></p><p><img src="https://i.loli.net/2021/06/07/XLflqHBiexJbaCF.png" alt="image-20210607163625389"></p><p><img src="https://i.loli.net/2021/06/07/BCx24f3WAlZhK1j.png" alt="image-20210607163639053"></p><p>修改redis 配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/redis.conf</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/07/4dj6OzeCmnchxUf.png" alt="image-20210607182600746"></p><p><img src="https://i.loli.net/2021/06/07/lYSX361hBeJZM7s.png" alt="image-20210607182649992"></p><p>启动redis</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><p>进入redis客户端</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a password</span><br></pre></td></tr></table></figure><p>redis 常用操作命令</p><p>RocketMQ</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirror-hk.koddos.net/apache/rocketmq/4.8.0/rocketmq-all-4.8.0-bin-release.zip</span><br><span class="line">unzip rocketmq-all-4.8.0-bin-release.zip</span><br><span class="line">chmod -R 777 rocketmq-all-4.8.0-bin-release</span><br></pre></td></tr></table></figure><p>runserver.shs</p><p><img src="https://i.loli.net/2021/06/09/vOBweJlNq6zREU1.png" alt="image-20210609150337600"></p><p>runbroker.sh</p><p><img src="https://i.loli.net/2021/06/09/yOb9uHjDm86ECV4.png" alt="image-20210609150905219"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring 入门</title>
      <link href="posts/Spring%20%E5%85%A5%E9%97%A8/"/>
      <url>posts/Spring%20%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-简介"><a href="#Spring-简介" class="headerlink" title="Spring 简介"></a>Spring 简介</h1><p><img src="https://s2.loli.net/2021/12/24/B9ZUjq3FcsMDvHQ.jpg" alt="图片描述"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>“Spring 真的那么有用吗？”</strong></p><p>首先 Spring 可谓是大名鼎鼎，如雷贯耳。而关于 Spring 的文章、书籍、教程更是数不胜数。可以说 Spring 贯穿我们的整个职业生涯，是框架界的常青树。那么我们这个专题专门来聊一聊： 到底 Spring 是什么，它的特点优势是什么，我们项目的开发为什么选择 Spring，它能帮助我们解决哪些问题？</p><p><strong>带着疑问，开始我们的专题。</strong></p><h2 id="Spring-概述"><a href="#Spring-概述" class="headerlink" title="Spring 概述"></a>Spring 概述</h2><p><strong>先搞清楚 Spring 的概念：</strong><br><strong>官网定义</strong>：</p><p>Spring 框架为任何类型的部署平台上的基于 Java 的现代企业应用程序提供了全面的编程和配置模型。</p><p>Spring 的一个关键元素是在应用程序级别的基础架构支持：Spring 专注于企业应用程序的 “管道”，以便团队可以专注于应用程序级别的业务逻辑，而不必与特定的部署环境建立不必要的联系。</p><p><strong>通俗解释</strong>：</p><p>简单来说：Spring 是一个免费开源框架，为了简化企业级项目开发，提供全面的开发部署解决方案。</p><p><strong>疑问导出</strong>：</p><p>看到这儿，我们明白了一件事：Spring 是帮助我们开发项目的，使用起来很方便。</p><p>那么问题来了：<strong>Spring 为了简化项目开发到底做了哪些事情？</strong></p><h2 id="知识入门"><a href="#知识入门" class="headerlink" title="知识入门"></a>知识入门</h2><h3 id="Spring-核心功能"><a href="#Spring-核心功能" class="headerlink" title="Spring 核心功能"></a>Spring 核心功能</h3><p>Spring 到底如何简化我们的项目开发呢？首先，来了解下 <strong>Spring</strong> 的体系结构。</p><h3 id="Spring-的体系结构介绍"><a href="#Spring-的体系结构介绍" class="headerlink" title="Spring 的体系结构介绍"></a>Spring 的体系结构介绍</h3><p><img src="https://s2.loli.net/2021/12/24/LH9dlJ6fVQKCx2p.png" alt="图片描述"><br><strong>结构图阐释</strong>：</p><ol><li>左上角勾画出负责持久层的部分，是 Spring 对数据持久化，事务管理，支持的功能框架。大家听过的 SpringDataJpa 就是其中的一种；</li><li>右上角勾画出是负责表现层的部分，是 Spring 对于表现层数据的处理部分的支持，比如：大家听说过的 SpirngMVC 就是其中的一种；</li><li>最底部的负责测试的部分 是 Spring 对于项目的测试 提供了完整的一个测试环境支持；</li><li>而中间的两部分 是我们大家常常俗称的 Spring 框架。</li></ol><p><strong>疑问导出</strong>：</p><p>看到这里大家可能会明白一点， Spring 其实是一个 “大家族”。从表现层、业务层、持久层，它都有对应的支持，而我们在框架学习的部分其实主要是使用了它中间的两个部分的核心功能。</p><p><strong>那么，Spring 核心功能到底是什么呢？</strong></p><h3 id="Spring-的核心功能"><a href="#Spring-的核心功能" class="headerlink" title="Spring 的核心功能"></a>Spring 的核心功能</h3><p>大家对于使用 Spring 框架开发项目已经司空见惯了… 但是对于它的功能或者作用，描述出来总是差点什么，那么现在咱们详细聊一聊它的核心功能。</p><p><strong>核心功能：</strong></p><ol><li><strong>控制反转（IoC）</strong>： 简单理解 IoC 是一种设计模式，将实例化对象的控制权 由手动的 new 变成了 Spring 框架通过反射机制实例化；</li><li><strong>依赖注入（DI）</strong>： 首先理解依赖，程序运行的需要可以称之为依赖。由于 Spring 框架通过反射技术实例化了对象，并将对象的实例存入在容器进行管理。那么如果一个类中的属性为某个其余的类，属性无需手动赋值，通过 spring 的配置文件，或者 Spring 提供的注解，通过 spring 框架可以实现直接注入属性；</li><li><strong>面向切面编程 （AOP）</strong>： 何谓切面，切面是数学中的一个概念，表示只有一个点接触到球体的一个平面称呼为切面，而接触点称呼为切点。那么在 Spring 中，切面编程指的就是在程序运行某个方法的时候，不修改原始执行代码逻辑，由程序动态地执行某些额外的功能，对原有的方法做增强，这就叫做面向切面编程，那个被监测的执行方法，称呼为切入点。</li></ol><p><strong>知识小结</strong>：</p><p>Spring 是分层的 Java SE/EE 应用 轻量级开源框架，<strong>以 IoC（Inverse of Control：控制反转）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库，</strong> 是使用最多的 Java EE 企业应用开源框架。</p><p>使用 Spring 的意义在于：<strong>对于 bean 对象的实例管理更加方便，代码编写更加优雅，降低代码的耦合性，提升代码的扩展性。</strong></p><h2 id="Spring-的优势"><a href="#Spring-的优势" class="headerlink" title="Spring 的优势"></a>Spring 的优势</h2><p><strong>Spring 的概念和功能了解以后，下面谈谈它的优势在哪</strong></p><ul><li>Spring 简化项目开发 ： Spring 灵活全面的扩展功能，使我们开发项目如鱼得水 。通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用；</li><li>Spring 的面向切面编程 ：Spirng 框架的 AOP 面向切面编程，极大地提高了程序的扩展性，支持开发人员实现对程序的自定义增强。同时可以方便地使用 Spring 提供的事务管理；</li><li>面向接口编程： 面向接口编程 降低代码的耦合性，同时也提高了代码的扩展性；</li><li>测试方便：对于测试的支持 有很多的组件实现；</li><li>方便集成第三方框架 Spring 可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz 等）的直接支持。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节主要对于 Spring 框架做了入门介绍，通过本节的学习，我们应该知道以下几点：</p><ol><li>Spring 框架的概念；</li><li>Spring 框架的意义；</li><li>Spring 框架的体系结构；</li><li>Spring 框架的核心功能；</li><li>Spring 框架的优势；</li></ol><h1 id="Spring-工程的搭建"><a href="#Spring-工程的搭建" class="headerlink" title="Spring 工程的搭建"></a>Spring 工程的搭建</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p><strong>“Spring 的工程如何创建？”</strong></p><p>在上一节中我们通过 Spring 的简介，了解了 Spring 的概念、体系结构、与它的核心功能。那么本章带你体验一下 Spring 的项目开发和我们之前搭建过的开发项目有哪些不同。</p><h3 id="Spring-框架版本介绍与依赖引入"><a href="#Spring-框架版本介绍与依赖引入" class="headerlink" title="Spring 框架版本介绍与依赖引入"></a>Spring 框架版本介绍与依赖引入</h3><p><strong>版本历史</strong><br>Spring 诞生到现在经历太多的历史版本，有的已经消失在历史长河中了… 我们选择最新的版本给大家进行案例讲解。</p><ul><li>5.2.x 是最新的生产线（通常于 2019 年 9 月下旬提供）；</li><li>5.1.x 是之前的生产线（自 2018 年 9 月以来），一直得到积极支持，直到 2020 年底；</li><li>5.0.x 于 2019 年第二季度进入 EOL 阶段。出于对 5.0.x 用户的礼貌，我们将在 2020 年 1 月之前提供主动维护，并在 2020 年底之前提供安全补丁（如果需要）；</li><li>4.3.x 是第四代的最后一个功能分支。它具有延长的维护期限，直到 2020 年 1 月，并且安全补丁甚至超过了这一点。4.3.x 将于 2020 年 12 月 31 日达到其正式停产（停产）；</li><li>截至 2016 年 12 月 31 日，3.2.x 属于产品停产（寿命终止）。该产品线中没有计划进一步的维护版本和安全补丁。请尽快迁移到 4.3 或 5.x。</li></ul><p>我们建议从 Maven Central 升级到最新的 Spring Framework 5.2.x 版本。</p><p>以上是官网列出 Spring 的历史版本介绍，我们采用的是 5.2.2 版本，对应的 jdk 最少是 jdk 1.8 ，我相信大家的 jdk 一般来讲都是满足要求的。</p><h3 id="Spring-框架源码下载"><a href="#Spring-框架源码下载" class="headerlink" title="Spring 框架源码下载"></a>Spring 框架源码下载</h3><p><strong>下载方式</strong>：</p><ol><li>下载源码文件 。<br>Spring 的源码下载地址 ：<br><a href="https://github.com/spring-projects/spring-framework/releases">https://github.com/spring-projects/spring-framework/releases</a></li><li>第二种是使用 maven 的坐标方式 。<br>maven 的 pom 文件坐标。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h2><p><strong>准备好依赖之后 废话不多说，我们开始撸代码</strong> 。</p><h3 id="使用-IDEA-创建-Web-工程"><a href="#使用-IDEA-创建-Web-工程" class="headerlink" title="使用 IDEA 创建 Web 工程"></a>使用 IDEA 创建 Web 工程</h3><p>开发工具选择 idea ，创建 Maven 的 jar 工程即可。因为涉及不到浏览器的请求，所以无需创建 web 工程。</p><p>创建 Maven 工程 。</p><p><img src="https://s2.loli.net/2021/12/24/vPE6sKzjn5RoQku.png"></p><p>补全坐标信息。</p><p><img src="https://s2.loli.net/2021/12/24/jcZiLtYF7yofrg8.png"></p><p>继续下一步 finish 完成创建即可。</p><h3 id="引入项目使用的坐标依赖"><a href="#引入项目使用的坐标依赖" class="headerlink" title="引入项目使用的坐标依赖"></a>引入项目使用的坐标依赖</h3><p>将准备好的坐标信息粘贴到工程下 <code>pom</code> 文件中 。 看下图：</p><p><img src="https://s2.loli.net/2021/12/24/KENkOMdoZnhXUfR.png"></p><h3 id="编写-Spring-框架使用的配置文件"><a href="#编写-Spring-框架使用的配置文件" class="headerlink" title="编写 Spring 框架使用的配置文件"></a>编写 Spring 框架使用的配置文件</h3><p>坐标有了之后，说明我们的工程中已经引入了 Spring 框架的依赖。点开左侧的 External Libraries 查看一下 。</p><p><img src="https://s2.loli.net/2021/12/24/DhOstJf3YHwGnIA.png"></p><p>那么看到上面的 jar 包列表，表示 Spring 框架中的基本依赖我们已经成功引入。接下来：既然我们使用的是框架，框架是一个半成品，已经封装好了很多功能提供我们使用，而我们如何让他们工作呢？ 这里需要一个和 Spirng 框架通信的桥梁 —<strong>Spring 框架的核心配置文件。</strong></p><p><strong>小提示</strong>：<br>文件的名称可以随便起，一般习惯使用 <code>applicationContext.xml</code>。<br>文件的位置放在哪里呢？ maven 工程需要放在 <code>src</code> 下面的 <code>resources</code> 下面，如下图：</p><p><img src="https://s2.loli.net/2021/12/24/PtnvqB7Uojb6OaV.png"></p><p>那么配置文件是空的，不要着急。到底应该配置什么，不是自己臆想猜测的。<br>如果你已经下载了源码，那么解压缩它，打开 <strong>docs\spring-framework-reference</strong> 目录，打开 <strong>core.html</strong> 查看官方文档，<br>下图：<br><img src="https://img.mukewang.com/wiki/5e8f4adb096cc7c014390571.jpg" alt="图片描述"><br>将上面的实例配置信息拷贝到我们的配置文件中，它只是给了最基本的配置头信息，内容部分 针对 bean 做初始化的部分 需要我们自行填充 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写代码测试"><a href="#编写代码测试" class="headerlink" title="编写代码测试"></a>编写代码测试</h2><p>准备好工程后，编写我们的代码。</p><h3 id="编写接口和接口的实现类"><a href="#编写接口和接口的实现类" class="headerlink" title="编写接口和接口的实现类"></a>编写接口和接口的实现类</h3><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service的save方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充-Spring-的配置文件"><a href="#补充-Spring-的配置文件" class="headerlink" title="补充 Spring 的配置文件"></a>补充 Spring 的配置文件</h3><p>配置文件的目的是将我们自定义的实现类交给 Spring 的容器管理。因为 Spring 框架核心功能之一就是 IoC 控制反转，目的是将对象实例化的动作交给容器。还记得第一节介绍的吗？不记得了？走你，剩下的我们继续。最终 Spring 的配置文件如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 此标签的作用 是实例化UserServiceImpl类的实例 交给 Spring 容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wyan.service.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>从容器中获取对象实例，调用提供的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = </span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">        UserService service = (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        service.saveUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li><code>ApplicationContext</code> 是 Spring 框架提供的一个接口，目前只需要知道它是作为存储实例化 bean 对象的容器即可。下一节我们会细讲。</li><li><code>context.getBean ()</code> 方法是通过配置文件中声明的 bean 标签 id 属性获取容器内的实例。</li></ol><p>最终结果如下：<br><img src="https://s2.loli.net/2021/12/24/l1aAIsexFucUPQw.png" alt="图片描述"><br>可以看到控制台打印输出 证明确实从容器中获取到了 userService 的实例。入门就是如此简单…</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>技术之路很简单 一是思路步骤清晰，二就是代码的熟练度。<br>先理清入门示例的步骤 ：</p><ol><li>创建 Maven 工程；</li><li>导入 Spring 的依赖；</li><li>编写 Spring 的配置文件；</li><li>编写测试的代码。</li></ol><h1 id="Spring-工程执行过程"><a href="#Spring-工程执行过程" class="headerlink" title="Spring 工程执行过程"></a>Spring 工程执行过程</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p><strong>Spring 框架是如何工作的？</strong></p><p>本节目的在于帮助大家理解 Spring 框架底层干了什么事情。</p><p>在上一节中我们通过一个入门工程简单地体验了一把 Spring 的使用。</p><p>我们发现，通过构造一个 <code>ClassPathXmlApplicationContext</code> 对象，加载项目的 <code>applicationContext.xml</code> 文件，确实可以实例化对象。</p><p><strong>疑问导出</strong></p><p>而脑海中不禁有一个想法… Spring 如何初始化对象的实例的？我们又如何从容器中获取得到对象的实例的呢？</p><p>带着疑问… 开启本节的源码和原理之旅。</p><h2 id="容器初始化"><a href="#容器初始化" class="headerlink" title="容器初始化"></a>容器初始化</h2><p>回顾代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext context =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    UserService service = (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    service.saveUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中可以得知 Spring 的容器是 <code>ApplicationContext</code>，那么它到底是什么东西呢？先跟我一起追踪一下它的角色。<br><strong>官方文档</strong><br><img src="https://s2.loli.net/2021/12/24/ashIAcxbU7Evonz.png" alt="图片描述"><br><strong>通俗解释</strong></p><p>简单翻译过来就是 <code>ApplicationContext</code> 是一个接口，是 <code>BeanFactory</code> 这个接口的子接口，它扩展了 <code>BeanFactory</code> 这个接口，提供了额外附加的功能。<br>而 <code>BeanFactory</code> 是管理 bean 对象的容器的根接口，大家了解下就好，我们是针对它的子接口 <code>ClassPathXmlApplicationContext</code> 做的实例化，目的是加载项目中的 Spring 的配置文件，使 Spring 来管理我们定义的 bean 对象。</p><p><strong>疑问导出</strong><br>那么我们的问题是…<code>ClassPathXmlApplicationContext</code> 对象实例化之后，干了哪些事情呢？</p><h3 id="容器初始化执行动作"><a href="#容器初始化执行动作" class="headerlink" title="容器初始化执行动作"></a>容器初始化执行动作</h3><p><strong><code>applicationContext</code> 实例化执行代码逻辑</strong> 。<br>我们追踪下源码，发现 <code>ClassPathXmlApplicationContext</code> 初始化的时候，它做了一系列的事情。源码如下：</p><p><img src="https://s2.loli.net/2021/12/24/r6jT8bPDF14SO39.png" alt="图片描述"></p><p><strong>代码解释：</strong></p><ol><li>是初始化 <code>ClassPathXmlApplicationContext</code> 对象执行的有参构造；</li><li>加载项目下的 xml 配置文件；</li><li>调用 refresh 刷新容器的方法 bean 的实例化就在这个方法中。</li></ol><p><strong>继续跟踪：</strong></p><h3 id="容器初始化-bean-对象动作"><a href="#容器初始化-bean-对象动作" class="headerlink" title="容器初始化 bean 对象动作"></a>容器初始化 bean 对象动作</h3><p><strong>下面是从源码中粘贴的部分代码</strong></p><p><img src="https://s2.loli.net/2021/12/24/gvqyasNMPkohHJ4.png" alt="图片描述"><br><strong>步骤阐述：</strong></p><ol><li>1 的位置：是准备刷新，那么 Spring 只是设置刷新的标记，加载了外部的 <code>properties</code> 属性文件；</li><li>2 的位置：是准备 bean 工厂对象；</li><li>3 的位置：这一步骤就加载了配置文件中的所有 bean 标签，但是并没有对他们进行实例化；</li><li>4 的位置：完成此上下文的 bean 工厂的初始化，初始化所有剩余的单例 bean。（Spring 中默认加载的 bean 就是单例模式后面生命周期会讲）</li><li>最后的位置：完成容器的刷新，也就是所有的 bean 初始化完成。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里粘贴一部分初始化代码的逻辑 帮助大家理解</span></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line"><span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line"><span class="comment">//所有非懒加载的单例bean的触发器初始化。。。</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">  ...<span class="comment">//省略循环的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK 上面就是加载配置文件后 Spring 框架做的所有事情，当然实际底层涉及的东西 更多，但是我们没有必要深究，毕竟我们是理解过程，不是追求实现。</p><p><strong>疑问导出：</strong></p><p>我们整理了 Spring 初始化 bean 对象的过程，那么如果容器中确实存在了 bean 的实例，我们是如何获取得到的呢？</p><h2 id="容器中获取对象的过程"><a href="#容器中获取对象的过程" class="headerlink" title="容器中获取对象的过程"></a>容器中获取对象的过程</h2><p>还是先看下我们获取容器对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext context =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">    UserService service = (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    service.saveUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong>：</p><p><code>context.getBean</code> 的方法是通过 <strong>bean</strong> 标签里的 <strong>id</strong> 来从容器中获取，那么我们看下源码 ：<br>在父类 <strong><code>AbstractApplicationContext</code></strong> 中有对 getBean 方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">assertBeanFactoryActive();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>追踪父类方法</strong><br>最终通过我们层层追踪，我们在 <code>AbstractAutowireCapableBeanFactory</code> 中发现这样的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//省略大量方法内部代码</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//给实例中的属性赋值</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">//真实实例化对象</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="comment">//继续省略大量方法</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将实例化后的对象放入容器中</span></span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回实例化后的对象实例</span></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面源码中我们可以看到： 对象实例的获取好像是在获取的时候执行的 <code>doCreateBean</code>，那么之前记载的 <code>xml</code> 文件不是实例过了吗？稍微解释下：加载文件时候的实例化操作，其实是实例化了一个 Spring 框架提供的对象，作用是对于我们 bean 对象做描述，这里才是真实的实例化动作。我们再看看 <code>registerDisposableBeanIfNecessary</code> 这个方法做的是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDisposableBean</span><span class="params">(String beanName, DisposableBean bean)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.disposableBeans) &#123;</span><br><span class="line"><span class="keyword">this</span>.disposableBeans.put(beanName, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/24/9KSujYBM6smgwIC.png" alt="图片描述"></p><p><strong>结论</strong>：<br>一切真相大白。它其实就是一个 map 集合 ，这个 map 集合的 key 就是我们定义的 bean 的 id 或者 bean 的 name ，那么值就是对象的实例。</p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>本节带着大家梳理了一下 Spring 初始化 bean 和获取 bean 的流程：</p><ol><li>Spring 框架通过 ResourceLoader 加载项目的 xml 配置文件；</li><li>读取 xml 的配置信息 变成对象存储，但未实例化；</li><li>通过 bean 工厂处理器对 bean 做实例化，存储到一个 map 集合中默认是单例；</li><li>获取对象 通过 xml 文件中 bean 的 id 从 map 集合中通过 get (key) 获取。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring DI</title>
      <link href="posts/Spring%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>posts/Spring%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-DI（依赖注入）之XML配置"><a href="#Spring-DI（依赖注入）之XML配置" class="headerlink" title="Spring DI（依赖注入）之XML配置"></a>Spring DI（依赖注入）之XML配置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="">Spring控制反转</a>，我们详细讲解了 控制反转，也就是对 bean 做实例化的部分。而我们知道 ，Spring 的核心功能是两个：控制反转 和 依赖注入。</p><p>那么控制反转我们已经讲过，而依赖注入是什么呢？</p><h2 id="依赖注入案例"><a href="#依赖注入案例" class="headerlink" title="依赖注入案例"></a>依赖注入案例</h2><h4 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h4><p><strong>知识回顾</strong></p><p>对于依赖注入，我们在第一章第一节已经介绍过，我们回顾一下</p><p><img src="https://s2.loli.net/2021/12/24/a3eXTCls7pO98ih.png" alt="图片描述"></p><p><strong>概念解释</strong></p><p>上面是我们之前对于依赖注入的一个通俗解释。那么这里再着重强调一下 <strong>IOC</strong> 控制反转与 <strong>DI</strong> 依赖注入的关系：</p><p>IOC 控制反转是将对象实例化的动作交由了 Spring 框架， 它的作用是降低了程序的耦合，不需要我们手动的创建对象，但是程序的耦合性还是存在。</p><p>对象中肯定会有一些其余对象的引用，那么这种引用就称呼为对象的依赖，而 DI 依赖注入其实 是 IOC 设计思想的一种表现形式。</p><p>对于 这种属性依赖，我们无需手动赋予，也是讲赋值的动作交给 Spring ，那么这种操作就是 <strong>依赖注入</strong>。</p><p><strong>依赖注入方式</strong>：</p><ul><li>第一种方式是通过 xml 配置的方式实现；</li><li>第二种方式是在属性或者方法上使用注解的方式实现。</li></ul><p>那么，本章节先带大家体验下 xml 方式实现依赖注入。</p><h4 id="工程实现"><a href="#工程实现" class="headerlink" title="工程实现"></a>工程实现</h4><p><strong>搭建动作介绍</strong></p><ol><li>创建一个 maven 工程</li><li>导入Spring 使用的依赖</li><li>编写业务层的 Service 和持久层的 Dao java 类</li><li>编写 Spring 的配置文件</li></ol><p><strong>创建工程 导入依赖 省略</strong></p><p>可以参考之前创建过的IoC工程</p><p><strong>java 代码</strong></p><p>创建 Servcie 的接口和接口的实现类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">getUserDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;删除的方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDao 接口和实现类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dao接口代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dao实现类代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释： dao的接口和实现类中并没有方法，只是为了测试 作为service中的属性依赖，可以实现由 Spring 完成动态注入。</p><p><strong>重点来了：spring 的核心配置文件：</strong></p><p><img src="http://img.mukewang.com/wiki/5e9959bd0918bd3810610534.jpg" alt="图片描述"></p><p>配置解释：</p><p>在上面的配置文件中：</p><ul><li>bean 标签是描述一个被实例化的类 而 property 则表示一类中的属性</li><li>property 标签中的属性 name 一般我们写成类中的属性名称， 实际上，起决定作用的并不是属性名，下面示例再展示</li><li>ref 表示当前的属性 是一个引用对象，而引用的是谁呢？ ref 中的值 必须是在容器中已经实例化的一个引用对象的唯一标识。</li><li>value 当前的属性可以直接赋值，所以通过 value 中，填写要赋予的数值即可</li></ul><p><strong>测试结果</strong></p><p><img src="http://img.mukewang.com/wiki/5e9959ff09fc348a12380755.jpg" alt="图片描述"></p><p><strong>代码解释</strong></p><p>可以看到 我们得到了 service 中的类属性 Userdao 的实例，并且也 得到了 字符串属性 userName的值 zs</p><h4 id="property注入属性的解释"><a href="#property注入属性的解释" class="headerlink" title="property注入属性的解释"></a>property注入属性的解释</h4><p>刚刚我们在上面的示例中 展示了xml依赖属性的注入，也是比较好理解。</p><p>这里我们强调一下使用的注意事项：</p><p>如果是 property 属性标签实现属性注入，那么类中必须由配置在 property 标签中 name 属性的 set 方法</p><p>下面我们测试一下set方法的改变：</p><p><strong>先讲 service 中 dao 的 set 方法改造如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了set方法 给dao属性赋值&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候代码中的set方法变成了 setDao 配置文件不变，依然是</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们看看会产生什么问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.NotWritablePropertyException: Invalid property &#x27;userDao&#x27; of bean class [com.wyan.service.UserServiceImpl]: Bean property &#x27;userDao&#x27; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?</span><br><span class="line">at org.springframework.beans.BeanWrapperImpl.createNotWritablePropertyException(BeanWrapperImpl.java:<span class="number">247</span>)</span><br><span class="line">at org.springframework.beans.AbstractNestablePropertyAccessor.processLocalProperty(AbstractNestablePropertyAccessor.java:<span class="number">426</span>)</span><br><span class="line">at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:<span class="number">278</span>)</span><br><span class="line">at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:<span class="number">266</span>)</span><br><span class="line">at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:<span class="number">97</span>)</span><br><span class="line">at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:<span class="number">77</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:<span class="number">1646</span>)</span><br></pre></td></tr></table></figure><p>可以看到异常的堆栈信息 无效的 userDao 属性， userDao 不可以 或者 没有有效的 setter 方法提供。</p><p><strong>更改xml文件中的 property 标签的 name 属性 为 dao</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="http://img.mukewang.com/wiki/5e995b9709af36a611160354.jpg" alt="图片描述"><br>所以我们说 property 中的 name 属性不一定要跟 Java类中的属性名保持一致 而是必须跟 setter 方法的名称一致</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>本章节重点依赖注入的 xml 实现</p><ol><li>依赖注入 实际上是 IOC 设计思想的一种具体实现</li><li>依赖注入 可以通过 xml 配置实现 ，可以通过注解实现</li><li>xml 的依赖注入 是依托于类中的 set 方法实现的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring IoC</title>
      <link href="posts/Spring%20IoC/"/>
      <url>posts/Spring%20IoC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-IoC（控制反转）"><a href="#Spring-IoC（控制反转）" class="headerlink" title="Spring IoC（控制反转）"></a>Spring IoC（控制反转）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过<a href="">Spring入门</a>，我们已经可以使用 <strong>Spring</strong> 框架实现对自定义的 Java 对象管理，由 Spring 框架加载对象，实例化对象，放入容器。其实这就是 <strong>Spirng</strong> 的核心功能之 IoC，那么什么是 IoC 呢？什么又是容器呢？</p><h2 id="什么是-IoC？"><a href="#什么是-IoC？" class="headerlink" title="什么是 IoC？"></a>什么是 IoC？</h2><p><strong>来自百度百科的解释 —— 控制反转（IoC）：</strong><br>（Inversion of Control，缩写为 IoC），是面向对象编程中的一种设计原则，可以用来降低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称 DI），还有一种方式叫 “依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p><p><strong>通俗解释</strong></p><p>如何理解好 IoC 呢？上一个小节中，我们使用简单的语言对它做了一个描述 —— IoC 是一种设计模式。将实例化对象的控制权，由手动的 <strong>new</strong> 变成了 <strong>Spring</strong> 框架通过反射机制实例化。</p><p>那我们来深入分析一下为什么使用 <strong>IoC</strong> 做控制反转，它到底能帮助我们做什么。<br>我们假设一个场景：</p><p>我们在学习 <strong>Web</strong> 阶段的过程中，一定实现过数据的查询功能，那么这里我就举一个实例：<br>我们有这样几个类：</p><ul><li>UserServlet</li><li>UserService 接口</li><li>UserServiceImpl 接口的实现类</li><li>UserDao</li></ul><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UserServlet  作为控制器 接收浏览器的请求</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServlet</span> <span class="keyword">extends</span> <span class="title">HttpServletRequest</span> </span>&#123;</span><br><span class="line"> <span class="comment">//用户的业务类 提供逻辑处理 用户相关的方法实现</span></span><br><span class="line"> <span class="keyword">private</span> UserService userService;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    <span class="comment">//手动实例化UserService接口的实现类</span></span><br><span class="line">    userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    List&lt;User&gt; list =  userService.findAll();</span><br><span class="line">    <span class="comment">//省略结果的跳转代码</span></span><br><span class="line">     </span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用户的业务接口UserService</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UserServiceImpl 作为用户的业务实现类 实现类UserService的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"> <span class="comment">//用户的Dao</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//手动实例化Dao</span></span><br><span class="line">     userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line">     <span class="keyword">return</span> userDao.findAll();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题分析：</strong></p><p>上面的代码有什么问题吗？ 按照我们学习过的知识… 答案是没有。因为 Dao 只要数据源编写代码正确， 完全可以实现数据的增删改查 ，对吗？</p><p>但是分析分析它我们发现：</p><ol><li>代码耦合性太强 不利于程序的测试：<br>因为 <code>userServlet</code> 依赖于 <code>userService</code> ，而 <code>userService</code> 依赖于 <code>userDao</code> ， 那么只要是被依赖的对象，一定要实例化才行。所以我们采取在程序中硬编码，使用 <code>new</code> 关键字对对象做实例化。 不利于测试，因为你不能确保所有使用的依赖对象都被成功地初始化了。有的朋友很奇怪，对象实例化有什么问题吗？ 如果构造参数不满足要求，或者你的构造进行了逻辑处理，那么就有可能实例化失败；</li><li>代码也不利于扩展：<br>假设一下，我们花了九牛二虎之气，整理好了所有的类使用的依赖，确保不会产生问题，那么一旦后续我们的方法进行扩充，改造了构造函数，或者判断逻辑，那么是不是所有手动 new 对象的地方都需要更改？ 很明显这就不是一个优雅的设计。</li></ol><p><strong>解决方式：</strong></p><p>Spring 的 IoC 完美的解决了这一点， 对象的实例化由 Spring 框架加载实现，放到 Spring 的容器中管理，避免了我们手动的 new 对象，有需要用到对象实例依赖，直接向 Spring 容器要即可，而一旦涉及到对象的实例修改，那么 只需更改 Spring 加载实例化对象的地方，程序代码无需改动，降低了耦合，提升了扩展性。</p><h2 id="容器的使用"><a href="#容器的使用" class="headerlink" title="容器的使用"></a>容器的使用</h2><p>刚刚我们解释了 IoC 的作用，是对象的实例化由主动的创建变成了 Spring 的创建，并放入容器管理，那么这个容器是什么？<br><strong>概念理解:</strong><br>日常生活中有很多的容器，例如：水桶、茶杯、酒瓶，那么他们都有一个特点，就是装东西。而 Spring 的容器，就是装对象的实例的。</p><h3 id="IoC-容器的体系结构"><a href="#IoC-容器的体系结构" class="headerlink" title="IoC 容器的体系结构"></a>IoC 容器的体系结构</h3><p>Spring 的容器有两个：</p><ol><li>BeanFactory</li><li>ApplicationContext</li></ol><p>他们两个都是接口，那么有什么区别呢？见图如下：<br><img src="https://s2.loli.net/2021/12/24/4laytu7QDYENrje.png" alt="图片描述"></p><p><code>BeanFactory</code> 才是 Spring 容器中的顶层接口。 <code>ApplicationContext</code> 是它的子接口。<br>简而言之，<code>BeanFactory</code> 提供了配置框架和基本功能，并在 <code>ApplicationContext</code> 中增加了更多针对企业的功能。<br><code>BeanFactory</code> 和 <code>ApplicationContext</code> 的区别： 创建对象的时间点不一样。<br><code>ApplicationContext</code>：只要一读取配置文件，默认情况下就会创建对象。<br><code>BeanFactory</code>：什么时候使用，什么时候创建对象。</p><h3 id="IoC-容器实例化的方式"><a href="#IoC-容器实例化的方式" class="headerlink" title="IoC 容器实例化的方式"></a>IoC 容器实例化的方式</h3><p>上面已经知道 Spring 的容器是通过一个接口 <code>org.springframework.context.ApplicationContext</code> 表示，并负责实例化，配置和组装 Bean 对象。容器通过读取 xml 文件中的配置信息来获取关于实例化对象，配置属性等命令。<br>而 <code>ApplicationContext</code> 只是一个接口，我们通常创建 <code>ClassPathXmlApplicationContext</code> 的实例或者 <code>FileSystemXmlApplicationContext</code> 的实例。前者是从类路径中获取上下文定义文件，后者是从文件系统或 URL 中获取上下文定义文件 。例如：<br><img src="https://img.mukewang.com/wiki/5e93a08a09777e9816390470.jpg" alt="图片描述"></p><p><strong>代码解释：</strong><br>15 行注释掉的代码是通过加载类路径下的配置文件，一般来说 Java 工程放在 <code>src</code> 目录下。我们使用的是 Maven 工程放在 <code>resources</code> 目录下。</p><p>18 行代码是通过加载本地 D 盘目录下的文件来初始化容器， 实例化 bean 对象。</p><p><strong>结论</strong><br>通过上面的两种方式测试，发现都可以成功初始化容器， 获取测试的 bean 对象实例。<br>也证明了容器的初始化可以创建 <code>ClassPathXmlApplicationContext</code> 也可以创建 <code>FileSystemXmlApplicationContext</code> 的实例。</p><h3 id="IoC-容器的使用实例"><a href="#IoC-容器的使用实例" class="headerlink" title="IoC 容器的使用实例"></a>IoC 容器的使用实例</h3><p>我们知道了加载配置文件初始化容器的方式，现在了解下容器的使用。其实对于我们而言，已经不陌生了，在Spring入门中也已经成功的从容器中获取了对象实例。<br>这里我们就回顾一下：</p><p>1.容器的初始化必须先配置 xml 文件，代码回顾如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.ahao.entity.User&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.加载配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>3.调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getBean(<span class="string">&quot;user&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本小节对 IoC 概念做了一个详解，同时介绍了 IoC 解决的问题，演示了 IoC 的使用实例，对于初学者来说搞清楚概念，理解作用，实践出结果，就是出色的完成了任务。</p><h1 id="Spring-IoC-（控制反转）之-xml-配置"><a href="#Spring-IoC-（控制反转）之-xml-配置" class="headerlink" title="Spring IoC （控制反转）之 xml 配置"></a>Spring IoC （控制反转）之 xml 配置</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>本小节目的在于带领大家熟练 <strong>xml 文件配置</strong>， 应用 xml 文件配置 IoC。</p><p>Spring入门中我们通过一个入门工程简单地体验了一把 Spring 的使用，梳理了一下 Spring 的工作流程。</p><p>大家有了一个初步认知，Spring 框架的工作脱离不了核心配置文件 <code>applicationContext.xml</code>。</p><p>在配置文件中我们目前只用到了一个 bean 标签，它的作用是用于描述 Java 的类，让框架启动加载配置文件实例化的。</p><p><strong>疑问导出</strong></p><p>那么我们知道描述一个类有几个要素，类名、属性、构造函数 set 和 get 方法对吧？而 bean 标签如何描述一个详细的类呢？</p><p>带着疑问… 开始本节内容。</p><h2 id="bean-标签中的属性介绍"><a href="#bean-标签中的属性介绍" class="headerlink" title="bean 标签中的属性介绍"></a>bean 标签中的属性介绍</h2><p><strong>核心配置文件回顾</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ahao.entity.User&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>在上面的代码中可以看到，在 bean 标签中有两个属性，一个是 id 一个是 class。那么在 bean 标签中都有哪些属性呢？</p><p><strong>属性列表</strong></p><table><thead><tr><th align="left">学号</th><th align="left">姓名</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">定义的唯一标识</td></tr><tr><td align="left">name</td><td align="left">同 id 的意义一致</td></tr><tr><td align="left">class</td><td align="left">类</td></tr><tr><td align="left">factory-bean</td><td align="left">工厂对象</td></tr><tr><td align="left">factory-method</td><td align="left">工厂方法</td></tr><tr><td align="left">init-method</td><td align="left">初始化执行的方法</td></tr><tr><td align="left">destroy-method</td><td align="left">销毁执行的方法</td></tr><tr><td align="left">scope</td><td align="left">对象的作用域</td></tr><tr><td align="left">lazy-init</td><td align="left">懒加载</td></tr><tr><td align="left">autowire</td><td align="left">依赖注入</td></tr><tr><td align="left">depends-on</td><td align="left">依赖于某个实例</td></tr></tbody></table><p><strong>疑问导出</strong></p><p>上述属性是配置 bean 标签中可以选择的属性，当然一般来讲，我们无需配置所有，可以根据自己的需求配置需要的属性信息，那么如何选择这些属性呢？</p><h3 id="属性详细解释"><a href="#属性详细解释" class="headerlink" title="属性详细解释"></a>属性详细解释</h3><h4 id="id-和-name-标签的使用"><a href="#id-和-name-标签的使用" class="headerlink" title="id 和 name 标签的使用"></a><strong>id 和 name 标签的使用</strong></h4><p>我们目前已经知道所有被<strong>实例化</strong>后的对象都存在于 <strong>Spirng 的容器</strong>中，那么从容器中获取这些对象需要一个属性 id 对吧？那么 <strong>name 和 id</strong> 有什么关系呢？</p><p>查看官方文档得知 Spring 的容器会给初始化的每个 bean 都定义一个或多个<strong>标识符</strong>。这些标识符在容器内必须是<strong>唯一</strong>的。一个 bean 通常只有一个标识符。而 name 和 id 都可以起到标识符的作用。</p><p>所以在 <strong>XML</strong> 配置文件，我们一般使用 <strong>id</strong> 或者 <strong>name</strong> 属性，定义 bean 的唯一标识，这样我们才能通过定义好的唯一标识，从 Spring 的容器中获取他们。</p><p><strong>代码实例</strong>:</p><p>xml 的配置文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ahao.entity.User&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ApplicationContext context =</span><br><span class="line">               <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">       System.out.println(context.getBean(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">       System.out.println(context.getBean(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="https://s2.loli.net/2021/12/24/Pq31gHLu52jCaKe.png" alt="image-20211224204058082"></p><p><strong>结论证明</strong>：</p><p>我们通过 bean 标签中的 id 属性 user， 或者使用 bean 标签中的 name 属性 user2， 都可以得到 Spring 容器中的 user 对象的示例，而且打印的地址是同一个。我们之前说过一句，默认在容器中的实例都是单例的，在这里也得到了证明。</p><h4 id="class-属性"><a href="#class-属性" class="headerlink" title="class 属性"></a><strong>class 属性</strong></h4><p>bean 标签的定义实质上是创建一个或多个对象的方法。当 <strong>xml 文件被解析加载</strong>的时候，使用该 bean 定义封装的配置数据来创建（或获取）实际对象，而创建获取的对象是谁呢？就是通过 <strong>class 属性</strong>中定义的类的全路径来指定 。</p><p>一般来讲 class 中的类实例化有<strong>两种方式</strong>：</p><p> 一种是<strong>反射</strong> ，相当于我们使用的 new 关键字。这种也是我们常用的方式。当然不要忘记提供无参数的构造方法（类中默认有无参构造，但是如果自定义了有参构造，默认的无参不会提供）</p><p> 一种是<strong>工厂模式</strong> ，需要借助于 factory-bean 和 factory-method 两个属性，这种方式不常用，我们可以了解下。</p><h4 id="factorybean-和-factorymethod-属性"><a href="#factorybean-和-factorymethod-属性" class="headerlink" title="factorybean 和 factorymethod 属性"></a>factorybean 和 factorymethod 属性</h4><p>这两个属性主要用于工厂模式实例化 bean 的时候使用，不是很常见。工厂模式有两种，这里分别做个实例，帮助大家理解。</p><p><strong>静态工厂</strong>模式实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--applicationContext的配置bean节点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ahao.entity.User&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUserInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>创建 bean 示例的 Java 工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：在定义使用静态工厂方法创建的 bean 时，class 属性指定的是被创建的类，包含静态的方法，并使用 factory-method 属性来指定工厂方法本身名称。</p><p><strong>普通工厂模式</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring实例化工厂对象 用于创建java实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ahao.factory.BeanFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被工厂创建的对象实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;beanFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUser1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>工厂类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User1 user1 = <span class="keyword">new</span> User1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User2 user2 = <span class="keyword">new</span> User2();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User1 <span class="title">createUser1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User2 <span class="title">createUser2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：先实例化先创建各个对象示例的工厂对象到容器中，自身的 bean 标签将 <code>class</code> 属性保留为空，并在 <code>factory-bean</code> 属性中指定当前容器中的工厂 Bean 名称，再使用 <code>factory-method</code> 属性设置创建示例的方法名称。</p><h4 id="init-method-和-destroy-method-属性的使用"><a href="#init-method-和-destroy-method-属性的使用" class="headerlink" title="init-method 和 destroy-method 属性的使用"></a>init-method 和 destroy-method 属性的使用</h4><p>这两个属性比较好理解 init-method 就是 bean 被初始化后执行的方法，destory-method 就是 bean 被销毁执行的代码。</p><p><strong>我们来个测试类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被spring实例化了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user类实例化时候执行的代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destoryMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user类实例被销毁时候执行的代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ahao.entity.User&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destoryMethod&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>测试代码</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ApplicationContext context =</span><br><span class="line">               <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>加载 Spring 的配置文件控制台打印如下：</p><p><img src="https://s2.loli.net/2021/12/24/sqV41WoTjeFgE3L.png" alt="image-20211224214211633"></p><p>有个小疑问：销毁语句没打印呢？那是因为并没有调用容器的销毁方法。</p><p><strong>改造测试</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       AbstractApplicationContext context =</span><br><span class="line">               <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">       context.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>解释：ApplicationContext 没有 close 方法使用它的子类</p><p><strong>运行结果：</strong></p><p><img src="https://img.mukewang.com/wiki/5e93a5d709537d1f13550412.jpg" alt="图片描述"></p><h4 id="其余属性作用"><a href="#其余属性作用" class="headerlink" title="其余属性作用"></a>其余属性作用</h4><p><strong>scope</strong> ：指定示例的作用范围，后续章节详细讲解；</p><p><strong>lazy-init</strong> ：表示是否为懒加载；</p><p><strong>autowire</strong> ：指定属性注入方式，后续章节详解；</p><p><strong>depends-on</strong>： 表示是否有依赖的 bean 对象，后续依赖注入章节详细解释。</p><h3 id="构造函数的使用"><a href="#构造函数的使用" class="headerlink" title="构造函数的使用"></a>构造函数的使用</h3><p>刚刚我们详细解释了 bean 标签内部的属性，经过几个小实例以后不禁也有个问题：</p><p>如果我们定义的类中有一些初始化的参数，并且定义好了有参数的构造，通过 xml 配置文件如何体现呢？</p><p>实现起来非常简单，跟我来进行一个小实例：</p><p><strong>改造 User 类</strong>：</p><p>这是一个普通的 Java 类对象，包含两个属性及其 get 和 set 方法，并且提供了空参构造和有参构造，为了测试方便再覆写一个 toString 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>xml 配置文件方式</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.ahao.entity.User&quot;</span>  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：</p><p><img src="https://s2.loli.net/2021/12/24/VLd125hUOwcXFWN.png" alt="image-20211224214408528"></p><p>其实对于有参构造实例化对象而言，使用一个标签 constructor-arg 即可，表示构造的参数，如果有多个，可以继续添加，这里不多做演示。</p><p><strong>疑问导出</strong>：</p><p>可能有同学会想，那么如果以后我们的属性需要动态更改呢？或者我们的属性不是基本类型而是另外的对象呢？ 后续在依赖注入多种属性的小节给大家讲解 。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本章节带着大家详细解释了 bean 标签的使用，那么通过本章节我们收获了哪些呢？</p><ol><li>容器内部命名唯一标识可以通过 id 也可以通过 name；</li><li>实例化对象有两种方式 反射模式和工厂模式；</li><li>如果是反射模式，那么必须配置 class 属性，因为需要用 class 属性中类的全路径来实例化 bean 对象；</li><li>如果需要在类实例化初始化参数，可以使用 init 方法也可以使用有参构造。</li></ol><h1 id="Spring-框架模拟实现"><a href="#Spring-框架模拟实现" class="headerlink" title="Spring 框架模拟实现"></a>Spring 框架模拟实现</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>通过前面的学习，大家对于 Spring 已经有了初步的认知，我们通过案例练习，或者源码追踪，可以粗略的看到 Spring 框架初始化 bean 对象的过程，那么这个章节，我们模拟 Spring 框架的思路，来写一个类似 Spring 加载对象的案例，加深大家的印象。</p><h2 id="案例实现思路"><a href="#案例实现思路" class="headerlink" title="案例实现思路"></a>案例实现思路</h2><h3 id="步骤介绍"><a href="#步骤介绍" class="headerlink" title="步骤介绍"></a>步骤介绍</h3><p><strong>思路分析：</strong></p><p>我们通过写过的案例可以知道：</p><ol><li>Spring 框架的容器 是一个接口 <code>ApplicationContext</code> 和接口的实现类 <code>ClassPathXmlApplicationContext</code> 来初始化的；</li><li>在初始化容器对象的时候需要传递 xml 配置文件的位置；</li><li>xml 的配置文件中主要是通过 bean 标签可以对 Java 的类进行描述：类的路径 类的标识 类的构造参数等等；</li><li>容器初始化以后需要解析 xml 配置文件的各个 bean 标签；</li><li>实例化的对象如果有参数或者构造方法，那么也需要给参数赋值；</li></ol><p><strong>开发准备</strong>：</p><p>为了方便理解测试 ，我们来自定义容器的接口和实现类。</p><p>名称改为 <code>SpringContext</code> 和 <code>XmlSpringContext</code> 区别于框架的接口和实现类。</p><p>接口定义方法 getBean 用于获取容器内的示例，实现类定义有参构造用于接受初始化时候的配置文件路径。</p><p><strong>接口代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringContext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现类代码如下</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlSpringContext</span>  <span class="keyword">implements</span> <span class="title">SpringContext</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlSpringContext</span> <span class="params">(String filename)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong>：</p><ol><li>map 用于存储实例化的 bean 对象 ；</li><li>有参构造方法逻辑暂时为空，下面会做实现，加载文件实例化对象在方法内部；</li><li>getBean 的方法用于通过 key 获取 map 中存储的实例。</li></ol><p>为了测试对象的实例化，我们自定义 <code>UserService</code> 和 <code>UserServiceImpl</code> 作为测试的接口对象和实现类。</p><p><strong>接口代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口的实现类代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="comment">//持久层的dao属性</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">getUserDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//实现接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;删除的方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释：dao 的属性其实是为了模拟属性赋值，后面依赖注入章节会详细讲解。</p><p><strong>自定义一个 xml 文件 作为模拟框架的配置文件</strong> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ahao.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ahao.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码解释：userDao 的 bean 需要实例化 是因为 service 用到了它的引用，所以这里多个属性 property。</p><p><strong>编写测试类加载文件测试</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化容器（读取配置文件 构建工厂）</span></span><br><span class="line">SpringContext context =</span><br><span class="line">                <span class="keyword">new</span> XmlSpringContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        UserServiceImpl userService = (UserServiceImpl) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.deleteById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(userService.getUserDao());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释：这里的目的只是测试能否获取对象调用方法，如果控制台打印证明案例成功</p><h3 id="容器对象的实现类构造函数具体代码"><a href="#容器对象的实现类构造函数具体代码" class="headerlink" title="容器对象的实现类构造函数具体代码"></a>容器对象的实现类构造函数具体代码</h3><p><strong>思路分析</strong>：</p><ol><li><p>读取初始化时候传递的文件路径；</p></li><li><p>通过 SAXReader 解析 xml 文件的节点得到 beans 节点下对应多个 bean 节点集合；</p></li><li><p>每一个 bean 表示一个对象，都需要被初始化，所以需要循环遍历集合；</p></li><li><p>在循环遍历的过程中获取 id 属性和 class 属性，id 属性作为存入 map 的 key，class 属性用于反射实例化对象，并存储 map 的 value；</p></li><li><p>继续解析子节点，如果有参数，反射获取 method 执行参数赋值。</p></li></ol><p><strong>完整代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlSpringContext</span><span class="params">(String filename)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xml文件的解析器</span></span><br><span class="line">SAXReader  sr = <span class="keyword">new</span> SAXReader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//构建一个直接通向我们配置文件路径 的输入流</span></span><br><span class="line">InputStream inputStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(filename);</span><br><span class="line"><span class="comment">//文档模型对象</span></span><br><span class="line">Document doc = sr.read(inputStream);</span><br><span class="line"><span class="comment">//获取根标签</span></span><br><span class="line">Element root = doc.getRootElement();</span><br><span class="line"><span class="comment">//获取当前根标签的子标签</span></span><br><span class="line">List&lt;Element&gt;  beans = root.elements(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Element bean:beans)&#123;</span><br><span class="line">String key = bean.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">String value = bean.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">Class&lt;?&gt; myclass = Class.forName(value);</span><br><span class="line"><span class="comment">//当前对象</span></span><br><span class="line">Object obj = myclass.newInstance();</span><br><span class="line">map.put(key, obj);</span><br><span class="line">List&lt;Element&gt; elements = bean.elements(<span class="string">&quot;property&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(elements.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(Element pro: elements)&#123;</span><br><span class="line"> String av = pro.attributeValue(<span class="string">&quot;name&quot;</span>);<span class="comment">//dao---&gt;setDao</span></span><br><span class="line"> <span class="comment">//方法名</span></span><br><span class="line"> String methodName=<span class="string">&quot;set&quot;</span>+(av.charAt(<span class="number">0</span>)+<span class="string">&quot;&quot;</span>).toUpperCase()+av.substring(<span class="number">1</span>,av.length()); </span><br><span class="line"> <span class="comment">//方法参数</span></span><br><span class="line"> String refvalue = pro.attributeValue(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line"> Object refobj = map.get(refvalue); </span><br><span class="line"> <span class="comment">//根据方法名称获取方法对象Method</span></span><br><span class="line"> Method method = myclass.getMethod(methodName,refobj.getClass().getInterfaces()[<span class="number">0</span>]); </span><br><span class="line"> method.invoke(obj, refobj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><p><img src="http://img.mukewang.com/wiki/5ed0ca6c099a40d412180728.jpg" alt="图片描述"></p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>本章节带着大家模拟一下 Spirng 加载文件的过程和实例化对象的过程，当然这个过程只是模拟 Spring 的框架的思路，而并不是真正的 Spring 框架源码，实际源码远比这个要复杂的多，</p><p>那么通过本章节我们收获哪些知识呢？</p><ol><li>Spring 容器类的使用</li><li>xml 配置文件的作用</li><li>反射技术的应用</li></ol><h1 id="Spring-IoC（控制反转）之注解配置"><a href="#Spring-IoC（控制反转）之注解配置" class="headerlink" title="Spring IoC（控制反转）之注解配置"></a>Spring IoC（控制反转）之注解配置</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>上两节，我们学习了 Spring IoC 的 xml 配置实现，整理了 xml 方式的实现步骤，并且模拟了 Spring 的容器如何加载解析 xml 配置文件，那么我们发现一点现象：</p><p>对于 Spring 的 bean 管理而言，如果全部通过 xml 文件实现的话，配置文件的内容未免过于臃肿。因为对于一个类的实例化，就需要一个 bean 标签。</p><p>这样的话，一个大型工程下来，有那么几百个，几千个类，Spring 的 xml 文件维护起来，成本实在太高。</p><p><strong>疑问导出</strong>：</p><p>Spring 能否有更方便的方式实现 IoC 呢？Spring 提出了两种 IoC 实现方式，一种是基于配置文件，一种是基于注解形式。</p><p>本节，我们学习下 Spring IoC 的注解形式是如何实现的。</p><h2 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h2><h3 id="步骤介绍-1"><a href="#步骤介绍-1" class="headerlink" title="步骤介绍"></a>步骤介绍</h3><p><strong>回顾 Spring IoC 的 xml 实现步骤</strong>：</p><ol><li><p>使用 new 关键字对 <code>ClassPathXmlApplicationContext</code> 做初始化；</p></li><li><p>在初始化容器对象的构造传入 xml 配置文件的位置 ；</p></li><li><p>在配置文件中通过 bean 标签可以对类进行描述：类的路径、类的标识、类的构造参数等等。</p></li></ol><p><strong>注解实现 IoC 的思路分析</strong>:</p><p> 1.Spring 容器一样需要初始化；</p><ol start="2"><li><p>一样需要传入 xml 配置文件 —– 需要描述清楚 需要被实例化的类都有哪些；</p></li><li><p>xml 文件中 不需要使用 bean 标签描述被实例化的类 —— 使用注解实现 IoC 管理目的就是为了简化 bean 标签的配置。</p></li></ol><p><strong>疑问导出:</strong></p><p>如果是 xml 文件方式实现 IoC ，加载 xml 文件的 bean 标签就已经知道，需要被实例化的对象，那么如果不使用 bean 标签描述，Spring 框架如何得知哪些类需要被容器管理呢？</p><p><strong>核心思想：</strong></p><p>开发人员无需使用 XML 来描述 bean ，而是将配置移入 Java 的类本身，通过 Spring 支持的组件扫描来实现。</p><p>看官稍等… 马上开始我们的案例实现。</p><h3 id="工程实现"><a href="#工程实现" class="headerlink" title="工程实现"></a><strong>工程实现</strong></h3><p><strong>创建工程</strong>：</p><p>为了区分 xml 工程，坐标名称换成 spring_an ，其实无所谓，大家自行创建即可。</p><p><img src="https://s2.loli.net/2021/12/24/Ku9qPwe2DvhWZJ6.png" alt="image-20211224220118299"></p><p><strong>导入依赖</strong>：</p><p>依赖的坐标跟 xml 的工程坐标一致即可，无需导入多余的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>项目代码</strong>：</p><p>为了测试，在工程内部创建 <code>UserDao</code> 的接口和 <code>UserDao</code> 的实现类 <code>UserDaoImpl</code>。</p><p><code>UserDao</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserDaoImpl</code> 的实现类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span>  <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行dao的保存方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项： 由于我们是基于注解的方式实现对 bean 的管理，所以在实现类上面需要添加一个注解 @Repository，此注解的作用是为了 Spring 的容器启动后，需要要自动检测这些被注解的类并注册相应的 bean 实例到容器中。</p><p><strong>Spring 的核心配置文件</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ahao.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面是本案例的配置文件，那么可以看出跟 xml 的配置文件有很大的区别：</p><p><strong>配置节点</strong>：<code>context-component-scan</code> 标签，这是 Spring 框架自定义的 xml 标签，通过 <code>base-package</code> 的属性，指明需要被自动扫描实例化的类所在位置。</p><p>如上图所示，我们在 com.ahao.dao 下的类是需要扫描自动注入容器的。</p><p>小细节：不是在 com.ahao.dao 下的所有类都会自动注入到容器，而是要搭配注解：比如我们的 @Repository 当然还有其余的注解，我们后面章节会详细讲解。</p><p><strong>测试类测试结果</strong>：</p><p><img src="https://s2.loli.net/2021/12/24/epaC3SB2V5yw7JZ.png" alt="image-20211224221233902"></p><p><strong>代码解释</strong>：</p><p>测试类其实跟 xml 的方式一模一样，我们本次测试的目的一样也是通过 Spring 容器管理注册的 bean 对象，只不过对象的实例化方式换成了注解，那么我们看到成功输出在控制台的测试语句，说明案例搭建完成。</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>本节带着大家使用注解的方式，实现了 Spring 对于 bean 的管理。</p><p>那么回顾下注解开发的步骤和注意点：</p><ol><li>Spring 容器初始化一样需要 xml 文件，目前是 xml 文件搭配注解管理 bean 并不是纯注解开发；</li><li>Spring 的 xml 配置文件中使用 <code>context:component-scan</code> 标签指定注册 bean 的类所在目录位置；</li><li>自定义编写的 Java 类，如果需要被自动扫描注入容器，必须搭配注解。</li></ol><h1 id="Spring-IoC（控制反转）之常用注解"><a href="#Spring-IoC（控制反转）之常用注解" class="headerlink" title="Spring IoC（控制反转）之常用注解"></a>Spring IoC（控制反转）之常用注解</h1><h2 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h2><p>上一节，我们通过注解的方式，实现了 Spring 对于 bean 的管理，那么如何实现的，我们回顾一下</p><p>两个重要点：</p><ol><li>注解实例化的类上，需要使用一个注解 <code>@Repository</code>；</li><li>Spring 的配置文件中，需要使用组件扫描 <code>&lt;context:component-scan&gt;</code> 。</li></ol><p><strong>疑问导出</strong>：</p><p>组件扫描的作用我们清楚，是为了扫描路径之下带有注解的类，但是为什么类上面的注解是 <code>@Repository</code> 呢？或者说，是否还有其余的注解可以实现呢？</p><p>本节，我们一起来学习下 Spring IoC 的常用注解。</p><h2 id="注解的详解"><a href="#注解的详解" class="headerlink" title="注解的详解"></a>注解的详解</h2><p>在我们详细讲解注解之前，首先明确一点：</p><p>注解配置和 xml 配置实现的功能都是一样的，只不过实现的方式不同，那么也就是说，xml 文件可以实现的，通过注解都可以完全办得到。比如实例化对象，设置属性，设置作用范围，生命周期的方法执行等等…</p><h3 id="注解分类介绍"><a href="#注解分类介绍" class="headerlink" title="注解分类介绍"></a>注解分类介绍</h3><p><strong>按功能划分</strong>：</p><ol><li><strong>创建对象：</strong> 对应的就是在 xml 文件中配置的一个 bean 标签，可以定义 id、name、class 等属性；</li><li><strong>注入数据：</strong> 对应的就是在 bean 标签下，使用 property 标签给类中的依赖属性赋值；</li><li><strong>作用范围：</strong> 对应的就是设置 bean 标签的 scope 属性，不设置默认也是单例；</li><li><strong>生命周期：</strong> 对应的就是设置 bean 标签的 init-method 和 destroy-method 方法。</li></ol><h4 id="创建对象的注解介绍"><a href="#创建对象的注解介绍" class="headerlink" title="创建对象的注解介绍"></a>创建对象的注解介绍</h4><p>从 Spring 的官网得知一段话：</p><blockquote><p><code>@Repository</code> 注释是针对满足的存储库（也被称为数据访问对象或 DAO）的作用，或者固定型的任何类的标记。</p></blockquote><p>也就是说，我们上一节中使用的注解，一般用于 dao 层使用。那么，我们都知道，JAVAEE 体系结构，一般开发分为三个层级：</p><ol><li><strong>表现层</strong>： 主要作用为处理数据生成静态的页面响应给浏览器展示 ；</li><li><strong>业务层</strong>： 主要作用为业务逻辑代码编写，数据的获取，数据的封装返回等等操作都在这里；</li><li><strong>持久层</strong>： 主要作用为跟数据库打交道，对于数据的持久化操作等。</li></ol><p>那么，如果是创建的表现层或者业务层代码，应该使用什么注解呢？</p><p>好了，看一下创建对象注解的划分：</p><ol><li><strong>@Component</strong> ：一般用于通用组件的类上使用的注解；</li><li><strong>@Service</strong> ： 一般用于业务层类上使用的注解；</li><li><strong>@Controller</strong> ： 一般用于控制层类上使用的注解；</li><li><strong>@Repository</strong> ：一般用于持久层类上使用的注解。</li></ol><p><strong>官网解释</strong>：</p><blockquote><p>Spring 提供进一步典型化注解：<code>@Component</code>，<code>@Service</code>，和 <code>@Dao</code>。<br><code>@Component</code> 是任何 Spring 托管组件的通用构造型。<br><code>@Repository</code>，<code>@Service</code> 和 <code>@Controller</code> 是 <code>@Component</code> 针对更特定用例的专业化（分别在持久性，服务和表示层）。</p></blockquote><p><strong>通俗解释：</strong></p><p><code>@Component</code> 注解是 Spring 框架中通用的一个注解，用于组件扫描实例化对象使用， 那么其余的三个注解 <code>@Controller</code> ，<code>@Service</code>，<code>@Repository</code> 都是 <code>@Component</code> 注解的衍生注解，作用跟 <code>@Componet</code> 注解的作用一致。<br>那么意义在于， 三个注解，对应的是三个开发层级 ，一般来讲我们将 <code>@Controller</code> 作为表现层的使用，<code>@Service</code> 作为业务层的注解，<code>@Repository</code> 作为持久层使用的注解。我们下面通过案例演示一下。</p><h3 id="创建对象的注解"><a href="#创建对象的注解" class="headerlink" title="创建对象的注解"></a>创建对象的注解</h3><p><strong>实例说明</strong></p><p>四种注解的测试，本节重点讲解创建对象使用的注解，而作用范围 scope 和生命周期的两个注解，我们放在后续对应的小节进行讲解测试。</p><p>置于注入数据的注解，是比较重要的一个内容， 我们放在依赖注入这节详细讲解。</p><p><strong>创建工程省略</strong></p><p>我们继续使用上一节的注解工程实例即可，那么为了演示三个注解，我们分别创建三个层级对应的代码：</p><ul><li>表现层的 <code>UserController</code></li><li>业务层的 <code>UserService</code></li><li>实现类 <code>UserServiceImpl</code></li></ul><p>持久层 dao 代码已经创建过了，这里不多解释。创建好的所有代码如下：</p><p><strong>UserController 代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是controller的执行保存..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserService 和实现类代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span>  <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;执行service中的保存逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>项目结构如下：</strong></p><p><img src="https://s2.loli.net/2021/12/24/F3DpUMH8rgtAWCS.png" alt="image-20211224222021654"></p><p>上面是本案例的工程以及代码结构：</p><p> 类虽然看起来很多，实际没有业务逻辑代码，只不过在各个层级使用了三个注解来注入到容器，目的是测试当 Spring 的配置文件加载扫描后，是否可以从容器中获取三种注解（<code>@Controller</code> <code>@Service</code> <code>@Repository</code>）注入的 bean 对象。</p><blockquote><p><strong>Tips：</strong> Spring 的配置文件 <code>context:component-scan</code> 标签的扫描层级 需要包含三个包路径，例如我的工程实例代码如下：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ahao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>测试类与测试结果</strong>：</p><p><img src="https://s2.loli.net/2021/12/24/SIbpN7fPxRE2uai.png" alt="image-20211224223258347"></p><p><strong>结论：</strong></p><p>可以三个注解都可以将对象注入到 Spring 的容器，那么以后开发时候按照规范或者习惯，分层开发，使用对应的注解。但它并不是必须这么做，你使用任意一种都可以，只不过，代码的可读性会差。</p><p>所以，我们一般表现层使用 <code>@controller</code> ，业务层使用 <code>@service</code>， 持久层使用 <code>@Repository</code>。</p><p>至于 <code>@Component</code> 如果有其余的类，不属于三个层级，可以采用 <code>@Component</code> 作为通用组件扫描注入容器。</p><h3 id="注解注入规则"><a href="#注解注入规则" class="headerlink" title="注解注入规则"></a>注解注入规则</h3><p>刚刚通过三个注解都可以完成了 bean 的实例化注入，通过测试代码也获取到了容器中的三个对象实例，那么这里不知道大家是否发现一个问题：</p><p>我们知道，Spring 这个容器本质是个 map 集合来存储实例化后的对象。既然是个 map 集合，就应该对应的有 key 和 value。</p><p>我们都知道 value 肯定是实例化后的 bean ，那么 key 是什么呢？</p><p><strong>注入规则</strong>：</p><ol><li>四种注解都支持 value 的属性作为自定义的 bean id ;</li><li>如果 value 属性没有指定，那么默认以类的简单名称（类名首字母小写）作为 bean 对象的 id。</li></ol><p>所以我们可以看到：</p><p>当我们只使用注解没有自定义 id 的时候可以通过，每个类的首字母小写来获取对象实例，那么如果有了自定义的 id，上述代码是否继续可用呢？</p><p><strong>自定义 id 获取实例</strong>：</p><p>改造类上面的注解，设置自定的 id，更改的注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controll(&quot;uc&quot;)</span></span><br><span class="line"><span class="meta">@Service(&quot;us&quot;)</span></span><br><span class="line"><span class="meta">@Repository(&quot;ud&quot;)</span></span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：</p><p><img src="https://s2.loli.net/2021/12/24/6JONLWeha7QC52T.png" alt="image-20211224225011452"></p><p><strong>测试结果</strong>：</p><p>为了区分测试结果，我在测试代码中，只修改了 controller 的获取方式，将 id 改成了 uc 。service 和 dao 并没有修改。</p><p>从控制台打印可以看到，只有 controller 对象可以成功获取，service 和 dao 都失败了，因为我们已经使用了自定义的 id，所以容器中没有默认的以类名作为 id 的 bean 对象实例。</p><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>本章节重点讲解注解的使用：</p><ol><li>Spring 支持的注解有四种分类；</li><li>Spring 创建对象的注解四种分类；</li><li>Spring 创建对象注入容器的规则。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="posts/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>posts/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java体系"><a href="#Java体系" class="headerlink" title="Java体系"></a>Java体系</h2><h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><p>1、跨平台<br>2、面向对象编程语言<br>3、分布式计算</p><h3 id="Java-的运行机制"><a href="#Java-的运行机制" class="headerlink" title="Java 的运行机制"></a>Java 的运行机制</h3><ul><li>编程 Java 程序</li><li>编译 Java 文件</li><li>JVM 读取字节码文件运行程序</li></ul><h3 id="Java的三大体系"><a href="#Java的三大体系" class="headerlink" title="Java的三大体系"></a>Java的三大体系</h3><ul><li>Java SE(J2SE)</li><li>Java ME(J2ME)</li><li>Java EE(J2EE)</li></ul><h3 id="配置-Java-环境"><a href="#配置-Java-环境" class="headerlink" title="配置 Java 环境"></a>配置 Java 环境</h3><p>JRE、JDK<br>JRE：Java Runtime Environment Java 运行环境<br>JDK：Java Devlopment Kit Java 开发工具包</p><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ul><li>编译</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure><ul><li>运行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure><p>Java IDE<br>NetBeans、Eclipse、IDEA</p><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><ul><li>强制性代码规范，必须执行的</li></ul><p>1、Java 程序的文件名与类名必须一致，若不一致，无法通过编译。<br>2、main 方法是程序的入口，方法的定义必须严格按照格式书写。<br>3、类是组织 Java 代码结构的，类中的方法是执行具体业务的。</p><ul><li>非强制性代码规范，建议按照此方式编写代码</li></ul><p>1、一行只写一条语句。<br>2、在 1 的基础上，还要注意代码缩进。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="安装-Java-环境"><a href="#安装-Java-环境" class="headerlink" title="安装 Java 环境"></a>安装 Java 环境</h3><ul><li>编写 Java 代码</li><li>编译 Java 代码，成为字节码文件 16 进制<br>javac 文件名（带后缀）</li><li>让 JVM 执行字节码文件，运行程序<br>java 文件名（不带后缀）</li></ul><p>IDE：集成开发环境<br>Eclipse、IDEA</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释就是用通俗易懂的语言对代码进行描述解释，方便自己和他人阅读。</p><ul><li>单行注释：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释内容</span></span><br></pre></td></tr></table></figure><ul><li>多行注释：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注释内容</span></span><br><span class="line"><span class="comment">注释内容</span></span><br><span class="line"><span class="comment">注释内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>文档注释：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**注释内容</span></span><br><span class="line"><span class="comment">*注释内容</span></span><br><span class="line"><span class="comment">*注释内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>Java 语言预先定义好的，有指定意义的标识符，组成程序的基本元素。</p><table><thead><tr><th>abstract</th><th>表示抽象</th></tr></thead><tbody><tr><td>boolean</td><td>基本数据类型</td></tr><tr><td>break</td><td>跳出循环</td></tr><tr><td>byte</td><td>基本数据类型</td></tr><tr><td>case</td><td>与 switch 搭配使用</td></tr><tr><td>catch</td><td>与 try 搭配使用，表示捕获异常</td></tr><tr><td>char</td><td>基本数据类型</td></tr><tr><td>class</td><td>表示一个类</td></tr><tr><td>continue</td><td>跳出循环</td></tr><tr><td>do</td><td>与 while 搭配使用，表示循环</td></tr><tr><td>double</td><td>基本数据类型</td></tr><tr><td>else</td><td>与 if 搭配，流程控制</td></tr><tr><td>enum</td><td>枚举类型</td></tr><tr><td>extends</td><td>继承</td></tr><tr><td>final</td><td>修饰常量</td></tr><tr><td>float</td><td>基本数据类型</td></tr><tr><td>if</td><td>流程控制</td></tr><tr><td>implements</td><td>实现接口</td></tr><tr><td>import</td><td>引入某个类</td></tr><tr><td>int</td><td>基本数据类型</td></tr><tr><td>interface</td><td>表示接口</td></tr><tr><td>long</td><td>基本数据类型</td></tr><tr><td>native</td><td>表示本地方法</td></tr><tr><td>new</td><td>创建对象</td></tr><tr><td>package</td><td>表示包</td></tr><tr><td>private</td><td>私有</td></tr><tr><td>public</td><td>共有</td></tr><tr><td>return</td><td>返回值</td></tr><tr><td>short</td><td>基本数据类型</td></tr><tr><td>static</td><td>表示静态</td></tr><tr><td>super</td><td>表示父类</td></tr><tr><td>switch</td><td>与 case 搭配使用</td></tr><tr><td>synchronized</td><td>线程同步</td></tr><tr><td>this</td><td>表示当前实例</td></tr><tr><td>throw</td><td>抛出异常</td></tr><tr><td>throws</td><td>方法中主动抛出异常</td></tr><tr><td>try</td><td>与 catch 搭配使用</td></tr><tr><td>void</td><td>表示方法没有返回值</td></tr><tr><td>volatile</td><td>保证线程读取到最新值</td></tr><tr><td>while</td><td>表示循环</td></tr></tbody></table><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>数据类型</li><li>变量名</li><li>变量值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型&#96;+&#96;引用数据类型</span><br></pre></td></tr></table></figure><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>1、声明变量的数据类型和变量名（包含数字、字母、下划线、$，不能包含空格、运算符，不能用关键字命名，不能以数字开头），大小写可以混用，首单词应该小写，后续单词的首字母大写。<br>userId、studentName （驼峰式命名法）<br>2、给内存空间赋值，该值就是变量值。</p><h3 id="Java-的数据类型"><a href="#Java-的数据类型" class="headerlink" title="Java 的数据类型"></a>Java 的数据类型</h3><ul><li>基本数据类型</li></ul><p>byte、int、short、long、float、double、char、boolean</p><blockquote><p>数值类型（整数、小数）</p></blockquote><p>byte 1 个字节 (8位)</p><p>short 2 个字节（16位）</p><p>int 4 个字节（32位）</p><p>long 8 个字节（64位）<br>float 4 个字节（32位） 单精度浮点型<br>double 8 个字节（64位）双精度浮点型</p><blockquote><p>非数值类型（文本）</p></blockquote><p>char 2 个字节（16位）<br>boolean 1 个字节(8位)、判断逻辑是否成立 true 1/false 0</p><ul><li>引用数据类型</li></ul><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul><li>自动转换</li></ul><p>Java 可以自动对某些数据类型进行自动转换。</p><p>规则：只能由<strong>低字节</strong>向<strong>高字节</strong>进行转换，反之则不行。</p><p>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p><ul><li>强制类型转换</li></ul><p>Java 无法自动转换的数据类型，开发者可以通过强制手段进行转换。</p><p>一般来讲强制类型转换可能会造成精度损失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> num = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = (<span class="keyword">int</span>)num;</span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>赋值运算符</li></ul><p>数据类型 变量名 = 数值/变量;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建变量用来记录张三的体重</span></span><br><span class="line"><span class="keyword">double</span> weight1 = <span class="number">70.5</span>;</span><br><span class="line"><span class="comment">//2、创建变量表示李四的体重</span></span><br><span class="line"><span class="keyword">double</span> weight2 = <span class="number">60.5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;交换之前：张三的体重是&quot;</span>+weight1+<span class="string">&quot;,李四的体重是&quot;</span>+weight2);</span><br><span class="line">System.out.println(<span class="string">&quot;进行交换&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> temp = weight1;</span><br><span class="line">weight1 = weight2;</span><br><span class="line">weight2 = temp;</span><br><span class="line">System.out.println(<span class="string">&quot;交换之后：张三的体重是&quot;</span>+weight1+<span class="string">&quot;,李四的体重是&quot;</span>+weight2);</span><br></pre></td></tr></table></figure><ul><li><p>算术运算符</p><ul><li>基本算术运算符<br>+、-、*、/、%、++、–<br>变量1 + 变量2<br>变量1 - 变量2<br>变量1 * 变量2<br>变量1 / 变量2<br>变量1 % 变量2<br>变量++、++变量<br>变量–、–变量<br>变量++：先操作，再运算。<br>++变量：先运算，再操作。</li><li>复合算术运算符<br>+=、-=、*=、/=、%=<br>变量1 += 变量2：先求出变量1和变量2之和，再把计算结果赋值给变量1，变量1 = 变量1 + 变量2</li></ul></li><li><p>关系运算符</p><p>==、!=、&gt;、&lt;、&gt;=、&lt;=</p></li><li><p>逻辑运算符</p></li></ul><p>逻辑运算符<strong>只能用于 boolean 类型</strong>的数据运算，判断 boolean 数据之间的逻辑关系，与、或、非。<br>&amp;（与）、｜（或）、!（非）、&amp;&amp;（短路与）、||（短路或）<br><strong>参与逻辑运算符的变量都是 boolean 的。</strong></p><p>1、变量1 &amp; 变量2：只有当变量 1 和变量 2 都为 true，结果为 true，否则为 false。 【A &amp; B AB都会执行】<br>2、变量1 ｜ 变量2：变量 1 和变量 2 只要有一个为 true，结果为 true，否则为 false。【A | B AB都会执行】<br>3、!变量1：若变量 1 为 true，结果为 false，若变量 1 为 false，结果为 true。<br>4、变量1 &amp;&amp; 变量2：只有当变量 1 和变量 2 都为 true，结果为 true，否则为 false。 【A &amp;&amp; B 若A为false，B不执行】<br>5、变量1 || 变量2：变量 1 和变量 2 只要有一个为 true，结果为 true，否则为 false。【A || B 若A为true，B不执行】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">11</span>;</span><br><span class="line">System.out.println((++num1==num2)||(num1++==num2));</span><br><span class="line">System.out.println(num1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">11</span>;</span><br><span class="line">System.out.println((++num1==num2)|(num1++==num2));</span><br><span class="line">System.out.println(num1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">11</span>;</span><br><span class="line">System.out.println((num1++==num2)&amp;(++num1==num2));</span><br><span class="line">System.out.println(num1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">11</span>;</span><br><span class="line">System.out.println((num1++==num2)&amp;&amp;(++num1==num2));</span><br><span class="line">System.out.println(num1);</span><br></pre></td></tr></table></figure><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>三元运算符、三目运算符、三元表达式</p><p>根据不同的条件给同一个变量赋不同的值，变量 = 条件?值1:值2.</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul><li>十进制和二进制的转换</li></ul><blockquote><p>十进制转二进制：</p><p>目标数除以2，若能除尽，该位记做0，若除不尽，该位记做1，再对商继续除以2，以此类推，直到商为0，然后把每一位的结果反序组合就是对应的二进制。</p></blockquote><p>10：1010</p><p>17：10001</p><blockquote><p>二进制转十进制：</p><p>从目标数的最后侧起，本位的数值乘以本位的权重，权重就是2的第几位的位数减一次方，将每一位的值进行相加，得到的结果就是对应的十进制。</p></blockquote><p>位运算符：</p><ul><li>&amp;（按位与）</li><li>｜（按位或）</li><li>^（按位异或）</li><li>&lt;&lt;（左移）、&gt;&gt;（右移）</li></ul><blockquote><p>变量1 &amp; 变量2：先把变量 1 和变量 2 转为二进制，每一位的数字一一对应，进行比较判断，若都为 1，则该位记做 1，否则记做 0。</p></blockquote><blockquote><p>变量1 |变量2：先把变量 1 和变量 2 转为二进制，每一位的数字一一对应，进行比较判断，只要有一个为 1，则该位记做 1，否则记做 0。</p></blockquote><blockquote><p>变量1 ^ 变量2：先把变量 1 和变量 2 转为二进制，每一位的数字一一对应，进行比较判断，相同记做 0，不同记做 1。</p></blockquote><blockquote><p>变量1 &lt;&lt; 变量2：变量1乘以2的变量2次方</p></blockquote><p>2 &lt;&lt; 3 : 2 * 8 = 16</p><blockquote><p>变量1 &gt;&gt; 变量2：变量1除以2的变量2次方</p></blockquote><p>2 &gt;&gt; 3：2/8 = 0</p><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>!&gt;算术运算符&gt;关系运算符&gt;逻辑运算符(&amp;&amp;&gt;||)</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="选择流程控制"><a href="#选择流程控制" class="headerlink" title="选择流程控制"></a>选择流程控制</h3><ul><li>if else</li></ul><p>用来判断某个条件是否成立，然后执行不同的逻辑运算。</p><p>基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">  <span class="comment">//条件成立的代码</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//条件不成立的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多重 if</li></ul><blockquote><p>173 M</p><p>173～178 L</p><p>178 XL</p></blockquote><ul><li>if 后面必须跟条件</li><li>else 后面不能跟条件</li><li>else 后面可以根据{}，也可以跟 if</li></ul><h3 id="循环流程控制"><a href="#循环流程控制" class="headerlink" title="循环流程控制"></a>循环流程控制</h3><ul><li>switch-case</li></ul><p>与 if 不同的是，switch-case 只能完成等值判断，而无法完成判断大小。<br>如果是判断两个值是否相等，可以使用 switch-case，如果比较两个值的大小关系，则不能使用 switch-case。<br>switch 支持 int、short、byte、char、枚举、String 类型，不支持 boolean 类型。<br>基本语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)&#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">        <span class="keyword">break</span>；</span><br><span class="line">            <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">        breka;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>case 判断变量是否等于某个值，default 表示所有的 case 都不成立的情况下所执行的代码。</p><ul><li>1 奖励 2000</li><li>2 奖励 1000</li><li>3 奖励 500</li><li>否则没有奖励</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> placing = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(placing == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖励2000元&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(placing == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;奖励1000元&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(placing == <span class="number">3</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;奖励500元&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有奖励&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(placing) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;奖励2000元&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;奖励1000元&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;奖励500元&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;没有奖励&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>for、while、do-while、foreach<br>循环四要素：</p><ul><li>初始化循环变量</li><li>循环条件</li><li>循环体</li><li>更新循环变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span></span><br><span class="line">    初始化循环变量</span><br><span class="line">    <span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">        循环体</span><br><span class="line">            更新循环变量</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化循环变量</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//循环条件</span></span><br><span class="line"><span class="keyword">while</span>(num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="comment">//更新循环变量</span></span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">String flag = <span class="string">&quot;y&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(flag.equals(<span class="string">&quot;y&quot;</span>)) &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;请输入学生学号：&quot;</span>);</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">    <span class="keyword">switch</span>(id) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;张三的成绩是96&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;李四的成绩是91&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;王五的成绩是89&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入正确的学号&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">&quot;是否继续？y/n&quot;</span>);</span><br><span class="line">    flag = scanner.next();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;感谢使用学生成绩查询系统&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>-<span class="keyword">while</span></span><br><span class="line">    <span class="comment">//初始化循环变量</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="comment">//更新循环变量</span></span><br><span class="line">    num++;</span><br><span class="line">&#125;<span class="keyword">while</span>(num&lt;<span class="number">10</span>);</span><br><span class="line"><span class="comment">//循环条件</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;张三参加体能测试，跑1000米&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;是否合格？y/n&quot;</span>);</span><br><span class="line">    result = scanner.next();</span><br><span class="line">&#125;<span class="keyword">while</span>(result.equals(<span class="string">&quot;n&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;合格，通过测试&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span></span><br><span class="line">    <span class="keyword">for</span>(初始化循环变量;循环条件;更新循环变量)&#123;</span><br><span class="line">        循环体</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num = <span class="number">0</span>;num &lt; <span class="number">10</span>;num++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while、do-while、for 3种循环的区别</p><ul><li>相同点：都遵循循环四要素，初始化循环变量、循环条件、循环体、更新循环变量。</li><li>不同点：<ul><li>while 和 do-while 适用于循环次数不确定的业务场景；for 适用于循环次数确定的场景。</li><li>while 和 for 都是先判断循环条件，再执行循环体；do-while 先执行循环体，再判断循环条件。</li></ul></li></ul><p>分别使用 while、do-while、for 循环输出 10 以内的所有奇数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//while循环</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(num &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(num%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//do-while循环</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(num%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">&#125;<span class="keyword">while</span>(num &lt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num = <span class="number">0</span>;num &lt;= <span class="number">10</span>;num++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(num%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure><p>for 循环只适用于循环次数确定的场景下(for 也可以适用于循环次数不确定的场景，只不过一般不会用这种方式进行开发)，while 和 do-while 循环次数确定或者不确定都可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">&quot;n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(;result.equals(<span class="string">&quot;n&quot;</span>);) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;张三参加体能测试，跑1000米&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;是否合格？y/n&quot;</span>);</span><br><span class="line">    result = scanner.next();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;合格，通过测试&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><p>数组就是一种可以存储大量数据类型相同的变量的数据结构，数组就是一个具有相同数据类型的数据集合。<br>数组中的数据必须是同一种数据类型的。</p><h3 id="数组的基本要素"><a href="#数组的基本要素" class="headerlink" title="数组的基本要素"></a>数组的基本要素</h3><ul><li>数组名称</li><li>数组元素</li><li>元素下标</li><li>数据类型</li></ul><p>数组本身就是一个变量，数组名称就是变量名，数组中保存的每一个数据都会有一个下标（从 0 开始）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明数组</span></span><br><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line"><span class="comment">//分配内存空间</span></span><br><span class="line">array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line"><span class="comment">//给数组赋值</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">array[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">array[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">array[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">array[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">array[<span class="number">5</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] array2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] array3 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="数组常见的错误"><a href="#数组常见的错误" class="headerlink" title="数组常见的错误"></a>数组常见的错误</h3><ul><li>数据类型不匹配。</li><li>边声明边赋值的方式，代码必须写在同一行，不能换行。</li><li>数组下标越界。</li></ul><h3 id="数组的常用操作及方法"><a href="#数组的常用操作及方法" class="headerlink" title="数组的常用操作及方法"></a>数组的常用操作及方法</h3><ul><li>求数组的最大值</li><li>求数组的最小值</li><li>在数组的指定位置插入数据</li><li>对数组进行排序</li></ul><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组简单理解即一维数组中保存的值是另外一个一维数组。<br>变量、数据类型、流程控制、循环、数组。<br>用户管理系统</p><ul><li>查询用户：将系统中保存的全部用户信息在控制台打印输出。</li><li>添加用户：向系统中添加新的用户信息，如果添加的用户已经存在，给出提示信息。</li><li>删除用户：输入用户名，进行删除操作，若输入的用户名不存在，给出提示信息。</li><li>账号冻结：输入用户名，进行冻结操作，若输入的用户名不存在或者该用户已经被冻结，给出相应提示。</li><li>账号解冻：输入用户名，进行解封操作，若输入的用户名不存在或者该用户状态正常，给出相应提示。</li><li>退出系统：跳出循环，给出提示信息。</li></ul><h2 id="面向对象程序"><a href="#面向对象程序" class="headerlink" title="面向对象程序"></a>面向对象程序</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象编程思想：将程序模块化的思想。</p><ul><li>什么是面向对象？</li></ul><p>面向对象编程思想诞生之前，程序开发采用的是面向过程的结构化编程方式，是一种面向功能划分的软件结构。<br>最小粒度细化到方法这一层。<br>面向过程注重的是每一个步骤，面向对象关注点在于整件事情的模块化结构。</p><ul><li>类和对象</li></ul><p>类和对象的关系<br>每个对象都有特定的特征：1、属性。2、方法。<br>属性指的是对象的静态特征，方法用来描述对象的动态特征。<br>对象是用来描述客观存在的一个实体，改实体是由一组属性和方法构成。<br>类是与对象紧密结合的另外一个概念，类是产生对象的模版，所有的对象都是通过类来创建的。<br>二者的关系：类是对象的抽象化描述，这些对象具有相同的特征和动作（属性和方法）。<br>对象是类的具体实例。<br>Java 程序是以类位组织单元，程序运行时的主体是通过类创建的具体对象。</p><p><strong>三大特征：封装、继承、多态</strong></p><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="comment">//定义属性，属性名符合驼峰式命名法</span></span><br><span class="line">    <span class="keyword">public</span> 数据类型 属性名;</span><br><span class="line">    <span class="comment">//定义方法，方法名符合驼峰式命名法</span></span><br><span class="line">    <span class="keyword">public</span> 返回值类型 方法名(参数列表:数据类型 参数名)&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 关于返回值的定义分为两类：有返回值和无返回值，有返回值的方法需要在方法定义时指定返回值的数据类型，并在方法体中用 return 将结果返回给外部调用者，加法运算。<br>如果一个方法不需要进行返回操作，将返回值类型定义为 void。<br>参数列表是指外部在调用该方法时需要传入到方法内部进行运算的数据。</p><h3 id="构造函数、构造方法、构造器"><a href="#构造函数、构造方法、构造器" class="headerlink" title="构造函数、构造方法、构造器"></a>构造函数、构造方法、构造器</h3><p>构造函数是一种特殊的方法，普通方法是用来描述某个动作的，构造方法是用来创建对象的。</p><ul><li>方法名必须与类名一致。</li><li>不需要定义返回值类型。</li></ul><p>构造函数可分为有参构造和无参构造，有参构造是指带参数的构造函数，无参构造是指没有参数的构造函数。<br>任何一个类都默认自带一个无参构造函数，如果手动在类中定义一个有参构造，则会覆盖默认的无参构造。</p><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>this 用来指代当前类的实例化对象，通过 this 可以调用当前类的属性和方法，比如在有参构造中，通过 this 将外部传入的值赋给当前类的实例化对象。<br>this 除了可以在类中访问属性也可以在类中调用方法，类中的方法可以分为两类：构造方法、普通方法，用 this 调用这两类方法的语法也不同。</p><p>1、调用构造函数的语法是 this(参数列表)，不能在普通方法中使用 this 调用构造函数。<br>2、用 this 调用普通方法，this.方法名(参数列表)，可以在构造函数中使用，也可以在普通方法中使用。</p><h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><p>变量的作用域是指在程序中可以通过变量名来访问该变量的范围，变量的作用域由变量被声明时所在位置决定的，Java 中根据不同的作用域可以将变量分为成员变量和局部变量。<br>局部变量：如果一个变量<strong>在方法中声明</strong>，则该变量是局部变量。<br>成员变量：如果一个变量<strong>在方法外，类中声明</strong>，则该变量是成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">2</span>; <span class="comment">//成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>; <span class="comment">//局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、成员变量和局部变量的区别在于作用域不同，成员变量的作用域在整个类中，类中的每个方法都可以访问该变量，局部变量的作用域只在定义该变量的方法中，出了方法体就无法访问。<br>2、成员变量和局部变量的初始值也不同，局部变量不会赋初始值，成员变量会赋初始值，具体的值是由成员变量的数据类型决定的。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是指将类的属性隐藏在内部，外部不能直接访问和修改，如何实现？通过修改成员变量的可见性，从公有改为私有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生信息如下：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;学生编号：&quot;</span>+id);</span><br><span class="line">        System.out.println(<span class="string">&quot;学生姓名：&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;学生年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的数值有误！&quot;</span>);</span><br><span class="line">            age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装的核心思想就是尽可能把<strong>属性都隐藏在内部</strong>，对外提供方法来访问，我们可以在这些方法中添加逻辑处理来实现过滤，以屏蔽错误数据的赋值。<br>封装的步骤：</p><ul><li>修改属性（成员变量）的访问权限为私有，使得外部不能直接访问。</li><li>提供外部可以直接调用的方法。</li><li>在该方法中加入对于属性的逻辑控制，避免出现逻辑上的错误。</li></ul><blockquote><p>什么是访问权限？</p></blockquote><p>访问权限是指该属性可以被直接访问的范围，是在属性定义时设定的，访问权限的可选项一共有 4 种：区别在于作用域范围不同。</p><ul><li>public</li><li>private</li><li>默认（不写）</li><li>protected</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static 表示静态或者全局，可以用来修饰成员变量和成员方法以及代码块。<br>使用 static 修饰的成员变量和成员方法<strong>独立于该类的任何一个实例化对象</strong>，访问时不依赖于该类的对象，而是直接通过类去访问，可以理解为被该类的所有实例对象所共用，所以说是<strong>全局的</strong>。<br>static 还可以修饰代码块，被 static 修饰的代码块叫做静态代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代码块的特点是只执行一次，什么时候执行？当这个类被加载到内存时执行，不需要开发者手动调用，会自动执行。<br>被加载到内存中的类叫做运行时类，静态代码块就是在加载类的时候执行的，因为类只加载一次，所以静态代码块也只执行一次。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>什么是继承？</li></ul><p>继承是用来描述类之间的关系的，即一个类继承（拥有）另外一个类中的属性和方法，被继承的类叫做父类，继承父类的类叫做子类。<br>继承的基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类名</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(<span class="keyword">char</span> gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中的继承是单继承，也就是说一个子类只能有一个直接父类。</p><h4 id="子类访问父类"><a href="#子类访问父类" class="headerlink" title="子类访问父类"></a>子类访问父类</h4><p><strong>创建一个子类对象的时候，会默认先创建一个父类对象，无论是通过有参构造或是无参构造来创建子类对象，都是通过【无参构造来创建父类对象的】。</strong><br>可以通过 super 关键字让子类创建对象时调用父类的有参构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;通过无参构造创建了Student对象&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类可以访问父类的构造方法、普通方法、成员变量，都是通过 super 关键字来完成，具体语法：<br>构造方法：super(参数列表)<br>普通方法：super.方法名(参数列表)<br>成员变量：super.成员变量名<br>在子类的构造方法中，可以通过 super 访问父类的构造方法和普通方法。<br>在子类的普通方法中，只能通过 super 访问父类的普通方法。</p><h4 id="子类的访问权限"><a href="#子类的访问权限" class="headerlink" title="子类的访问权限"></a>子类的访问权限</h4><p>访问权限修饰符：public、protected、默认修饰符、private。</p><table><thead><tr><th>属性</th><th>同一个类中</th><th>同包</th><th>子类（不同包）</th><th>不同包</th></tr></thead><tbody><tr><td>public</td><td>可以访问</td><td>可以访问</td><td>可以访问</td><td>可以访问</td></tr><tr><td>protected</td><td>可以访问</td><td>可以访问</td><td>可以访问</td><td>不能访问</td></tr><tr><td>默认修饰符</td><td>可以访问</td><td>可以访问</td><td>不能访问</td><td>不能访问</td></tr><tr><td>private</td><td>可以访问</td><td>不能访问</td><td>不能访问</td><td>不能访问</td></tr></tbody></table><p>包：package，用来管理 Java 文件，一个项目中不可避免会出现同名的 Java 类，为了防止产生冲突，可以把同名的 Java 类分别放入不同的包中。<br>包的命名规范：包名由小写字母组成，不能以 . 开头或结尾，可以包含数字，但不能以数字开头，使用 . 来分层。<br>包的命名方式一般采用网络域名的反向输出，如 com.company.test/com.company.entity。</p><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>子类在继承父类方法的基础上，对父类方法重新定义并覆盖的操作叫做方法重写。<br><strong>构造方法不能被重写</strong>，方法重写的规则：<br>1、父子类的方法名相同。<br>2、父子类的方法参数列表相同。<br>3、子类方法的返回值与父类方法返回值<strong>类型相同或者是其子类</strong>。<br>4、子类方法的<strong>访问权限不能小于父类</strong>。</p><h3 id="方法重写-VS-方法重载"><a href="#方法重写-VS-方法重载" class="headerlink" title="方法重写 VS 方法重载"></a>方法重写 VS 方法重载</h3><p>位置：方法重写在子类中对父类方法进行重写，方法重载是在同一个类中。<br>方法名：方法重写相同，方法重载相同。<br>参数列表：方法重写相同，方法重载不同。<br>返回值：方法重写相同或是其子类，方法重载没有要求。<br>访问权限：方法重写不能小于父类，方法重载没有要求。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个事物具有多种表现形态，在 Java 程序中，定义一个方法，在具体的生成环境中根据不同的需求呈现不同的业务逻辑，多态的前提是继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memeber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdinaryMember</span> <span class="keyword">extends</span> <span class="title">Memeber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通会员买书打9折&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类二 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMember</span> <span class="keyword">extends</span> <span class="title">Memeber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;超级会员买书打6折&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cashier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Memeber memeber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memeber <span class="title">getMemeber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memeber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemeber</span><span class="params">(Memeber memeber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memeber = memeber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">settlement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memeber.buyBook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OrdinaryMember ordinaryMember = <span class="keyword">new</span> OrdinaryMember();</span><br><span class="line">        SuperMember superMember = <span class="keyword">new</span> SuperMember();</span><br><span class="line">        Cashier cashier = <span class="keyword">new</span> Cashier();</span><br><span class="line">        cashier.setMemeber(superMember);</span><br><span class="line">        cashier.settlement(ordinaryMember);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态的具体使用有两种形式：<br>1、定义方法时<strong>形参类型为父类</strong>，实际调用方法时传入<strong>子类类型的参数</strong>。<br>2、定义方法时<strong>返回值类型为父类</strong>，实际调用方法时<strong>返回子类对象</strong>。<br>以上两种形式的基本原理都是<strong>父类引用可以指向子类对象</strong>。</p><h3 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h3><p>如果一个方法只有方法的声明而没有具体的方法实现，这个方法就叫做抽象方法，Java 中的抽象方法需要使用 abstract 关键字来修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buyBook</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>一旦类中定义了抽象方法，则该类也必须声明为抽象类，需要在类定义处添加 abstract 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buyBook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类与普通类的区别是抽象类不能被实例化，抽象方法与普通方法的区别是抽象方法没有方法体。<br>抽象类中可以没有抽象方法，但是包含了抽象方法的类必须定义为抽象类。即我们可以在抽象类中定义普通方法，但是在普通类中不能定义抽象方法。<br>如果父类是抽象类，一旦子类继承了该抽象父类，则子类必须对父类的抽象方法进行重写，否则程序报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buyBook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.southwind.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMember</span> <span class="keyword">extends</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;超级会员买书打6折&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子类也是抽象类，则可以不用重写父类的抽象方法。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>什么是接口？</li></ul><p>接口是由抽象类衍生出来的一个概念，并由此产生了一种编程方式：面向接口编程。<br>面向接口编程就是将程序中的业务模块进行分离，以接口的形式去对接不同的业务模块。<br>面向接口编程的优点：当用户需求变更时，只需要切换不同的实现类，而不需要修改串联模块的接口，减少对系统的影响。<br>1、能够最大限度实现解耦合，降低程序的耦合性。<br>2、使程序易于扩展。<br>3、有利于程序的后期维护。</p><ul><li>如何使用接口</li></ul><p>接口在 Java 中是独立存在的一种结构，和类相似，我们需要创建一个接口文件，Java 中用 class 关键字来标识类，用 interface 来标识接口，基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> 返回值 方法名(参数列表)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口其实就是一个抽象类，极度抽象的抽象类。</strong><br>抽象类：一个类中一旦存在没有具体实现的抽象方法时，那么该类就必须定义为抽象类，同时抽象类允许存在非抽象方法。<br>但是接口完全不同，接口中不能存在非抽象方法，接口中必须全部是抽象方法。<br>因为接口中必须全部都是抽象方法，所以修饰抽象方法的关键字 abstract 可以省略。<br>接口中允许定义成员变量，但是有如下要求：<br>1、不能定义 private 和 protected 修饰的成员变量，只能定义<strong>public和默认访问</strong>权限修饰符修饰的成员变量。<br>2、接口中的成员变量在定义时就必须完成初始化。<br>3、接口中的成员变量都是静态常量，即可以直接通过接口访问，同时值不能被修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ID = <span class="number">0</span>;</span><br><span class="line">    String NAME = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用接口时，不能直接实例化接口对象，而必须实例化其实现类对象，实现类本身就是一个普通的 Java 类，创建实现类的代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 implements 关键字来指定实现类具体要实现的接口，在实现类的内部需要对接口的所有抽象方法进行实现，同时要求<strong>访问权限修饰符、返回值类型、方法名和参数列表</strong>必须完全一致。<br>接口和继承，Java 只支持单继承，但是接口可以多实现（一个实现类可以同时实现多个接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ID = <span class="number">0</span>;</span><br><span class="line">    String NAME = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口二</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterface</span>,<span class="title">MyInterface2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;实现了跑步的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;实现了飞行的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyInterfaceImpl myInterfaceImpl = <span class="keyword">new</span> MyInterfaceImpl();</span><br><span class="line">        myInterfaceImpl.fly();</span><br><span class="line">        myInterfaceImpl.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object 是 Java 官方提供的类，存放在 java.lang 包中，该类是所有类的直接父类或者间接父类，无论是 Java 提供的类还是开发者自定义的类，都是 Object 的直接子类或间接子类，Java 中的任何一个类都会继承 Object 中的 public 和 protected 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hashCode();</span><br><span class="line">getClass();</span><br><span class="line">equals(<span class="keyword">null</span>);</span><br><span class="line">clone();</span><br><span class="line">toString();</span><br><span class="line">notify();</span><br><span class="line">notifyAll();</span><br><span class="line">wait();</span><br><span class="line">wait(<span class="number">1000L</span>);</span><br><span class="line">wait(<span class="number">1000L</span>, <span class="number">100</span>);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>Object 类中经常被子类重写的方法：<br>1、public String toString() 以字符串的形式返回对象的信息<br>2、public boolean equals(Object obj) 判断两个对象是否相等<br>3、public native int hashCode() 返回对象的<code>散列码</code></p><ul><li>toString</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写之后</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;People [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, score=&quot;</span> + score + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>equals</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写之后</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  People people = (People)obj;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.id == people.id &amp;&amp; <span class="keyword">this</span>.name.equals(people.name) &amp;&amp; <span class="keyword">this</span>.score.equals(people.score)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>hashCode</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//重写之后</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>) (id*name.hashCode()*score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ul><li>什么是包装类？</li></ul><p>包装类是 Java 提供的一组类，专门用来创建 8 种基本数据类型对应的对象，一共有 8 个包装类，存放在 java.lang 包中，基本数据类型对应的包装类。</p><table><thead><tr><th>byte</th><th>Byte</th></tr></thead><tbody><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>包装类的体系结构</p><p>Java 官方提供的一组类，这组类的作用是将基本数据类型的数据封装成引用类型。<br>Byte、Integer、Short、Long、Float、Double、Boolean、Characte</p><p><img src="https://img-blog.csdnimg.cn/20210219173159392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><p>装箱和拆箱是包装类的特有名词，装箱是指将基本数据类型转为对应的包装类对象，拆箱就是将包装类对象转为对应的基本数据类型。</p><p>装箱与拆箱<br>装箱是指将基本数据类型转换为包装类对象。<br>拆箱是指将包装类对象转换为基本数据类型。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>1、public Type(type value) 【<strong>即原类型</strong>】<br>每个包装类都提供了一个有参构造函数：public Type(type value)，用来实例化包装类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line">Byte byt = <span class="keyword">new</span> Byte(b);</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line">Short shor = <span class="keyword">new</span> Short(s);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(i);</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">4</span>;</span><br><span class="line">Long lon = <span class="keyword">new</span> Long(l);</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">5.5f</span>;</span><br><span class="line">Float flo = <span class="keyword">new</span> Float(f);</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">6.6</span>;</span><br><span class="line">Double dou = <span class="keyword">new</span> Double(d);</span><br><span class="line"><span class="keyword">char</span> cha = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">Character charac = <span class="keyword">new</span> Character(cha);</span><br><span class="line"><span class="keyword">boolean</span> bo = <span class="keyword">true</span>;</span><br><span class="line">Boolean bool = <span class="keyword">new</span> Boolean(bo);</span><br><span class="line">System.out.println(byt);</span><br><span class="line">System.out.println(shor);</span><br><span class="line">System.out.println(integer);</span><br><span class="line">System.out.println(lon);</span><br><span class="line">System.out.println(flo);</span><br><span class="line">System.out.println(dou);</span><br><span class="line">System.out.println(charac);</span><br><span class="line">System.out.println(bool);</span><br></pre></td></tr></table></figure><p>2、public Type(String value)/public Type(char value) 【<strong>即字符/字符串类型</strong>】<br>每个包装类还有一个重载构造函数：</p><p>Character 类的重载构造函数：<code>public Type(char value)</code>，其他包装类的重载构造函数：<code>public Type(String value)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Byte byt = <span class="keyword">new</span> Byte(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Short shor = <span class="keyword">new</span> Short(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">Long lon = <span class="keyword">new</span> Long(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">Float flo = <span class="keyword">new</span> Float(<span class="string">&quot;5.5f&quot;</span>);</span><br><span class="line">Double dou = <span class="keyword">new</span> Double(<span class="string">&quot;6.6&quot;</span>);</span><br><span class="line">Character charac = <span class="keyword">new</span> Character(<span class="string">&#x27;J&#x27;</span>);</span><br><span class="line">Boolean bool = <span class="keyword">new</span> Boolean(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(byt);</span><br><span class="line">System.out.println(shor);</span><br><span class="line">System.out.println(integer);</span><br><span class="line">System.out.println(lon);</span><br><span class="line">System.out.println(flo);</span><br><span class="line">System.out.println(dou);</span><br><span class="line">System.out.println(charac);</span><br></pre></td></tr></table></figure><p>需要注意的是，Boolean 类的构造函数中，当参数为 “true” 时，Boolean 值为 true，当参数不为 “true”，Boolean 值为 false。</p><h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>1、public Type(type value)<br>2、public Type(String value)/public Type(char value)<br>3、<strong>valueOf</strong>(type value) 静态方法，参数是基本数据类型的数据<br>每一个包装类都有一个 valueOf(type value) 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line">Byte byt = Byte.valueOf(b);</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line">Short shot = Short.valueOf(s);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">Integer integer = Integer.valueOf(i);</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">4L</span>;</span><br><span class="line">Long lon = Long.valueOf(l);</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">5.5f</span>;</span><br><span class="line">Float floa = Float.valueOf(f);</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">6.6</span>;</span><br><span class="line">Double doub = Double.valueOf(d);</span><br><span class="line"><span class="keyword">boolean</span> boo = <span class="keyword">true</span>;</span><br><span class="line">Boolean bool = Boolean.valueOf(boo);</span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">Character cha = Character.valueOf(ch);</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//valueOf(String value)/valueOf(char value) 专门为 Character 转换使用的，</span></span><br><span class="line"><span class="comment">//其他的 7 个包装类都可以使用 valueOf(String value)。</span></span><br><span class="line">Byte byt = Byte.valueOf(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Short sho = Short.valueOf(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">Integer integer = Integer.valueOf(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">Long lon = Long.valueOf(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">Float flo = Float.valueOf(<span class="string">&quot;5.5f&quot;</span>);</span><br><span class="line">Double dou = Double.valueOf(<span class="string">&quot;6.6&quot;</span>);</span><br><span class="line">Boolean boo = Boolean.valueOf(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">Character cha = Character.valueOf(<span class="string">&#x27;J&#x27;</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是 Boolean.valueOf(String value) 方法中，当 value 为 “true” 时，Boolean 的值为 true，否则，Boolean 的值为 false。</p><h4 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h4><p>1、<code>*Value()</code><br>每个包装类都有一个 *Value() 方法，通过该方法可以将包装类转为基本数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Byte byt = Byte.valueOf(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Short sho = Short.valueOf(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">Integer integer = Integer.valueOf(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">Long lon = Long.valueOf(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">Float flo = Float.valueOf(<span class="string">&quot;5.5f&quot;</span>);</span><br><span class="line">Double dou = Double.valueOf(<span class="string">&quot;6.6&quot;</span>);</span><br><span class="line">Boolean boo = Boolean.valueOf(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">Character cha = Character.valueOf(<span class="string">&#x27;J&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">byte</span> b = byt.byteValue();</span><br><span class="line"><span class="keyword">short</span> sh = sho.shortValue();</span><br><span class="line"><span class="keyword">int</span> i = integer.intValue();</span><br><span class="line"><span class="keyword">long</span> l = lon.longValue();</span><br><span class="line"><span class="keyword">float</span> f = flo.floatValue();</span><br><span class="line"><span class="keyword">double</span> d = dou.doubleValue();</span><br><span class="line"><span class="keyword">boolean</span> bo = boo.booleanValue();</span><br><span class="line"><span class="keyword">char</span> c = cha.charValue();</span><br></pre></td></tr></table></figure><p>2、<code>parse*(String value)</code><br>除了 <code>Character</code> 类以外的每一个包装类都有一个<code>静态方法</code>可以将字符串类型转为基本数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = Byte.parseByte(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">short</span> s = Short.parseShort(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> l = Long.parseLong(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"><span class="keyword">float</span> f = Float.parseFloat(<span class="string">&quot;5.5&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(<span class="string">&quot;6.6&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> bo = Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure><p>3、toString(type value)<br>每个包装类都有该方法，作用是将基本数据类型转为 String 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line">String bstr = Byte.toString(b);</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line">String sstr = Short.toString(s);</span><br><span class="line">String i = Integer.toString(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">4L</span>;</span><br><span class="line">String lstr = Long.toString(l);</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">5.5f</span>;</span><br><span class="line">String fstr = Float.toString(f);</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">6.6</span>;</span><br><span class="line">String dstr = Double.toString(d);</span><br><span class="line"><span class="keyword">boolean</span> bo = <span class="keyword">true</span>;</span><br><span class="line">String bostr = Boolean.toString(bo);</span><br><span class="line">String chstr = Character.toString(<span class="string">&#x27;J&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>什么是异常？</li></ul><p>Java 中的错误大致可以分为两类：<br>1、一类是编译时错误，一般是指语法错误。<br>2、另一类是运行时错误。<br>Java 中有一组专门用来描述各种不同的运行时异常，叫做<code>异常类</code>，Java 结合异常类提供了处理错误的机制。<br>具体步骤是当程序出现错误时，会创建一个包含错误信息的异常类的实例化对象，并自动将该对象提交给系统，由系统转交给能够处理异常的代码进行处理。<br>异常可以分为两类：<br><strong>【Error 和 Exception】：</strong><br>1、Error 是指系统错误，JVM 生成，我们编写的程序无法处理。<br>2、Exception 指程序运行期间出现的错误，我们编写的程序可以对其进行处理。</p><p>Error 和 Exception 都是 Throwable 的子类，Throwable、Error、Exception 都是存放在 java.lang 包中。</p><ul><li>异常的使用</li></ul><p>异常的使用需要用到两个关键字 try 和 catch，并且这两个关键字需要结合起来使用，用 try 来监听可能会抛出异常的代码，一旦捕获到异常，生成异常对象并交给 catch 来处理，基本语法如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能抛出异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">10</span>/<span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            <span class="keyword">if</span>(e.getMessage().equals(<span class="string">&quot;/ by zero&quot;</span>)) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;分母不能为0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 try 和 catch，还可以使用 finally 关键字来处理异常，finally 的作用？<br>无论程序是否抛出异常，finally 代码块中的代码一定都会执行，finally 一般跟在 catch 代码块的后面，基本语法如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能抛出异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//必须执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p>Java 将运行时出现的错误全部封装成类，并且不是一个类，而是一组类。同时这些类之间是有层级关系的，由树状结构一层层向下分级，处在最顶端的类是 Throwable，是所有异常类的根结点。<br>Throwable 有两个直接子类：</p><ul><li>Error<ul><li>VirtualMachineError<ul><li>StackOverflowError</li><li>OutOfMemoryError</li></ul></li><li>AWTError</li><li>IOError</li></ul></li><li>Exception。</li><li>IOException</li><li>FileLockInterruptionException</li><li>FileNotFoundException</li><li>FilerException</li><li>RuntimeException<ul><li>ArithmeticException</li><li>ClassNotFoundException</li><li>IllegalArggumentException</li><li>ArrayIndexOutOfBoundsException</li><li>NullPointerException</li><li>NoSuchMethodException</li><li>NumberFormatException</li></ul></li></ul><h3 id="throw-和-throws"><a href="#throw-和-throws" class="headerlink" title="throw 和 throws"></a>throw 和 throws</h3><p>throw 和 throws 是 Java 在处理异常时使用的两个关键字，都可以用来抛出异常，但是使用的方式和表示的含义完全不同。<br>Java 中抛出异常有 3 种方式：</p><ul><li>try-catch</li><li>使用 throw 是开发者主动抛出异常，即读到 throw 代码就一定抛出异常，基本语法：throw new Exception()，是一种基于代码的逻辑而主动抛出异常的方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        test(array,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">3</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(array[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>try-catch 和 throw 都是作用于具体的逻辑代码，throws 是作用于方法的，用来描述方法可能会抛出的异常。</li></ul><blockquote><p>如果方法 throws 的是 RuntimeException 异常或者其子类，外部调用时可以不处理，JVM 会处理。<br>如果方法 throws 的是 Exception 异常或者其子类，外部调用时必须处理，否则报错。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        test(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String str)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><ul><li>自动捕获 try-cath</li><li>throw 主动抛出异常</li><li>throws 修饰可能抛出异常的方法</li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>除了使用 Java 提供的异常外，也可以根据需求来自定义异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNumberException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNumberException</span><span class="params">(String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">System.out.println(test.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(object <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)object;</span><br><span class="line"><span class="keyword">return</span> ++num;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">String error = <span class="string">&quot;传入的参数不是整数类型&quot;</span>;</span><br><span class="line">MyNumberException myNumberException = <span class="keyword">new</span> MyNumberException(error);</span><br><span class="line"><span class="keyword">throw</span> myNumberException;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h3><p>封装、继承、多态、抽象、接口、异常完成一个汽车查询系统。</p><p>需求描述：共有 3 种类型的汽车：小轿车、大巴车、卡车，其中小轿车的座位数是 4 座，大巴车座位数是 53 座，卡车座位数是 2 座，要求使用封装、继承、抽象来完成车辆的定义。</p><p>可以对车辆信息进行修改，卡车可以运货但是载重量不能超过 12 吨，使用自定义异常来处理错误，小轿车和大巴车没有此功能，要求使用接口来实现。</p><p>Car</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String color;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name, String color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">seatNum</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sedan</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sedan</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sedan</span><span class="params">(String name, String color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name, color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">seatNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;4座&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bus</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bus</span><span class="params">(String name, String color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name, color);</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">seatNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;53座&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Truck</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Truck</span> <span class="keyword">extends</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Truck</span><span class="params">(String name, String color,<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name, color);</span><br><span class="line"><span class="keyword">this</span>.weight = weight;</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">seatNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;2座&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getweight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Container</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getweight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CarException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CarException</span><span class="params">(String error)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Scanner scanner;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Sedan sedan;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Bus bus;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Truck truck;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Car[] cars;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">sedan = <span class="keyword">new</span> Sedan(<span class="string">&quot;小轿车&quot;</span>,<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">bus = <span class="keyword">new</span> Bus(<span class="string">&quot;大巴车&quot;</span>,<span class="string">&quot;绿色&quot;</span>);</span><br><span class="line">truck = <span class="keyword">new</span> Truck(<span class="string">&quot;卡车&quot;</span>,<span class="string">&quot;蓝色&quot;</span>,<span class="number">2</span>);</span><br><span class="line">cars = <span class="keyword">new</span> Car[<span class="number">3</span>];</span><br><span class="line">cars[<span class="number">0</span>] = sedan;</span><br><span class="line">cars[<span class="number">1</span>] = bus;</span><br><span class="line">cars[<span class="number">2</span>] = truck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;欢迎使用本汽车管理系统&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;车辆名称\t\t车辆颜色\t\t座位数\t\t载重量&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Car car:cars) &#123;</span><br><span class="line"><span class="keyword">if</span>(car <span class="keyword">instanceof</span> Truck) &#123;</span><br><span class="line">Truck truck = (Truck)car;</span><br><span class="line">System.out.println(car.getName()+<span class="string">&quot;\t\t&quot;</span>+car.getColor()+<span class="string">&quot;\t\t&quot;</span>+car.seatNum()+<span class="string">&quot;\t\t&quot;</span>+truck.getweight());</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(car.getName()+<span class="string">&quot;\t\t&quot;</span>+car.getColor()+<span class="string">&quot;\t\t&quot;</span>+car.seatNum()+<span class="string">&quot;\t\t不能拉货&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;1.小轿车\t2.大巴车\t3.卡车&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;请选择要修改的车辆：&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> num = scanner.nextInt();</span><br><span class="line"><span class="keyword">switch</span>(num) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">update(<span class="string">&quot;sedan&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">update(<span class="string">&quot;bus&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">update(<span class="string">&quot;truck&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;车辆不存在!&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">String name = <span class="keyword">null</span>;</span><br><span class="line">String color = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(type.equals(<span class="string">&quot;sedan&quot;</span>)) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;输入车辆名称&quot;</span>);</span><br><span class="line">name = scanner.next();</span><br><span class="line">System.out.print(<span class="string">&quot;输入车辆颜色&quot;</span>);</span><br><span class="line">color = scanner.next();</span><br><span class="line">Sedan sedan = <span class="keyword">new</span> Sedan(name,color);</span><br><span class="line">cars[<span class="number">0</span>] = sedan;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(type.equals(<span class="string">&quot;bus&quot;</span>)) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;输入车辆名称&quot;</span>);</span><br><span class="line">name = scanner.next();</span><br><span class="line">System.out.print(<span class="string">&quot;输入车辆颜色&quot;</span>);</span><br><span class="line">color = scanner.next();</span><br><span class="line">Bus bus = <span class="keyword">new</span> Bus(name,color);</span><br><span class="line">cars[<span class="number">1</span>] = bus;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(type.equals(<span class="string">&quot;truck&quot;</span>)) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;输入车辆名称&quot;</span>);</span><br><span class="line">name = scanner.next();</span><br><span class="line">System.out.print(<span class="string">&quot;输入车辆颜色&quot;</span>);</span><br><span class="line">color = scanner.next();</span><br><span class="line">System.out.print(<span class="string">&quot;输入载重量&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> weight = scanner.nextInt();</span><br><span class="line"><span class="keyword">if</span>(weight &gt; <span class="number">12</span>) &#123;</span><br><span class="line">CarException carException = <span class="keyword">new</span> CarException(<span class="string">&quot;卡车的载重量不能超过12吨&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> carException;</span><br><span class="line">&#125; <span class="keyword">catch</span> (CarException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Truck truck = <span class="keyword">new</span> Truck(name,color,weight);</span><br><span class="line">cars[<span class="number">2</span>] = truck;</span><br><span class="line">&#125;</span><br><span class="line">showCars();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">test.showCars();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲解了面向对象的高级部分，包括 Object 类、包装类、接口和异常。其中 Object 类是所有 Java 类的父类，定义了 Java 体系的基础资料，通过继承传递给 Java 的每一个类，通过方法重写和多态让整个 Java 体系具有很强的灵活性。</p><p>包装类是 Java 为基本数据类型提供封装的一组类，通过包装类我们可以将基本数据类型转为对象，这一点在面向对象编程中很重要。</p><p>接口是抽象类的扩展，是 Java 中实现多态的重要方式，可以降低程序的耦合性，让程序变得更加灵活多变。接口就相当于零件，我们可以自由地将这些零件进行组装、整合。</p><p>异常是 Java 中处理错误的一种机制，同样是基于面向对象的思想，将错误抽象成对象然后进行处理，这里需要关注的是对异常相关的几个关键字的使用，try、catch、finally、throw、throws。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程是提升程序性能非常重要的一种方式，必须掌握的技术。<br>使用多线程可以让程序充分利用 CPU 资源。</p><blockquote><p>优点：</p></blockquote><ul><li>系统资源得到更合理的利用。</li><li>程序设计更加简洁。</li><li>程序响应更快，运行效率更高。</li></ul><blockquote><p>缺点:</p></blockquote><ul><li>需要更多的内存空间来支持多线程。</li><li>多线程并发访问的情况可能会影响数据的准确性。</li><li>数据被多线程共享，可能会出现死锁的情况。</li></ul><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><blockquote><p>什么是进程：进程就是计算机正在运行的一个独立的应用程序。</p></blockquote><p>进程是一个动态的概念，当我们启动某个应用的时候，进程就产生了，当我们关闭该应用的时候，进程就结束了，进程的生命周期就是我们在使用该软件的整个过程。</p><blockquote><p>什么是线程？<br>线程是组成进程的基本单位，可以完成特定的功能，一个进程是由一个或多个线程组成的。<br>应用程序是静态的，进程和线程是动态的，有创建有销毁，存在是暂时的，不是永久的。</p></blockquote><p>进程和线程的区别：</p><p><strong>进程在运行时拥有独立的内存空间，即每个进程所占用的内存空间都是独立的，互不干扰。</strong><br><strong>线程是共享内存空间的，但是每个线程的执行都是相互独立的，单独的线程是无法执行的，由进程来控制多个线程的执行。</strong></p><h3 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h3><p>多线程是指在一个进程中，多个线程同时执行，这里说的同时执行并不是真正意义的同时执行。</p><p>系统会为每个线程分配 CPU 资源，在某个具体的时间段内 CPU 资源会被一个线程占用，在不同的时间段内由不同的线程来占用 CPU 资源，<strong>所以多个线程还是在交替执行，只不过因为 CPU 运行速度太快，我们感觉是在同时执行。</strong></p><p><img src="https://img-blog.csdnimg.cn/20210219173243561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>整个程序如果是一条回路，说明程序只有一个线程。</p><p><img src="https://img-blog.csdnimg.cn/20210219173256643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>程序有两条回路，同时向下执行，这种情况就是多线程，两个线程同时在执行。</p><h3 id="Java-中线程的使用"><a href="#Java-中线程的使用" class="headerlink" title="Java 中线程的使用"></a>Java 中线程的使用</h3><p>Java 中使用线程有两种方式：</p><ul><li>继承 Thread 类</li><li>实现 Runnable 接口</li></ul><blockquote><p>Java 写程序三部分组成：</p></blockquote><p>1、JDK 系统类库<br>JRE：Java Runtime Enviroment（Java 运行环境），仅供运行程序的。<br>JDK：Java Development Kit（Java 开发工具包），如果需要进行程序开发，必须安装 JDK。<br>String、Scanner、包装类。。。<br>java.lang.Thread<br>javax.servlet.Servlet<br>2、第三方类库<br>非 Java 官方的组织提供的一些成熟好用的工具，C3P0 数据库连接池、Spring 框架、DBUtils、Dom4J…<br>github：全球最大的同性交友网站<br>3、开发者自定义的代码<br>根据具体的业务需求编写的业务代码。</p><h3 id="Java-中线程的使用-1"><a href="#Java-中线程的使用-1" class="headerlink" title="Java 中线程的使用"></a>Java 中线程的使用</h3><ul><li>继承 Thread 类</li></ul><p>1、创建自定义类并继承 Thread 类。<br>2、重写 Thread 类中的 run 方法，并编写该线程的业务逻辑代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//定义业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-------------MyThread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//开启两个子线程</span></span><br><span class="line">         MyThread thread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">         MyThread2 thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">         thread1.start();</span><br><span class="line">         thread2.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：不能通过 run 方法来调用线程的任务，因为 run 方法调用相当于普通对象的执行，并不会去抢占 CPU 资源。<br>只有通过<code>start</code>方法才能开启线程，进而去抢占 CPU 资源，当某个线程抢占到 CPU 资源后，会自动调用 run 方法。</p><ul><li>实现 Runnable 接口</li></ul><p>1、创建自定义类并实现 Runnable 接口。<br>2、实现 run 方法，编写该线程的业务逻辑代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;========MyRunnable=======&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">thread.start();</span><br><span class="line">MyRunnable2 runnable2 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(runnable2);</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><p>线程和任务：<br>线程是去抢占 CPU 资源的，任务是具体执行业务逻辑的，线程内部会包含一个任务，线程启动(start)，当抢占到资源之后，任务就开始执行(run)。<br>两种方式的区别：<br>1、MyThread，继承 Thread 类的方式，直接在类中重写 run 方法，使用的时候，直接实例化 MyThread，start 即可，因为 Thread 内部存在 Runnable。<br>2、MyRunnbale，实现 Runnable 接口的方法，在实现类中重写 run 方法，使用的时候，需要先创建 Thread 对象，并将 MyRunnable 注入到 Thread 中，Thread.start。<br>实际开发中推荐使用第二种方式。</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程共有 5 种状态，在特定的情况下，线程可以在不同的状态之间切换，5 种状态如下所示。</p><ul><li>创建状态：实例化一个新的线程对象，还未启动。</li><li>就绪状态：创建好的线程对象调用 start 方法完成启动，进入线程池等待抢占 CPU 资源。</li><li>运行状态：线程对象获取了 CPU 资源，在一定的时间内执行任务。</li><li>阻塞状态：正在运行的线程暂停执行任务，释放所占用的 CPU 资源，<strong>并在解除阻塞状态之后也不能直接回到运行状态，而是重新回到就绪状态，等待获取 CPU 资源。</strong></li><li>终止状态：线程运行完毕或因为异常导致该线程终止运行。</li></ul><p>线程状态之间的转换图。</p><p><img src="https://img-blog.csdnimg.cn/20210219173324618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Java-多线程的实现"><a href="#Java-多线程的实现" class="headerlink" title="Java 多线程的实现"></a>Java 多线程的实现</h3><ul><li>继承 Thread</li><li>实现 Runnable</li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h4><p>让当前线程暂停执行，从运行状态进入阻塞状态，将 CPU 资源让给其他线程的调度方式，通过 sleep() 来实现。</p><p>sleep(long millis)，调用时需要传入休眠时间，单位为豪秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i+<span class="string">&quot;---------MyThread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在类的外部调用 sleep 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyThread2 thread = <span class="keyword">new</span> MyThread2();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    thread.sleep(<span class="number">5000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p><strong>在外部调用需要注意，休眠一定要放在启动之前。？？？</strong></p><p>如何让主线程休眠？直接通过静态方式调用 sleep 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i+<span class="string">&quot;+++++Test2+++++&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>sleep 是静态本地方法，可以通过类调用，也可以通过对象调用，方法定义抛出 InterruptedException，InterruptedException 继承 Exception，外部调用时必须手动处理异常。</p><h4 id="线程合并"><a href="#线程合并" class="headerlink" title="线程合并"></a>线程合并</h4><p>合并是指将指定的某个线程加入到当前线程中，合并为一个线程，由两个线程交替执行变成一个线程中的两个自线程顺序执行。</p><p>通过调用 join 方法来实现合并，具体如何合并？</p><p>线程甲和线程乙，线程甲执行到某个时间点的时候调用线程乙的 join方法，则表示从当前时间点开始 CPU 资源被线程乙独占，线程甲进入阻塞状态，直到线程乙执行完毕，线程甲进入就绪状态，等待获取 CPU 资源进入运行状态。</p><p>join 方法重载，join() 表示乙线程执行完毕之后才能执行其他线程，join(long millis) 表示乙线程执行 millis 毫秒之后，无论是否执行完毕，其他线程都可以和它争夺 CPU 资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">200</span>;i++) &#123;</span><br><span class="line">            System.out.println(i+<span class="string">&quot;------JoinRunnable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个线程，主线程、join线程</span></span><br><span class="line"><span class="comment"> * 主线程的逻辑：当i==10，join线程合并到主线程中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        JoinRunnable joinRunnable = <span class="keyword">new</span> JoinRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(joinRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i+<span class="string">&quot;main+++++++++&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i+<span class="string">&quot;--------JoinRunnable&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i+<span class="string">&quot;+++++Test2+++++&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h4><p>线程礼让是指在某个特定的时间点，让线程暂停抢占 CPU 资源的行为，运行状态/就绪状态—》阻塞状态，将 CPU 资源让给其他线程来使用。</p><p>假如线程甲和线程乙在交替执行，某个时间点线程甲做出了礼让，所以在这个时间节点线程乙拥有了 CPU 资源，执行业务逻辑，但不代表线程甲一直暂停执行。</p><p>线程甲只是在特定的时间节点礼让，过了时间节点，线程甲再次进入就绪状态，和线程乙争夺 CPU 资源。</p><p>通过 yield 方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">5</span>) &#123;</span><br><span class="line">yield();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;======&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">YieldThread1 thread = <span class="keyword">new</span> YieldThread1();</span><br><span class="line">thread.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">YieldThread2 thread2 = <span class="keyword">new</span> YieldThread2();</span><br><span class="line">thread2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line">thread2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>有很多种情况会造成线程停止运行：</p><p>线程执行完毕自动停止</p><p>线程执行过程中遇到错误抛出异常并停止</p><p>线程执行过程中根据需求手动停止</p><p>Java 中实现线程中断有如下几个常用方法：</p><ul><li>public void stop()</li><li>public void interrupt()</li><li>public boolean isInterrupted()</li></ul><blockquote><p>stop 方法在新版本的 JDK 已经不推荐使用，重点关注后两个方法。</p><p>interrupt 是一个实例方法，当一个线程对象调用该方法时，表示中断当前线程对象。</p><p>每个线程对象都是通过一个标志位来判断当前是否为中断状态。</p></blockquote><p>isInterrupted函数就是用来获取当前线程对象的标志位：</p><p>1、true 表示清除了标志位，当前线程已经中断。</p><p>2、false 表示没有清除标志位，当前对象没有中断。</p><p>当一个线程对象处于不同的状态时，中断机制也是不同的。</p><p>创建状态：实例化线程对象，不启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">System.out.println(thread.getState());</span><br><span class="line">thread.interrupt();</span><br><span class="line">System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210219173406760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>NEW 表示当前线程对象为创建状态，false 表示当前线程并未中断，因为当前线程没有启动，不存在中断，不需要清除标志位。</p><blockquote><p>匿名内部类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(i+<span class="string">&quot;---main&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//MyRunnable runnable = new MyRunnable();</span></span><br><span class="line"><span class="comment">//Thread thread = new Thread(runnable);</span></span><br><span class="line"><span class="comment">//thread.start();</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">System.out.println(i+<span class="string">&quot;---main&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(thread.getState());</span><br><span class="line">thread.interrupt();</span><br><span class="line">System.out.println(thread.isInterrupted());</span><br><span class="line">System.out.println(thread.getState());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步（synchronized）"><a href="#线程同步（synchronized）" class="headerlink" title="线程同步（synchronized）"></a>线程同步（synchronized）</h3><p>Java 中允许多线程并行访问，同一时间段内多个线程同时完成各自的操作。<br>多个线程同时操作<strong>同一个共享数据</strong>时，可能会导致数据不准确的问题。<br>使用线程同步可以解决上述问题。<br>可以通过 synchronized 关键字修饰方法实现线程同步，每个Java 对象都有一个<code>内置锁</code>，内置锁会保护使用 synchronized 关键字修饰的方法，要调用该方法就必须先获得锁，否则就处于阻塞状态。</p><blockquote><p>非线程同步</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//1.num++操作</span></span><br><span class="line">        num++;</span><br><span class="line">        <span class="comment">//2.休眠1毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.打印输出</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;是当前的第&quot;</span>+num+<span class="string">&quot;位访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线程同步</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//1.num++操作</span></span><br><span class="line">        num++;</span><br><span class="line">        <span class="comment">//2.休眠1毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.打印输出</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;是当前的第&quot;</span>+num+<span class="string">&quot;位访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Account account = <span class="keyword">new</span> Account();</span><br><span class="line">         Thread t1 = <span class="keyword">new</span> Thread(account,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">         Thread t2 = <span class="keyword">new</span> Thread(account,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">         t1.start();</span><br><span class="line">         t2.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized 关键字可以修饰实例方法，也可以修饰静态方法，两者在使用的时候是有区别的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                    SynchronizedTest.test();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 先输出start...</span></span><br><span class="line"><span class="comment">      * 间隔1s</span></span><br><span class="line"><span class="comment">      * 再输出end...</span></span><br><span class="line"><span class="comment">      * 输出start...</span></span><br><span class="line"><span class="comment">      * ...</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.输出start</span></span><br><span class="line">        System.out.println(<span class="string">&quot;start......&quot;</span>);</span><br><span class="line">        <span class="comment">//2.休眠</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.输出end</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized 修饰非静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                    SynchronizedTest2 synchronizedTest2 = <span class="keyword">new</span> SynchronizedTest2();</span><br><span class="line">                    synchronizedTest2.test();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start......&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给实例方法（非静态方法）添加 synchronized 关键字并不能实现线程同步。<br>线程同步的本质是锁定多个线程所共享的资源，synchronized 还可以修饰代码块，会为代码块加上<code>内置锁</code>，从而实现同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                    SynchronizedTest3.test();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest3.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何判断线程同步或是不同步？</strong><br>找到关键点：锁定的资源在内存中是一份还是多份？一份大家需要排队，线程同步，多份（一人一份），线程不同步。<br><strong>无论是锁定方法还是锁定对象，锁定类，只需要分析这个方法、对象、类在内存中有几份即可。</strong></p><blockquote><p>对象一般都是多份<br>类一定是一份<br>方法就看是静态方法还是非静态方法，静态方法一定是一份，非静态方法一般是多份</p></blockquote><h3 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h3><p>单例模式是一种常见的软件设计模式，核心思想是<strong>一个类只有一个实例对象</strong>。<br>JVM：栈内存、堆内存<br>单线程模式下的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo singletonDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建了SingletonDemo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singletonDemo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singletonDemo = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程模式下的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo singletonDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建了SingletonDemo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singletonDemo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singletonDemo = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双重检测</strong>，synchronized 修饰代码块。<br>1、线程同步是为了实现线程安全，如果只创建一个对象，那么线程就是安全的。<br>2、如果 synchronized 锁定的是多个线程共享的数据（同一个对象），那么线程就是安全的。<br>3、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonDemo singletonDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建了SingletonDemo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singletonDemo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(singletonDemo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonDemo = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile 的作用时候可以使内存中的数据对象线程可见。<br>主内存对线程是不可见的，添加 volatile 关键字之后，主内存对线程可见。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>并发、并行</p><p>使用并发编程的目的？为了充分利用计算机的资源，提高性能，企业以盈利为目的。</p><p>并发：多个线程访问同一个共享资源，前提是计算机是单核 CPU，多个线程不是同时在访问，而是交替进行，只是因为 CPU 运行速度太快，看起来是同时在运行。</p><p>并行：多核 CPU，多个线程是真正的同时在运行，各自占用不同的 CPU，相互之间没有影响，也不会争夺资源。</p><p>Java 默认线程有两个，main（主线程），GC（垃圾回收机制）</p><p>synchronized 关键字实现线程同步，让在访问同一个资源的多个线程排队去完成业务，避免出现数据错乱的情况。</p><h3 id="死锁-DeadLock"><a href="#死锁-DeadLock" class="headerlink" title="死锁 DeadLock"></a>死锁 DeadLock</h3><p>前提：一个线程完成业务需要同时访问两个资源。</p><p>死锁：多个线程同时在完成业务，出现争抢资源的情况。</p><p>资源类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="comment">//编号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="comment">//资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Chopsticks chopsticks1 = <span class="keyword">new</span> Chopsticks();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Chopsticks chopsticks2 = <span class="keyword">new</span> Chopsticks();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * num = 1 拿到 chopsticks1，等待 chopsticks2</span></span><br><span class="line"><span class="comment"> * num = 2 拿到 chopsticks2，等待 chopsticks1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;拿到了chopsticks1，等待获取chopsticks2&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (chopsticks1) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (chopsticks2) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;用餐完毕！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">2</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;拿到了chopsticks2，等待获取chopsticks1&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (chopsticks2) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (chopsticks1) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;用餐完毕！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLockRunnable deadLockRunnable1 = <span class="keyword">new</span> DeadLockRunnable();</span><br><span class="line">        deadLockRunnable1.num = <span class="number">1</span>;</span><br><span class="line">        DeadLockRunnable deadLockRunnable2 = <span class="keyword">new</span> DeadLockRunnable();</span><br><span class="line">        deadLockRunnable2.num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(deadLockRunnable1,<span class="string">&quot;张三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(deadLockRunnable2,<span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何破解死锁"><a href="#如何破解死锁" class="headerlink" title="如何破解死锁"></a>如何破解死锁</h3><p>不要让多线程并发访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLockRunnable deadLockRunnable1 = <span class="keyword">new</span> DeadLockRunnable();</span><br><span class="line">        deadLockRunnable1.num = <span class="number">1</span>;</span><br><span class="line">        DeadLockRunnable deadLockRunnable2 = <span class="keyword">new</span> DeadLockRunnable();</span><br><span class="line">        deadLockRunnable2.num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(deadLockRunnable1,<span class="string">&quot;张三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//确保deadLockRunnable1已经执行完成</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(deadLockRunnable2,<span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;+++++++++++Runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) System.out.println(<span class="string">&quot;+++++++Runnable&quot;</span>);&#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) System.out.println(<span class="string">&quot;----Runnable&quot;</span>);&#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) System.out.println(<span class="string">&quot;++++=====++Runnable&quot;</span>);&#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>java.util.concurrent（JUC）</p><p>Lock 是一个接口，用来实现线程同步的，功能与 synchronized 一样。</p><p>Lock 使用频率最高的实现类是 ReentrantLock（重入锁），可以重复上锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        <span class="keyword">new</span> Thread(account,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(account,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;是当前的第&quot;</span>+num+<span class="string">&quot;位访客&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现资源和 Runnable 接口的解耦合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            account.count();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start(); </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            account.count();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;是第&quot;</span>+num+<span class="string">&quot;位访客&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><p>java.util.concurrent</p><p>Java 并发编程工具包，Java 官方提供的一套专门用来处理并发编程的工具集合（接口+类）</p><p>并发：单核 CPU，多个线程“同时”运行，实际是交替执行，只不过速度太快，看起来是同时执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个厨师一口锅</span><br></pre></td></tr></table></figure><p>并行：多核 CPU，真正的多个线程同时运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个厨师两口锅</span><br></pre></td></tr></table></figure><p>重入锁是 JUC 使用频率非常高的一个类 ReentrantLock</p><p>ReentrantLock 就是对 synchronized 的升级，目的也是为了实现线程同步。</p><ul><li>ReentrantLock 是一个类，synchronized 是一个关键字。</li><li>ReentrantLock 是 JDK 实现，synchronized 是 JVM 实现。</li><li>synchronized 可以自动释放锁，ReentrantLock 需要手动释放。</li></ul><p>ReentrantLock 是 Lock 接口的实现类。</p><p>公平锁和非公平锁的区别</p><p>公平锁：线程同步时，多个线程排队，依次执行</p><p>非公平锁：线程同步时，可以插队</p><p>线程的实现有两种方式</p><ul><li>继承 Thread</li><li>实现 Runnable</li></ul><p>实现 Runnable 的耦合度更低</p><p><img src="https://img-blog.csdnimg.cn/20210219173456849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Account account = <span class="keyword">new</span> Account();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">account.count();</span><br><span class="line">&#125;,<span class="string">&quot;A&quot;</span>) .start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">account.count();</span><br><span class="line">&#125;,<span class="string">&quot;B&quot;</span>) .start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将资源和 Runnable 进行解耦合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;是当前的第&quot;</span>+num+<span class="string">&quot;位访客&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account2 account = <span class="keyword">new</span> Account2();</span><br><span class="line">        <span class="keyword">new</span> Thread(account,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(account,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;是当前的第&quot;</span>+num+<span class="string">&quot;位访客&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210219173514100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer id = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (num) &#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;是当前的第&quot;</span>+num+<span class="string">&quot;位访客&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果锁定 num 不能同步，锁定 id 可以同步，原因是什么？</p><p><strong>synchronized 必须锁定唯一的元素才可以实现同步</strong></p><p>num 的值每次都在变，所以 num 所指向的引用一直在变，所以不是唯一的元素，肯定无法实现同步。</p><p>id 的值永远不变，所以是唯一的元素，可以实现同步。</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account3 account = <span class="keyword">new</span> Account3();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            account.count();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            account.count();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account3</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;是当前的第&quot;</span>+num+<span class="string">&quot;位访客&quot;</span>);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Lock 上锁和解锁都需要开发者手动完成。</li><li>可以重复上锁，上几把锁就需要解几把锁。</li></ul><p>ReentrantLock 除了可以重入之外，还有一个可以中断的特点，可中断是指某个线程在等待获取锁的过程中可以主动过终止线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StopLock stopLock = <span class="keyword">new</span> StopLock();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            stopLock.service();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        Thread t2 =<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            stopLock.service();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            t2.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reentrantLock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;get lock&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><p>ReentrantLock 限时性：判断某个线程<strong>在一定的时间内</strong>能否获取锁，通过 tryLock 方法来实现</p><p>tryLock(long time,TimeUnit unit)</p><p>time 指时间数值</p><p>unit 时间单位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeLock timeLock = <span class="keyword">new</span> TimeLock();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A 拿到锁，执行业务代码，休眠 5 秒钟</span></span><br><span class="line"><span class="comment">         * B 尝试拿锁，需要在 3 秒钟之内拿到锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            timeLock.lock();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            timeLock.lock();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试在3S内获取锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(reentrantLock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; get lock&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; not lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(reentrantLock.isHeldByCurrentThread())&#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p>在一个生产环境中，生产者和消费者在同一时间段内共享同一块缓冲区，生产者负责向缓冲区添加数据，消费者负责从缓冲区取出数据。</p><h4 id="汉堡类"><a href="#汉堡类" class="headerlink" title="汉堡类"></a>汉堡类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hamburger&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Hamburger[] array = <span class="keyword">new</span> Hamburger[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向容器中添加汉堡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Hamburger hamburger)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(index == array.length)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">        array[index] = hamburger;</span><br><span class="line">        index++;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产类一个汉堡&quot;</span>+hamburger);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从容器中取出汉堡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Hamburger <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//当前线程暂停</span></span><br><span class="line">            <span class="comment">//让正在访问当前资源的线程暂停</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒之前暂停的线程</span></span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">        index--;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费了一个汉堡&quot;</span>+array[index]);</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Container container;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Container container)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            Hamburger hamburger = <span class="keyword">new</span> Hamburger(i);</span><br><span class="line">            <span class="keyword">this</span>.container.push(hamburger);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Container container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.container.pop();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">new</span> Container();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(container);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(container);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            producer.product();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            producer.product();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            consumer.consum();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            consumer.consum();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            consumer.consum();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程并发卖票"><a href="#多线程并发卖票" class="headerlink" title="多线程并发卖票"></a>多线程并发卖票</h3><p>一场球赛的球票分 3 个窗口出售，共 15 张票，用多线程并发来模拟 3 个窗口的售票情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="comment">//剩余球票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> surpluCount = <span class="number">15</span>;</span><br><span class="line">    <span class="comment">//已售出球票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(surpluCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(surpluCount == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            surpluCount--;</span><br><span class="line">            outCount++;</span><br><span class="line">            <span class="keyword">if</span>(surpluCount == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;售出第&quot;</span>+outCount+<span class="string">&quot;张票，球票已售罄&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;售出第&quot;</span>+outCount+<span class="string">&quot;张票，剩余&quot;</span>+surpluCount+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            ticket.sale();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            ticket.sale();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            ticket.sale();</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java 并发编程"></a>Java 并发编程</h2><p>为什么很重要？</p><p>并发编程可以充分利用计算机的资源，把计算机的性能发挥到最大，可以最大程度节约公司的成本，提高效率。</p><h3 id="什么是高并发"><a href="#什么是高并发" class="headerlink" title="什么是高并发"></a>什么是高并发</h3><p>并发 VS 并行的区别</p><blockquote><p>并发 concurrency：多线程“同时”操作同一个资源，并不是真正的同时操作，而是交替操作，单核 CPU 的情况下，资源按时间段分配给多个线程。张三李四王五使用一口锅炒菜，交替</p></blockquote><blockquote><p>并行 parallelism：是真正的多个线程同时执行，多核 CPU，每个线程使用一个 CPU 资源来运行。张三李四王五使用三口锅炒菜，同时进行</p></blockquote><p>并发编程描述的是一种使系统允许多个任务可以在重叠的时间段内执行的设计结构，不是指多个任务在同一时间段内执行，而是指系统具备处理多个任务在同一时间段内同时执行的能力。</p><p>高并发是指我们设计的程序，可以支持海量任务的执行在时间段上重叠的情况。</p><p>高并发的标准：</p><ul><li>QPS：每秒响应的 HTTP 请求数量，QPS 不是并发数。</li><li>吞吐量：单位时间内处理的请求数，由 QPS 和并发数来决定。</li><li>平均响应时间：系统对一个请求作出响应的评价时间。</li></ul><p>QPS = 并发数 / 平均响应时间</p><ul><li>并发用户数：同时承载正常使用系统的用户人数</li></ul><p>互联网分布式架构设计，提高系统并发能力的方式：</p><ul><li>垂直扩展</li><li>水平扩展</li></ul><h3 id="垂直扩展"><a href="#垂直扩展" class="headerlink" title="垂直扩展"></a>垂直扩展</h3><p>提升单机处理能力<br>1、提升单机的硬件设备，增加 CPU 核数，升级网卡，硬盘扩容，升级内存。<br>2、提升单机的架构性能，使用 Cache 提高效率，使用异步请求来增加单服务吞吐量，NoSQL 提升数据库访问能力。</p><h3 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h3><p>集群：一个厨师搞不定，多雇几个厨师一起炒菜，多个人干同一件事情。</p><p>分布式：给厨师雇两个助手，一个负责洗菜，一个负责切菜，厨师只负责炒菜，一件事情拆分成多个步骤，由不同的人去完成。</p><p>站点层扩展：Nginx 反向代理，一个 Tomcat 跑不动，那就 10 个 Tomcat 去跑。</p><p>服务层扩展：RPC 框架实现远程调用，Spring Boot/Spring Cloud，Dubbo，分布式架构，将业务逻辑拆分到不同的 RPC Client，各自完成对应的业务，如果某项业务并发量很大，增加新的 RPC Client，就能扩展服务层的性能，做到理论上的无限高并发。</p><p>数据层扩展：在数据量很大的情况下，将原来的一台数据库服务器，拆分成多台，以达到扩充系统性能的目的，<code>主从复制</code>，<code>读写分离</code>，<code>分表分库</code>。</p><h3 id="JUC-1"><a href="#JUC-1" class="headerlink" title="JUC"></a>JUC</h3><p>JDK 提供的一个工具包，专门用来帮助开发者完成 Java 并发编程。</p><h3 id="进程和线程-1"><a href="#进程和线程-1" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>Java 默认的线程数 2 个</p><ul><li>mian 主线程</li><li>GC 垃圾回收机制</li></ul><p>Java 本身是无法开启线程的，Java 无法操作硬件，只能通过调用本地方法，C++ 编写的动态函数库。</p><p><img src="https://img-blog.csdnimg.cn/20210219173557950.png" alt="在这里插入图片描述"></p><blockquote><p>Java 中实现多线程有几种方式？</p></blockquote><p>1、继承 Thread 类</p><p>2、实现 Runnable 接口</p><p>3、实现 Callable 接口</p><p>Callable 和 Runnable 的区别在于 Runnable 的 run 方法<strong>没有返回值</strong>，Callable 的 call 方法<strong>有返回值</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCallable myCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask(myCallable);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String value = futureTask.get();</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210219173618354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="sleep-和-wait"><a href="#sleep-和-wait" class="headerlink" title="sleep 和 wait"></a>sleep 和 wait</h3><p>sleep 是让当前线程休眠，wait 是让访问当前对象的线程休眠。</p><p>sleep 不会释放锁，wait 会释放锁。</p><h3 id="synchronized-锁定的是什么"><a href="#synchronized-锁定的是什么" class="headerlink" title="synchronized 锁定的是什么"></a>synchronized 锁定的是什么</h3><p>1、synchronized 修饰非静态方法，锁定方法的调用者</p><p>2、synchronized 修饰静态方法，锁定的是类</p><p>3、synchronized 静态方法和实例方法同时存在，静态方法锁定的是类，实例方法锁定的是对象</p><h3 id="Lock-1"><a href="#Lock-1" class="headerlink" title="Lock"></a>Lock</h3><p>JUC 提供的一种锁机制，功能和 synchronized 类似，是对 synchronized 的升级，它是一个接口。</p><p><img src="https://img-blog.csdnimg.cn/20210219173633162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>它的常用实现类是 ReentrantLock。</p><p>synchronized 是通过 JVM 实现锁机制，ReentrantLock 是通过 JDK 实现锁机制。</p><p>synchronized 是一个关键字，ReentrantLock 是一个类。</p><p>重入锁：可以给同一个资源添<code>加多把锁</code>。</p><p>synchronized 是线程执行完毕之后自动释放锁，ReentrantLock 需要手动解锁。</p><p>用 synchronized 实现卖票</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer saleNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer lastNum = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lastNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            saleNum++;</span><br><span class="line">            lastNum--;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了第&quot;</span>+saleNum+<span class="string">&quot;张票，剩余&quot;</span>+lastNum+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 Lock 完成卖票</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket2 ticket = <span class="keyword">new</span> Ticket2();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer saleNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer lastNum = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">if</span>(lastNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            saleNum++;</span><br><span class="line">            lastNum--;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了第&quot;</span>+saleNum+<span class="string">&quot;张票，剩余&quot;</span>+lastNum+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>synchronized 和 lock 的区别</p></blockquote><p>1、synchronized 自动上锁，自动释放锁，Lock 手动上锁，手动释放锁。</p><p>2、synchronized 无法判断是否获取到了锁，Lock 可以判断是否拿到了锁。</p><p>3、synchronized 拿不到锁就会一直等待，Lock 不一定会一直等待。</p><p>4、synchronized 是 Java 关键字，Lock 是接口。</p><p>5、synchronized 是非公平锁，Lock 可以设置是否为公平锁。</p><p>公平锁：很公平，排队，当锁没有被占用时，当前线程需要判断队列中是否有其他等待线程。</p><p>非公平锁：不公平，插队，当锁没有被占用时，当前线程可以直接占用，而不需要判断当前队列中是否有等待线程。</p><p>实际开发中推荐使用 Lock 的方式。</p><p>ReentrantLock 具备限时性的特点，可以判断某个线程在一定的时间段内能否获取到锁，使用 tryLock 方法，返回值是 boolean 类型，true 表示可以获取到锁，false 表示无法获取到锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeLock timeLock = <span class="keyword">new</span> TimeLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            timeLock.getLock();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            timeLock.getLock();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;拿到了锁&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;拿不到锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者消费者模式-1"><a href="#生产者消费者模式-1" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;生产了汉堡&quot;</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;消费了汉堡&quot;</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须使用 while 判断，不能用 if，因为 if 会存在线程虚假唤醒的问题，虚假唤醒就是一些 wait 方法会在除了 notify 的其他情况被唤醒，不是真正的唤醒，使用 while 完成多重检测，避免这一问题。</p><h4 id="Lock-2"><a href="#Lock-2" class="headerlink" title="Lock"></a>Lock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        condition.signal();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;生产了汉堡&quot;</span>+num);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        condition.signal();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;消费了汉堡&quot;</span>+num);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Lock 锁，就不能通过 wait 和 notify 来暂停线程和唤醒线程</strong>，而应该使用 Condition 的 <code>await</code>和 <code>signal</code>来暂停和唤醒线程。</p><h3 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h3><h4 id="并发访问异常"><a href="#并发访问异常" class="headerlink" title="并发访问异常"></a>并发访问异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//写</span></span><br><span class="line">                list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                <span class="comment">//读</span></span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h4><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p><img src="https://img-blog.csdnimg.cn/20210219173713891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="Collections-synchronizedList"><a href="#Collections-synchronizedList" class="headerlink" title="Collections.synchronizedList"></a>Collections.synchronizedList</h5><h5 id="JUC：CopyOnWriteArrayList"><a href="#JUC：CopyOnWriteArrayList" class="headerlink" title="JUC：CopyOnWriteArrayList"></a>JUC：CopyOnWriteArrayList</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread((()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CopyOnWrite 写时复制，当我们往一个容器添加元素的时候，不是直接给容器添加，而是先将当前容器复制一份，向新的容器中添加数据，添加完成之后，再将原容器的引用指向新的容器。</p><p><img src="https://img-blog.csdnimg.cn/20210219173730255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread((()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                set.add(String.valueOf(temp)+<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread((()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">3</span>),UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JUC-工具类"><a href="#JUC-工具类" class="headerlink" title="JUC 工具类"></a>JUC 工具类</h3><h4 id="CountDownLatch：减法计数器"><a href="#CountDownLatch：减法计数器" class="headerlink" title="CountDownLatch：减法计数器"></a>CountDownLatch：减法计数器</h4><p>可以用来倒计时，当两个线程同时执行时，如果要确保一个线程优先执行，可以使用计数器，当计数器清零的时候，再让另一个线程执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个 CountDownLatch</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;+++++++++++++++Thread&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main-----------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>coutDown()：计数器减一</p><p>await()：计数器停止，唤醒其他线程</p><p>new CountDownLatch(100)、coutDown()、await() 必须配合起来使用，创建对象的时候赋的值是多少，coutDown() 就必须执行多少次，否则计数器是没有清零的，计数器就不会停止，其他线程也无法唤醒，所以必须保证计数器清零，coutDown() 的调用次数必须大于构造函数的参数值。</p><h4 id="CyclicBarrier：加法计数器"><a href="#CyclicBarrier：加法计数器" class="headerlink" title="CyclicBarrier：加法计数器"></a>CyclicBarrier：加法计数器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">100</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;放行&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;--&gt;&quot;</span>+temp);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await()：在其他线程中试图唤醒计数器线程，当其他线程的执行次数达到计数器的临界值时，则唤醒计数器线程，并且计数器是可以重复使用的，当计数器的线程执行完成一次之后，计数器自动清零，等待下一次执行。</p><p>new CyclicBarrier(30），for 执行 90 次，则计数器的任务会执行 3 次。</p><h4 id="Semaphore：计数信号量"><a href="#Semaphore：计数信号量" class="headerlink" title="Semaphore：计数信号量"></a>Semaphore：计数信号量</h4><p>实际开发中主要使用它来完成限流操作，限制可以访问某些资源的线程数量。</p><p>Semaphore 只有 3 个操作：</p><ul><li>初始化</li><li>获取许可</li><li>释放</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">//获得许可</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进店购物&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;出店&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程在执行的时候，首先需要去获取信号量，只有获取到资源才可以执行，执行完毕之后需要释放资源，留给下一个线程。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>接口 ReadWriteLock，实现类是 ReentrantReadWriteLock，可以<strong>多线程同时读，但是同一时间内只能有一个线程进行写入操作</strong>。</p><p>读写锁也是为了实现线程同步，只不过粒度更细，可以分别给读和写的操作设置不同的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cache cache = <span class="keyword">new</span> Cache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">                cache.write(temp,String.valueOf(temp));</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.read(temp);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用hashmap，是因为每个只有一个线程进行写操作</span></span><br><span class="line">    <span class="comment">//如果有多个线程操作，需使用ConcurrentHashMap</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Integer key,String value)</span></span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        System.out.println(key+<span class="string">&quot;开始写入&quot;</span>);</span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(key+<span class="string">&quot;写入完毕&quot;</span>);</span><br><span class="line">        readWriteLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Integer key)</span></span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        System.out.println(key+<span class="string">&quot;开始读取&quot;</span>);</span><br><span class="line">        map.get(key);</span><br><span class="line">        System.out.println(key+<span class="string">&quot;读取完毕&quot;</span>);</span><br><span class="line">        readWriteLock.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写入锁也叫独占锁，只能被一个线程占用，读取锁也叫共享锁，多个线程可以同时占用。</strong></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>预先创建好一定数量的线程对象，存入<code>缓冲池</code>中，需要用的时候直接从缓冲池中取出，用完之后不要销毁，还回到缓冲池中，为了提高资源的利用率。</p><p>优势：</p><ul><li>提高线程的利用率</li><li>提高响应速度</li><li>便于统一管理线程对象</li><li>可以控制最大的并发数</li></ul><p>1、线程池初始化的时候创建一定数量的线程对象。</p><p>2、如果缓冲池中没有空闲的线程对象，则新来的任务进入等待队列。</p><p>3、如果缓冲池中没有空闲的线程对象，等待队列也已经填满，可以申请再创建一定数量的新线程对象，直到到达线程池的最大值，这时候如果还有新的任务进来，只能选择拒绝。</p><p>无论哪种线程池，都是工具类 Executors 封装的，底层代码都一样，都是通过创建 ThreadPoolExecutor 对象来完成线程池的构建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = (System.getSecurityManager() == <span class="keyword">null</span>)</span><br><span class="line">        ? <span class="keyword">null</span></span><br><span class="line">        : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize：核心池大小，初始化的线程数量</li><li>maximumPoolSize：线程池最大线程数，它决定了线程池容量的上限</li></ul><p>corePoolSize 就是线程池的大小，maximumPoolSize 是一种补救措施，任务量突然增大的时候的一种补救措施。</p><ul><li>keepAliveTime：线程对象的存活时间</li><li>unit：线程对象存活时间单位</li><li>workQueue：等待队列</li><li>threadFactory：线程工厂，用来创建线程对象</li><li>handler：拒绝策略</li></ul><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>池化技术 池化思想</p><p>优势：</p><ul><li>提高线程的利用率</li><li>提高响应速度</li><li>便于统一管理线程对象</li><li>可控制最大并发数</li></ul><p>线程池的具体设计思想</p><ul><li>核心池的大小</li><li>线程池的最大容量</li><li>等待队列</li><li>拒绝策略</li></ul><p>线程池启动的时候会按照核心池的数来创建初始化的线程对象 2 个。</p><p>开始分配任务，如果同时来了多个任务， 2 个线程对象都被占用了，第 3 个以及之后的任务进入等待队列，当前有线程完成任务恢复空闲状态的时候，等待队列中的任务获取线程对象。</p><p>如果等待队列也占满了，又有新的任务进来，需要去协调，让线程池再创建新的线程对象，但是线程池不可能无限去创建线程对象，一定会有一个最大上限，就是线程池的最大容量。</p><p>如果线程池已经达到了最大上限，并且等待队列也占满了，此时如果有新的任务进来，只能选择拒绝，并且需要根据拒绝策略来选择对应的方案。</p><p><img src="https://img-blog.csdnimg.cn/20210219173810678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>ThreadPoolExecutor</p><p>直接实例化 ThreadPoolExecutor ，实现定制化的线程池，而不推荐使用 Executors 提供的封装好的方法，因为这种方式代码不够灵活，无法实现定制化。</p><p>ThreadPoolExecutor 核心参数一共有 7 个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize：核心池的大小</span><br><span class="line">maximumPoolSize：线程池的最大容量</span><br><span class="line">keepAliveTime：线程存活时间（在没有任务可执行的情况下），必须是线程池中的数量大于 corePoolSize，才会生效</span><br><span class="line">TimeUnit：存活时间单位</span><br><span class="line">BlockingQueue：等待队列，存储等待执行的任务</span><br><span class="line">ThreadFactory：线程工厂，用来创建线程对象</span><br><span class="line">RejectedExecutionHandler：拒绝策略</span><br><span class="line">1、AbortPolicy：直接抛出异常</span><br><span class="line">2、DiscardPolicy：放弃任务，不抛出异常</span><br><span class="line">3、DiscardOldestPolicy：尝试与等待队列中最前面的任务去争夺，不抛出异常</span><br><span class="line">4、CallerRunsPolicy：谁调用谁处理</span><br></pre></td></tr></table></figure><p>单例 1</p><p><img src="https://img-blog.csdnimg.cn/20210219173828954.png" alt="在这里插入图片描述"></p><p>固定 5</p><p><img src="https://img-blog.csdnimg.cn/20210219173841948.png" alt="在这里插入图片描述"></p><p>缓存</p><p><a href="https://imgchr.com/i/yRB674"><img src="https://img-blog.csdnimg.cn/img_convert/9390f2e73cc7fd37b66546e0abb53eda.png" alt="yRB674.png"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 自己写7大参数，完全定制化</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">1L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                executorService.execute(()-&gt;&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;===&gt;办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210219173929837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="img"></p><p>new ThreadPoolExecutor.AbortPolicy()</p><p><img src="https://img-blog.csdnimg.cn/20210219173955805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>new ThreadPoolExecutor.CallersunsPolicy()</p><p><img src="https://img-blog.csdnimg.cn/20210219174012233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>new ThreadPoolExecutor.DiscardOldestPolicy()</p><p>new ThreadPoolExecutor.DiscardPolicy()</p><p>不会抛出异常</p><p>线程池 3 大考点：</p><p>1、Executors 工具类的 3 种实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure><p>2、7 个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize：核心池的大小</span><br><span class="line">maximumPoolSize：线程池的最大容量</span><br><span class="line">keepAliveTime：线程存活时间（在没有任务可执行的情况下），必须是线程池中的数量大于 corePoolSize，才会生效</span><br><span class="line">TimeUnit：存活时间单位</span><br><span class="line">BlockingQueue：等待队列，存储等待执行的任务</span><br><span class="line">ThreadFactory：线程工厂，用来创建线程对象</span><br><span class="line">RejectedExecutionHandler：拒绝策略</span><br></pre></td></tr></table></figure><p>3、4 种拒绝策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、AbortPolicy：直接抛出异常</span><br><span class="line">2、DiscardPolicy：放弃任务，不抛出异常</span><br><span class="line">3、DiscardOldestPolicy：尝试与等待队列中最前面的任务去争夺，不抛出异常</span><br><span class="line">4、CallerRunsPolicy：谁调用谁处</span><br></pre></td></tr></table></figure><h3 id="ForkJoin-框架"><a href="#ForkJoin-框架" class="headerlink" title="ForkJoin 框架"></a>ForkJoin 框架</h3><p>ForkJoin 是 JDK 1.7 后发布的多线程并发处理框架，功能上和 JUC 类似，JUC 更多时候是使用单个类完成操作，ForkJoin 使用多个类同时完成某项工作，处理上比 JUC 更加丰富，实际开发中使用的场景并不是很多，互联网公司真正有高并发需求的情况才会使用，<strong>面试时候会加分</strong></p><p>本质上是对线程池的一种的补充，对线程池功能的一种扩展，基于线程池的，它的核心思想就是将一个大型的任务拆分成很多个小任务，分别执行，最终将小任务的结果进行汇总，生成最终的结果。</p><p><img src="https://img-blog.csdnimg.cn/20210219174032295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>本质就是把一个线程的任务拆分成多个小任务，然后由多个线程并发执行，最终将结果进行汇总。</p><p>比如 A B 两个线程同时还执行，A 的任务比较多，B 的任务相对较少，B 先执行完毕，这时候 B 去帮助 A 完成任务（将 A 的一部分任务拿过来替 A 执行，执行完毕之后再把结果进行汇总），从而提高效率。</p><p><strong>工作窃取</strong><br><img src="https://img-blog.csdnimg.cn/20210219174052572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>ForkJoin 框架，核心是两个类</p><ul><li>ForkJoinTask （描述任务）</li><li>ForkJoinPool（线程池）提供多线程并发工作窃取</li></ul><p>使用 ForkJoinTask 最重要的就是要搞清楚如何拆分任务，这里用的是<strong>递归</strong>思想。</p><p>1、需要创建一个 ForkJoinTask 任务，ForkJoinTask 是一个抽象类，不能直接创建 ForkJoinTask 的实例化对象，开发者需要自定义一个类，继承 ForkJoinTask 的子类 RecursiveTask ，Recursive 就是递归的意思，该类就提供了实现递归的功能。</p><p><img src="https://img-blog.csdnimg.cn/20210219174114210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 10亿求和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line">    <span class="keyword">private</span> Long temp = <span class="number">100_0000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((end-start)&lt;temp)&#123;</span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Long avg = (start+end)/<span class="number">2</span>;</span><br><span class="line">            ForkJoinDemo task1 = <span class="keyword">new</span> ForkJoinDemo(start,avg);</span><br><span class="line">            task1.fork();</span><br><span class="line">            ForkJoinDemo task2 = <span class="keyword">new</span> ForkJoinDemo(avg,end);</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="keyword">return</span> task1.join()+task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinDemo(<span class="number">0L</span>,<span class="number">10_0000_0000L</span>);</span><br><span class="line">        forkJoinPool.execute(task);</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sum = task.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(sum+<span class="string">&quot;，供耗时&quot;</span>+(endTime-startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Volatile-关键字"><a href="#Volatile-关键字" class="headerlink" title="Volatile 关键字"></a>Volatile 关键字</h3><p><a href="https://imgchr.com/i/yRrtWn"><img src="https://img-blog.csdnimg.cn/img_convert/372bc88d2024a70fcdfda81a61ad1544.png" alt="yRrtWn.png"></a></p><p>Volatile 是 JVM 提供的轻量级同步机制，<strong>可见性</strong>，主内存对象线程可见。</p><p><strong>一个线程执行完任务之后还，会把变量存回到主内存中，并且从主内存中读取当前最新的值，如果是一个空的任务，则不会重新读取主内存中的值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 循环</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;---Thread---&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 循环</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池-workQueue"><a href="#线程池-workQueue" class="headerlink" title="线程池 workQueue"></a>线程池 workQueue</h3><p>一个阻塞队列，用来存储等待执行的任务，常用的阻塞队列有以下几种：</p><ul><li>ArrayBlockingQueue：基于数组的先进先出队列，创建时必须指定大小。</li><li>LinkedBlockingQueue：基于链表的先进先出队列，创建时可以不指定大小，默认值时 Integer.MAX_VALUE。</li><li>SynchronousQueue：它不会保持提交的任务，而是直接新建一个线程来执行新来的任务。</li><li>PriorityBlockingQueue：具有优先级的阻塞队列。</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>二叉树遍历，深度优先搜索等。</p><p>什么是递归？</p><p>常规的定义：编程语言中，函数 func 直接或者间接调用函数本身，则该函数称为递归函数。</p><p><img src="https://img-blog.csdnimg.cn/20210219174140724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="img"></p><p>问前排人是第几排 -&gt; 函数</p><p>所有的递归问题都可以用递推公式来表示，所以要用递归解决问题，关键就是先找到递推公式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1)+1</span><br><span class="line">f(1) &#x3D; 1</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>f(n) 表示你当前是第几排，f(n-1) 前面一排所在的排数，f(1) = 1 表示第一排的人知道自己是第一排。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> f(n-<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归需要满足 3 要素：</p><p>1、一个父问题可以拆分成若干个子问题，并且若干子问题的结果汇总起来就是父问题的答案。</p><p>2、父问题和子问题，解题思路必须完全一致，只是数据规模不同。</p><p>3、存在终止条件。</p><p>问题在不断拆分的同时，一定要在某个节点终止拆分，得到一个明确的答案。</p><p>问题：假设有 n 个台阶，每次可以跨 1 个台阶或者 2 个台阶，请问走完这 n 个台阶一共有多少种走法？</p><p>1、假设有 1 个台阶，一共有（1） 种走法</p><p>2、假设有 2 个台阶，一共有 2 种走法 【1，1】【2】</p><p>3、假设有 3 个台阶，一共有（）种走法？【1，1，1】【1，2】【2，1】</p><p>…</p><p>可以根据第一步的走法进行分类</p><p>第一类是第一步走了 1 个台阶</p><p>第二类是第一步走了 2 个台阶</p><p>所以 n 个台阶的走法就等于先走 1 个台阶后，n-1 个台阶的走法+先走 2 个台阶后，n-2 个台阶的走法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-<span class="number">1</span>)+f(n-<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>f(1) = 1，能否作为终止条件？</p><p>n = 2，f(2) = f(1)+f(0)，如果终止条件只有一个 f(1) = 1，f(2) 就无法求解， 因为 f(0) 的值无法确定，</p><p>把 f(2) = 2 作为一个终止条件</p><p>终止条件有两个：</p><p>f(1) = 1;</p><p>f(2) = 2;</p><p>n = 3，f(3) = f(2)+f(1) = 3</p><p>n = 4，f(4) = f(3)+f(2) = 3 + 2 = 5</p><p>递推公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(1) &#x3D; 1;</span><br><span class="line">f(2) &#x3D; 2;</span><br><span class="line">f(n) &#x3D; f(n-1)+f(n-2);</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>推导出递归代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            System.out.println(i+<span class="string">&quot;个台阶共有&quot;</span>+f(i)+<span class="string">&quot;种走法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = f(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;d:&quot;</span>+d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m:&quot;</span>+n);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;n:&quot;</span>+n);</span><br><span class="line">            <span class="comment">//n=4</span></span><br><span class="line">            <span class="keyword">int</span> c = f(n-<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;c:&quot;</span>+c);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/yRspkQ"><img src="https://img-blog.csdnimg.cn/img_convert/20cd2c953dc0426daee68ff9d406615d.png" alt="yRspkQ.png"></a></p><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>为什么要使用集合框架？</p><p>1、数组的长度是固定</p><p>2、数组无法同时存储多个不同的数据类型</p><p>集合简单理解就是一个长度可以改变，可以保持任意数据类型的动态数组。</p><p>集合本身是数据结果的基本概念之一，我们这里说的集合是 Java 语言对这种数据结果的具体实现。</p><p>Java 中的集合不是由一个类来完成的，而是由一组接口和类构成了一个框架体系。大致可分为 3 层，最上层是一组接口，继而是接口的实现类。</p><h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><p>Collection：集合框架最基础的接口，最顶层的接口。</p><p>List：Collection 的子接口，存储有序、不唯一（元素可重复）的对象，最常用的接口。</p><p>Set：Collection 的子接口，存储无序、唯一（元素不可重复）的对象。</p><p>Map：独立于 Collection 的另外一个接口，最顶层的接口，存储一组键值对象，提供键到值的映射。</p><p>Iterator：输出集合元素的接口，一般适用于无序集合，从前往后输出。</p><p>ListIterator：Iterator 子接口，可以双向输出集合中的元素。</p><p>Enumeration：传统的输出接口，已经被 Iterator 取代。</p><p>SortedSet：Set 的子接口，可以对集合中的元素进行排序。</p><p>SortedMap：Map 的子接口，可以对集合中的元素进行排序。</p><p>Queue：队列接口。</p><p>Map.Entry：Map 的内部接口，描述 Map 中存储的一组键值对元素。</p><h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>Collection 是集合框架中最基础的父接口，可以存储一组无序，不唯一的对象。<br><img src="https://img-blog.csdnimg.cn/20210219174220203.png" alt="在这里插入图片描述"></p><p>Collection 接口可以存储一组无序，不唯一（可重复）的对象，一般不直接使用该接口，也不能被实例化，只是用来<strong>提供规范</strong>。</p><p>Collection 是 Iterable 接口的子接口。</p><table><thead><tr><th>int size()</th><th>获取集合长度</th></tr></thead><tbody><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否存在某个对象</td></tr><tr><td>Iterator iterator()</td><td>实例化 Iterator 接口，遍历集合</td></tr><tr><td>Object[] toArray()</td><td>将集合转换为一个 Object 数组</td></tr><tr><td>T[] toArray(T[] a)</td><td>将集合转换为一个指定数据类型的数组</td></tr><tr><td>boolean add(E e)</td><td>向集合中添加元素</td></tr><tr><td>boolean remove(Object o)</td><td>从集合中删除元素</td></tr><tr><td>boolean containsAll(Collection c)</td><td>判断集合中是否存在另一个集合的所有元素</td></tr><tr><td>boolean addAll(Collection c)</td><td>向集合中添加某个集合的所有元素</td></tr><tr><td>boolean removeAll(Collection c)</td><td>从集合中删除某个集合的所有元素</td></tr><tr><td>void clear()</td><td>清除集合中的所有元素</td></tr><tr><td>boolean equals(Collection c)</td><td>判断两个集合是否相等</td></tr><tr><td>int hashCode()</td><td>返回集合的哈希值</td></tr></tbody></table><h3 id="Collection-子接口"><a href="#Collection-子接口" class="headerlink" title="Collection 子接口"></a>Collection 子接口</h3><ul><li>List：存放有序、不唯一的元素</li><li>Set：存放无序、唯一的元素</li><li>Queue：队列接口</li></ul><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><p><img src="https://img-blog.csdnimg.cn/20210219174239416.png" alt="在这里插入图片描述"></p><p>List 常用的扩展方法：</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>T get(int index)</td><td>通过下标返回集合中对应位置的元素</td></tr><tr><td>T set(int index,T element)</td><td>在集合中的指定位置存入对象</td></tr><tr><td>int indexOf(Object o)</td><td>从前向后查找某个对象在集合中的位置</td></tr><tr><td>int lastIndexOf(Object o)</td><td>从后向前查找某个对象在集合中的位置</td></tr><tr><td>ListIterator listIterator()</td><td>实例化 ListIterator 接口，用来遍历 List 集合</td></tr><tr><td>List subList(int fromIndex,int toIndex)</td><td>通过下标截取 List 集合</td></tr></tbody></table><h3 id="List-接口的实现类"><a href="#List-接口的实现类" class="headerlink" title="List 接口的实现类"></a>List 接口的实现类</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList 是开发中使用频率最高的 List 实现类，实现了长度可变的数组，在内存中分配连续空间，所以读取快，增删慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;JavaSE&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;JavaME&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;JavaEE&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list:&quot;</span>+list);</span><br><span class="line">        System.out.println(<span class="string">&quot;list长度:&quot;</span>+list.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;list是否包含Java:&quot;</span>+list.contains(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        list.remove(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;Spring Boot&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.set(<span class="number">1</span>,<span class="string">&quot;Spring Cloud&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;*************&quot;</span>);</span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;Spring&quot;</span>));</span><br><span class="line">        System.out.println(list.subList(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList：基于数组的实现，非线程安全，效率高，所有的方法都没有 synchronized 修饰。</p><h4 id="Vector-1"><a href="#Vector-1" class="headerlink" title="Vector"></a>Vector</h4><p>线程安全，效率低，实现线程安全直接通过 synchronized 修饰方法来完成。</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>Vector 的子类，实现了<strong>栈</strong>的数据结构，（后进先出）</p><ul><li>push：入栈方法</li><li>peek：取出栈顶元素，将栈顶复制一份取出，取完之后栈内的数据不变。</li><li>pop：取出栈顶元素，直接取出栈顶元素，取完之后栈内的数据减一。</li></ul><h4 id="LikedList"><a href="#LikedList" class="headerlink" title="LikedList"></a>LikedList</h4><p>实现了先进先出的队列，采用链表的形式存储。</p><p>ArrayList 和 LikedList 的区别：内存中存储的形式不同，ArrayList 采用的数组的方式，LinkedList 采用的是链表的形式。</p><p>数组在内存中存储空间是连续的，读取快，增删慢。</p><p>因为数组在内存中是连续的，所以取数据可以通过寻址公式很快求出目标元素的内存地址，因为内存是连续的，所以新增或者删除元素，必然需要移动数据，而且<strong>数组长度越长，需要移动的元素越多，操作就越慢。</strong></p><p><img src="https://img-blog.csdnimg.cn/20210219174322436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>链表在内存中存储空间是不连续的，读取慢，增删快。链表在内存中是不连续的，没有固定的公式可以使用，要读取只能从第一位开始一直遍历到目标元素，数据规模越大，操作越慢。</p><p>增删快，因为只需要重新设置目标元素前后两个节点的后置指针即可，与数据规模无关。</p><p><img src="https://img-blog.csdnimg.cn/20210219174335324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        linkedList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        linkedList.offer(<span class="string">&quot;JavaSE&quot;</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        linkedList.push(<span class="string">&quot;JavaME&quot;</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        linkedList.addFirst(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        linkedList.addLast(<span class="string">&quot;Last&quot;</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        System.out.println(linkedList.peek());</span><br><span class="line">        System.out.println(linkedList.peekFirst());</span><br><span class="line">        System.out.println(linkedList.peekLast());</span><br><span class="line">        System.out.println(linkedList.pop());</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedList 和 Stack 都有 pop 方法，有什么区别和相同点？</strong></p><p>pop 方法都是取出集合中的第一个元素，但是两者的顺序是相反的，Stack 是“后进先出”，所以 pop 取出的是最后一个元素，LinkedList 是“先进先出”，所以 pop 取出的是第一个元素。</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>LinkedList 实现了 Deque 接口，而 Deque 接口是 Queue 的子接口，Queue 就是队列，底层实现了队列的数据结构。</p><p>实际开发中，不能直接实例化 Queue 对象。</p><p>Queue 的实现类是 AbstractQueue，它是一个抽象类，不能直接实例化，开发中需要实现它的子类 PriorityQueue。</p><p>Queue 中添加的数据必须是有顺序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.demo5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue queue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line"><span class="comment">//        queue.add(1);</span></span><br><span class="line"><span class="comment">//        queue.add(2);</span></span><br><span class="line"><span class="comment">//        queue.add(3);</span></span><br><span class="line"><span class="comment">//        queue.add(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">//        queue.add(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">//        queue.add(&quot;c&quot;);</span></span><br><span class="line"></span><br><span class="line">        queue.add(<span class="keyword">new</span> A(<span class="number">1</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> A(<span class="number">2</span>));</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        A a = (A)o;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.num &gt; a.num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.num == a.num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;num=&quot;</span> + num +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Queue 默认给元素进行升序排列，即自然排序。</p><h3 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h3><ul><li>List（有序不唯一）</li><li>Set</li><li>Map</li></ul><p>List Set：存储的是单个数据，List 可以存储重复的数据，Set 数据不能重复</p><p>Map：存储的是一组数据</p><h3 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h3><p>跟 List 一样，Set 是 Collection 的子接口，Set 集合是以散列的形式存储数据，所以元素是没有顺序的，可以存储一组无序且唯一的数据。</p><p><img src="https://img-blog.csdnimg.cn/20210219174358107.png" alt="在这里插入图片描述"></p><p>Set 常用实现类：</p><ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>HashSet 是开发中经常使用的一个实现类，存储一组无序且唯一的对象。</p><p>无序：元素的存储顺序和遍历顺序不一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        set.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        set.remove(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">        iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>LinkedHasSet 是 Set 的另外一个实现类，可以存储一组有序且唯一的元素.</p><p>有序：元素的存储顺序和遍历顺序一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashSet linkedHashSet = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedHashSet的长度是&quot;</span>+linkedHashSet.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;遍历LinkedHashSet&quot;</span>);</span><br><span class="line">        Iterator iterator = linkedHashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        linkedHashSet.remove(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(linkedHashSet.contains(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="equals-和-的区别？"><a href="#equals-和-的区别？" class="headerlink" title="equals 和 == 的区别？"></a>equals 和 == 的区别？</h5><p>所有类中的 equals 都是继承自 Object 类，Object 类中原生的 eqauls 方法就是在通过 == 进行判断</p><p><img src="https://img-blog.csdnimg.cn/20210219174417570.png" alt="img"></p><p>但是每个类都可以对 equals 方法进行重写，覆盖掉之前使用 == 进行判断的逻辑，改用新的逻辑进行判断是否相等。</p><p>LinkedHashSet 如何判断两个对象是否相等？</p><p>首先会判断两个对象的 hashCode 是否相等</p><blockquote><p>什么是 hashCode？</p></blockquote><p>将对象的内部信息（内存地址、属性值等），通过某种特定规则转换成一个散列值，就是该对象的 hashCode。</p><ul><li>两个不同对象的 hashCode 值可能相等。</li><li>hashCode 不相等的两个对象一定不是同一个对象。</li></ul><p>集合在判断两个对象是否相等的时候：</p><p>1、会先比较他们的 hashCode，如果 hashCode 不相等，则认为不是同一个对象，可以添加。</p><p>2、如果 hashCode 值相等，还不能认为两个对象是相等的，需要通过 equals 进行进一步的判断，equals 相等，则两个对象相等，否则两个对象不相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashSet set = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        Data data1 = <span class="keyword">new</span> Data(<span class="number">1</span>);</span><br><span class="line">        set.add(data1);</span><br><span class="line">        Data data2 = <span class="keyword">new</span> Data(<span class="number">1</span>);</span><br><span class="line">        set.add(data2);</span><br><span class="line">        <span class="comment">//是一个对象</span></span><br><span class="line">        System.out.println(data1.equals(data2));</span><br><span class="line">        <span class="comment">//不是一个对象</span></span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Data&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;num=&quot;</span> + num +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hashcode</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//instanceof 判断对象是否属于某个类</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Data)&#123;</span><br><span class="line">            Data data = (Data) obj;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.num == data.num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051</span></span><br></pre></td></tr></table></figure><h5 id="：判断的是栈内存中的值。"><a href="#：判断的是栈内存中的值。" class="headerlink" title="==：判断的是栈内存中的值。"></a>==：判断的是栈内存中的值。</h5><p><code>引用类型的数据</code>：栈内存中存储的是地址，所以此时 == 判断的是引用地址。</p><p><code>基本数据类型</code>：栈内存中存储的是具体的数值。</p><p><img src="https://img-blog.csdnimg.cn/20210219174437512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>栈中存储的是变量</p><p>Data data;</p><p>int num;</p><p>引用类型具体的对象（属性）存储在堆中的，再<strong>将堆中对象的内存地址赋值给栈中的变量</strong> data，data 中存储的就是地址。</p><p>基本数据类型不需要用到堆内存，变量在栈中，变量的值直接存储在变量中。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>LinkedHashSet 和 TreeSet 都是存储一组<strong>有序且唯一</strong>的数据，但是这里的两个有序是有区别的。</p><p>LinkedHashSet 的有序是指元素的<strong>存储顺序和遍历顺序</strong>是一致的。</p><p>如：6,3,4,5,1,2–&gt;6,3,4,5,1,2</p><p>TreeSet 的有序是指集合内部会<strong>自动对所有的元素</strong>按照升序进行排列，无论存入的顺序是什么，遍历的时候一定按照生序输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet treeSet = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        <span class="comment">//        treeSet.add(1);</span></span><br><span class="line">        <span class="comment">//        treeSet.add(3);</span></span><br><span class="line">        <span class="comment">//        treeSet.add(6);</span></span><br><span class="line">        <span class="comment">//        treeSet.add(2);</span></span><br><span class="line">        <span class="comment">//        treeSet.add(5);</span></span><br><span class="line">        <span class="comment">//        treeSet.add(4);</span></span><br><span class="line">        <span class="comment">//        treeSet.add(1);</span></span><br><span class="line">        treeSet.add(<span class="string">&quot;b11&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;e22&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;a33&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;c44&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;d55&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;treeSet的长度是&quot;</span>+treeSet.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;treeSet遍历&quot;</span>);</span><br><span class="line">        Iterator iterator = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet treeSet = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Data(<span class="number">1</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Data(<span class="number">3</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Data(<span class="number">6</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Data(<span class="number">2</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Data(<span class="number">5</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Data(<span class="number">4</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Data(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;treeSet的长度&quot;</span>+treeSet.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;treeSet遍历&quot;</span>);</span><br><span class="line">        Iterator iterator = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A.compareTo(B)</span></span><br><span class="line"><span class="comment">     * 返回值：</span></span><br><span class="line"><span class="comment">     * 1 表示A大于B</span></span><br><span class="line"><span class="comment">     * 0 表示A等于B</span></span><br><span class="line"><span class="comment">     * -1 表示A小于B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Data)&#123;</span><br><span class="line">            Data data = (Data) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.num &lt; data.num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.num == data.num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Data&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;num=&quot;</span> + num +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><p>key-value，数据字典</p><p><img src="https://img-blog.csdnimg.cn/20210219174500640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>List、Set 接口都是 Collection 的子接口，Map 接口是与 Collection 完全独立的另外一个体系。</p><p>List &amp; Set VS Map</p><p>List &amp; Set &amp; Collection 只能操作单个元素，Map 可以操作一对元素，因为 Map 存储结构是 key - value 映射。</p><p>Map 接口定义时使用了泛型，并且定义两个泛型 K 和 V，K 表示 key，规定键元素的数据类型，V 表示 value，规定值元素的数据类型。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>int size()</td><td>获取集合长度</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>boolean containsKey(Object key)</td><td>判断集合中是否存在某个 key</td></tr><tr><td>boolean containsValue(Object value)</td><td>判断集合中是否存在某个 value</td></tr><tr><td>V get(Object key)</td><td>取出集合中 key 对应的 value</td></tr><tr><td>V put(K key,V value)</td><td>向集合中存入一组 key-value 的元素</td></tr><tr><td>V remove(Object key)</td><td>删除集合中 key 对应的 value</td></tr><tr><td>void putAll(Map map)</td><td>向集合中添加另外一个 Map</td></tr><tr><td>void clear()</td><td>清除集合中所有的元素</td></tr><tr><td>Set keySet()</td><td>取出集合中所有的 key，返回一个 Set</td></tr><tr><td>Collection values()</td><td>取出集合中所有的 value，返回一个 Collection</td></tr><tr><td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td><td>将 Map 以 Set 的形式输出</td></tr><tr><td>int hashCode()</td><td>获取集合的散列值</td></tr><tr><td>boolean equals(Object o)</td><td>比较两个集合是否相等</td></tr></tbody></table><h3 id="Map-接口的实现类"><a href="#Map-接口的实现类" class="headerlink" title="Map 接口的实现类"></a>Map 接口的实现类</h3><ul><li>HashMap：存储一组无序，key 不可以重复，value 可以重复的元素。</li><li>Hashtable：存储一组无序，key 不可以重复，value 可以重复的元素。</li><li>TreeMap：存储一组有序，key 不可以重复，value 可以重复的元素，可以按照 key 进行排序。</li></ul><h4 id="HashMap-的使用"><a href="#HashMap-的使用" class="headerlink" title="HashMap 的使用"></a>HashMap 的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hashMap.put(<span class="string">&quot;h&quot;</span>,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;w&quot;</span>,<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;j&quot;</span>,<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;s&quot;</span>,<span class="string">&quot;JavaSE&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;m&quot;</span>,<span class="string">&quot;JavaME&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;e&quot;</span>,<span class="string">&quot;JavaEE&quot;</span>);</span><br><span class="line">        System.out.println(hashMap);</span><br><span class="line">        hashMap.remove(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除之后&quot;</span>+hashMap);</span><br><span class="line">        hashMap.put(<span class="string">&quot;m&quot;</span>,<span class="string">&quot;Model&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加之后&quot;</span>+hashMap);</span><br><span class="line">        <span class="keyword">if</span> (hashMap.containsKey(<span class="string">&quot;a&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;集合中存在key=a&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;集合中不存在key=a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hashMap.containsValue(<span class="string">&quot;Java&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;集合中存在value=Java&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;集合中不存在value=Java&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set keys = hashMap.keySet();</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的key&quot;</span>);</span><br><span class="line">        Iterator iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        Collection values = hashMap.values();</span><br><span class="line">        <span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;************&quot;</span>);</span><br><span class="line">        iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            String key = (String) iterator.next();</span><br><span class="line">            String value = (String) hashMap.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;-&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>Hashtable 用法与 HashMap基本一样，它们的区别是，Hashtable是线程安全的，但是性能较低。HashMap 是非线程安全的，但是性能较高。</p><p>HashMap，方法没有用 synchronized 修饰，所以是非线程安全的。</p><p><img src="https://img-blog.csdnimg.cn/202102191746036.png" alt="在这里插入图片描述"></p><p>Hashtable，方法用 synchronized 修饰，所以是线程安全的。</p><p><img src="https://img-blog.csdnimg.cn/20210219174627625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>Hashtable 的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashtable.put(<span class="string">&quot;h&quot;</span>,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;w&quot;</span>,<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;j&quot;</span>,<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;s&quot;</span>,<span class="string">&quot;JavaSE&quot;</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;m&quot;</span>,<span class="string">&quot;JavaME&quot;</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;e&quot;</span>,<span class="string">&quot;JavaEE&quot;</span>);</span><br><span class="line">        System.out.println(hashtable);</span><br><span class="line">        hashtable.remove(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        System.out.println(hashtable);</span><br><span class="line">        System.out.println(hashtable.containsKey(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(hashtable.containsValue(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">        Set keys = hashtable.keySet();</span><br><span class="line">        System.out.println(keys);</span><br><span class="line">        Collection values = hashtable.values();</span><br><span class="line">        System.out.println(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 和 Hashtable，保存的书画家都是无序的，Map 的另外一个实现类 TreeMap 主要功能是按照 key 对集合中的元素进行排序。</p><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap 的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap treeMap = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">&quot;Java&quot;</span>),<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> User(<span class="number">5</span>,<span class="string">&quot;JavaME&quot;</span>),<span class="string">&quot;JavaME&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;Hello&quot;</span>),<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> User(<span class="number">6</span>,<span class="string">&quot;JavaEE&quot;</span>),<span class="string">&quot;JavaEE&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;World&quot;</span>),<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">&quot;JavaSE&quot;</span>),<span class="string">&quot;JavaSE&quot;</span>);</span><br><span class="line">        System.out.println(treeMap);</span><br><span class="line">        Set set = treeMap.keySet();</span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Object key = iterator.next();</span><br><span class="line">            System.out.println(key+<span class="string">&quot;-&quot;</span>+treeMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            User user = (User)o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.id &gt; user.id)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.id == user.id)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><p>Collection 接口，List 和 Set的父接口。</p><p>Collections不是接口，它是一个<strong>工具类</strong>，专门提供了一些对集合的操作，方便开发者去使用，完成相应的业务功能。</p><p>Colletions 针对集合的工具类，Collection</p><p>Arrays 针对数组的工具类，Array</p><table><thead><tr><th>name</th><th>描述</th></tr></thead><tbody><tr><td>public static sort()</td><td>对集合进行排序</td></tr><tr><td>public static int binarySearch(List list,Object v)</td><td>查找 v 在 list 中的位置，集合必须是生序排列</td></tr><tr><td>public static get(List list,int index)</td><td>返回 list 中 index 位置的值</td></tr><tr><td>public static void reverse(List list)</td><td>对 list 进行反序输出</td></tr><tr><td>public static void swap(List list,int i,int j)</td><td>交换集合中指定位置的两个元素</td></tr><tr><td>public static void fill(List list,Object obj)</td><td>将集合中所有元素替换成 obj</td></tr><tr><td>public static Object min(List list)</td><td>返回集合中的最小值</td></tr><tr><td>public static Object max(List list)</td><td>返回集合中的最大值</td></tr><tr><td>public static boolean replaceAll(List list,Object old,Object new)</td><td>在 list 集合中用 new 替换 old</td></tr><tr><td>public static boolean addAll(List list,Object… obj)</td><td>向集合中添加元素</td></tr></tbody></table><p>可变参数，在调用方法的时候，参数可以是任意个数，但是类型必须匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>... arg)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>但是下面这种写法，可以传任意类型，任意数量的参数，多态的一种具体表示形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object... arg)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>Java 中默认输出对象的格式：对象所属的全类名（全限定类名）带着包名的类名+@+对象的哈希值</p><p>断点 breakpoint</p><p>JavaScript js 脚本语言</p><p>Java 是必须全部编译之后，统一执行，假如有 10 行 Java 代码，必须先对这 10 行代码进行编译，通过之后，再交给 JVM 执行。</p><p>JS 逐行执行，执行一行算一行，假如有 10 行 JS 代码，一行一行开始执行，执行到第 5 行报错，那么后续 6-10 就不再执行，但是已经执行的前 5 行结果不变。</p><p>Java 更加严谨，JS 更加随意</p><p>Java 是强语言类型的，JS 是弱语言类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//        list.add(&quot;Hello&quot;);</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Java&quot;);</span></span><br><span class="line"><span class="comment">//        Collections.addAll(list,&quot;Java&quot;,&quot;JavaME&quot;,&quot;World&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;排序之前&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(list);</span></span><br><span class="line">        <span class="comment">//进行排序-》升序a</span></span><br><span class="line"><span class="comment">//        Collections.sort(list);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;排序之后&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(list);</span></span><br><span class="line">        <span class="comment">//查找元素在集合中的下标,二分查找法（集合中的元素必须升序排列）</span></span><br><span class="line"><span class="comment">//        int index = Collections.binarySearch(list,&quot;Java&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;Java 在 list 中的下标&quot;+index);</span></span><br><span class="line"><span class="comment">//        System.out.println(list);</span></span><br><span class="line"><span class="comment">//        Collections.replaceAll(list,&quot;Java&quot;,&quot;Collections&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(list);</span></span><br><span class="line"></span><br><span class="line">        Collections.addAll(</span><br><span class="line">                list,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">30</span>),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">26</span>),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">&quot;王五&quot;</span>,<span class="number">18</span>)</span><br><span class="line">        );</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            User user = (User) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.age &lt; user.age)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.age == user.age)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型（Generics），是指在类定义时不指定类中信息的具体数据类型，而是暂时用一个标识符来替代，当外部实例化对象的时候再来指定具体的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 A 类的时候就指定了属性是 B 类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> C <span class="title">test</span><span class="params">(D d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义 A 类的时候不指定属性的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>,<span class="title">E</span>,<span class="title">M</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">test</span><span class="params">(M m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A&lt;B,C,D&gt; a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure><p>优点：这样做极大地提升程序的灵活性，提升类的扩展性，泛型可以指代类中成员变量的数据类型，方法的返回值类型以及方法的参数类型。</p><h3 id="泛型的应用"><a href="#泛型的应用" class="headerlink" title="泛型的应用"></a>泛型的应用</h3><p>自定义类中添加泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名&lt;泛型1,泛型2,泛型3...&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> 泛型<span class="number">1</span> 属性名;</span><br><span class="line"><span class="keyword">public</span> 泛型<span class="number">2</span> 方法名(泛型<span class="number">3</span>)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Time</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Time&lt;Integer&gt; time1 = <span class="keyword">new</span> Time&lt;&gt;();</span><br><span class="line">        time1.setValue(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的时间是&quot;</span>+time1.getValue());</span><br><span class="line">        Time&lt;String&gt; time2 = <span class="keyword">new</span> Time&lt;&gt;();</span><br><span class="line">        time2.setValue(<span class="string">&quot;十点整&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的时间是&quot;</span>+time2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型用哪个字母都可以，关键是类定义处的字母和类中信息的字母保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Time</span>&lt;<span class="title">H</span>,<span class="title">M</span>,<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> H hour;</span><br><span class="line">    <span class="keyword">private</span> M minute;</span><br><span class="line">    <span class="keyword">private</span> S second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> H <span class="title">getHour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHour</span><span class="params">(H hour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hour = hour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> M <span class="title">getMinute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinute</span><span class="params">(M minute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.minute = minute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(S second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Time&lt;String,Integer,Float&gt; time = <span class="keyword">new</span> Time&lt;&gt;();</span><br><span class="line">        time.setHour(<span class="string">&quot;十点&quot;</span>);</span><br><span class="line">        time.setMinute(<span class="number">10</span>);</span><br><span class="line">        time.setSecond(<span class="number">10.0f</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的时间是&quot;</span>+time.getHour()+<span class="string">&quot;:&quot;</span>+time.getMinute()+<span class="string">&quot;:&quot;</span>+time.getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>有一个参数为 ArrayList 的方法，希望这个方法即可接收泛型是 String 的集合，又可以接收泛型是 Integer 的集合，怎么实现？</p><p>多态在泛型中不适用</p><p><img src="https://img-blog.csdnimg.cn/20210219174715904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        test(list1);</span><br><span class="line">        test(list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ArrayList&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList&lt;?&gt; 表示可以使用任意的泛型类型对象，这样 test 方法具备通用性了。</p><h3 id="泛型上限和下限"><a href="#泛型上限和下限" class="headerlink" title="泛型上限和下限"></a>泛型上限和下限</h3><p>上限：表示实例化时具体的数据类型，可以是上限类型的子类或者是上限类型本身，用 extends 表示。</p><p>下限：表示实例化时具体的数据类型，可以是下限类型的父类或者是下限类型本身，用 super 表示。</p><p>类名&lt;泛型标识 extends 上限类名&gt;</p><p>类名&lt;泛型标识 super 下限类名&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Time</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> Time&lt;Float&gt;());</span><br><span class="line">        test(<span class="keyword">new</span> Time&lt;Integer&gt;());</span><br><span class="line">        test(<span class="keyword">new</span> Time&lt;Number&gt;());</span><br><span class="line"></span><br><span class="line">        test2(<span class="keyword">new</span> Time&lt;String&gt;());</span><br><span class="line">        test2(<span class="keyword">new</span> Time&lt;Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型上限</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Time&lt;? extends Number&gt; time)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型下限</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Time&lt;? <span class="keyword">super</span> String&gt; time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现泛型接口有两种方式：</p><ul><li>实现类在定义时继续使用泛型标识</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyInterface</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInterfaceImpl</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现类在定义时直接给出具体的数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl2</span> <span class="keyword">implements</span> <span class="title">MyInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInterfaceImpl2</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        MyInterfaceImpl myInterface = <span class="keyword">new</span> MyInterfaceImpl&lt;String&gt;(<span class="string">&quot;接口&quot;</span>);</span><br><span class="line">        String val = (String) myInterface.getValue();</span><br><span class="line"></span><br><span class="line">        MyInterfaceImpl2 myInterface1 = <span class="keyword">new</span> MyInterfaceImpl2(<span class="string">&quot;接口&quot;</span>);</span><br><span class="line">        val = myInterface1.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-实用类"><a href="#Java-实用类" class="headerlink" title="Java 实用类"></a>Java 实用类</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举 Enum，是一种有确定值区间的数据类型，本质上就是一个类，具有简洁、安全、方便等特点。</p><p>枚举的值被约束到了一个特定的范围内，只能从这个范围以内取值。</p><p>为什么要有枚举？</p><p>因为在描述某些对象的属性时，该属性的值不能随便定义，必须在某个特定的区间内取值。</p><p>出于对数据的安全性考虑，类似这种有特定取值范围的数据我们就可以使用枚举来描述。</p><p>枚举指由一组常量组成的类型，指定一个取值区间，我们只能从该区间中取值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Week</span> <span class="keyword">extends</span> <span class="title">Enum</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week MONDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week TUESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week WEDNSDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week THURSDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week FRIDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SATURDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SUNDAY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Week $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        MONDAY = <span class="keyword">new</span> Week(<span class="string">&quot;MONDAY&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        TUESDAY = <span class="keyword">new</span> Week(<span class="string">&quot;TUESDAY&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        WEDNSDAY = <span class="keyword">new</span> Week(<span class="string">&quot;WEDNSDAY&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        THURSDAY = <span class="keyword">new</span> Week(<span class="string">&quot;THURSDAY&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        FRIDAY = <span class="keyword">new</span> Week(<span class="string">&quot;FRIDAY&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        SATURDAY = <span class="keyword">new</span> Week(<span class="string">&quot;SATURDAY&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        SUNDAY = <span class="keyword">new</span> Week(<span class="string">&quot;SUNDAY&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        $VALUES[] = (<span class="keyword">new</span> Week[]&#123;</span><br><span class="line">            MONDAY,TUESDAY,WEDNSDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Week[] values()&#123;</span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Week <span class="title">valueOf</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String s,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>Math 类为开发者提供了一系列的数学方法，同时还提供了两个静态常量 E（自然对数的底数）和 PI（圆周率）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;常量E&quot;</span>+Math.E);</span><br><span class="line">        System.out.println(<span class="string">&quot;常量PI&quot;</span>+Math.PI);</span><br><span class="line">        System.out.println(<span class="string">&quot;9的平方根&quot;</span>+Math.sqrt(<span class="number">9</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;8的立方根&quot;</span>+Math.cbrt(<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;2的3次方&quot;</span>+Math.pow(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;较大值&quot;</span>+Math.max(<span class="number">6.5</span>,<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;-10.3的绝对值&quot;</span>+Math.abs(-<span class="number">10.3</span>));</span><br><span class="line">        System.out.println(Math.ceil(<span class="number">10.000001</span>));</span><br><span class="line">        System.out.println(Math.floor(<span class="number">10.999999</span>));</span><br><span class="line">        System.out.println((<span class="keyword">int</span>)(Math.random()*<span class="number">10</span>));</span><br><span class="line">        System.out.println(Math.rint(<span class="number">5.4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>用来产生随机数的类，并且可以任意指定一个区间，在此区间范围内产生一个随机数。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public Random()</td><td>创建一个无参的随机数构造器，使用系统时间作为默认种子</td></tr><tr><td>public Random(long seed)</td><td>使用 long 数据类型的种子创建一个随机数构造器</td></tr><tr><td>public boolean nextBoolean()</td><td>返回一个 boolean 类型的随机数</td></tr><tr><td>public double nextDouble()</td><td>返回一个 double 类型的随机数，0.0 - 1.0 之间</td></tr><tr><td>public float nextFloat()</td><td>返回一个 float 类型的随机数，0.0 - 1.0 之间</td></tr><tr><td>public int nextInt()</td><td>返回一个 int 类型的随机数</td></tr><tr><td>public int nextInt(n)</td><td>返回一个 int 类型的随机数，0-n之间</td></tr><tr><td>public long nextLong</td><td>返回一个 long 类型的随机数，0-1 之间</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//生成订单编号（时间戳+随机数）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//随机生成一个六位数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;订单&quot;</span>+i+<span class="string">&quot;的编号是：&quot;</span>+System.currentTimeMillis()+random.nextInt(<span class="number">100000</span>)+<span class="number">100000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Java 通过 String 类来创建和操作字符串数据。</p><ul><li>String 实例化</li></ul><p>1、直接赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure><p>2、通过构造函数创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210219174752458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210219174803462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isLatin1() ? StringLatin1.equals(value, aString.value)</span><br><span class="line">:StringUTF16.equals(value, aString.value);</span><br></pre></td></tr></table></figure><p>三目运算符 三元表达式</p><h4 id="String-常用方法"><a href="#String-常用方法" class="headerlink" title="String 常用方法"></a>String 常用方法</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public String()</td><td>创建一个空的字符串对象</td></tr><tr><td>public String(String value)</td><td>创建一个值为 value 的字符串对象</td></tr><tr><td>public String(char value[])</td><td>将一个char数组转换为字符串对象</td></tr><tr><td>public String(char value[],int offset, int count)</td><td>将一个指定范围的char数组转为字符串对象</td></tr><tr><td>public String(byte value[])</td><td>将一个byte数组转换为字符串对象</td></tr><tr><td>public String(byte value[],int offset, int count)</td><td>将一个指定范围的byte数组转为字符串对象</td></tr><tr><td>public int length()</td><td>获取字符串的长度</td></tr><tr><td>public boolean isEmpty()</td><td>判断字符串是否为空</td></tr><tr><td>public char charAt(int index)</td><td>返回指定下标的字符</td></tr><tr><td>public byte[] getBytes()</td><td>返回字符串对应的byte数组</td></tr><tr><td>public boolean equals(Object anObject)</td><td>判断两个字符串值是否相等</td></tr><tr><td>public boolean equalsIgnoreCase(Object anObject)</td><td>判断两个字符串值是否相等（忽略大小写）</td></tr><tr><td>public int compareTo(String value)</td><td>对字符串进行排序</td></tr><tr><td>public int compareToIgnoreCase(String value)</td><td>忽略大小写进行排序</td></tr><tr><td>public boolean startsWith(String value)</td><td>判断字符串是否以 value 开头</td></tr><tr><td>public boolean endsWith(String value)</td><td>判断字符串是否以 value 结尾</td></tr><tr><td>public int hashCode()</td><td>返回字符串的 hash 值</td></tr><tr><td>public int indexOf(String str)</td><td>返回 str 在字符串中的下标</td></tr><tr><td>public int indexOf(String str,int formIndex)</td><td>从指定位置查找字符串的下标</td></tr><tr><td>public String subString(int beginIndex)</td><td>从指定位置开始截取字符串</td></tr><tr><td>public String subString(int beginIndex,int endIndex)</td><td>截取指定区间的字符串</td></tr><tr><td>public String concat(String str)</td><td>追加字符串</td></tr><tr><td>public String replaceAll(String o,String n)</td><td>将字符串中所有的 o 替换成 n</td></tr><tr><td>public String[] split(String regex)</td><td>用指定的字符串对目标进行分割，返回数组</td></tr><tr><td>public String toLowerCase()</td><td>转小写</td></tr><tr><td>public String toUpperCase()</td><td>转大写</td></tr><tr><td>public char[] toCharArray()</td><td>将字符串转为字符数组</td></tr></tbody></table><p>null 和空是两个概念。</p><p>null 是指对象不存在，引用地址为空。</p><p>空是指对象存在，没有内容，长度为零。</p><p><img src="https://img-blog.csdnimg.cn/20210219174821811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>String 对象一旦创建，值不能修改（原来的值不能修改，一旦修改就是一个新的对象，只要一改动，就会创建一个新的对象）</p><p>修改之后会重新开辟内存空间来存储新的对象，会修改 String 的引用。</p><p><img src="https://img-blog.csdnimg.cn/20210219174835482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>String 的值为什么不能修改？修改之后会创建一个新的对象？而不是在原有对象的基础上进行修改？</p><p>因为 String 底层是用数组来存值的，数组长度一旦创建就不可修改，所以导致上述问题。</p><p>StringBuffer 可以解决 String 频繁修改造成的空间资源浪费的问题。</p><p>StringBuffer 底层也是使用数组来存值。</p><ul><li>StringBuffer 数组的默认长度为 16，使用无参构造函数来创建对象。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210219174849186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XQoz3EIH-1613726775803)(Java SE总结详细.assets/image-20210219150328983.png)]"></p><ul><li>使用有参构造创建对象，数组长度=值的长度+16。<br><img src="https://img-blog.csdnimg.cn/20210219174904850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        StringBuffer stringBuffer1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//stringBuffer 底层数组的长度是 21</span></span><br><span class="line">        <span class="comment">//stringBuffer1 底层数组的长度是 16</span></span><br><span class="line">        stringBuffer1.append(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer.toString().equals(stringBuffer1.toString()));</span><br><span class="line">        System.out.println(stringBuffer.length());</span><br><span class="line">        System.out.println(stringBuffer1.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>length 方法返回的并不是底层数组的长度，而是它的<strong>有效长度</strong>（值的长度）。</p><p>StringBuffer 一旦创建，默认会有 16 个字节的空间去修改，但是一旦追加的字符串长度超过 16，如何处理？</p><p>StringBuffer 不会重新开辟一块新的内存区域，而是在原有的基础上进行扩容，通过调用父类 ensureCapacityInternal() 方法对底层数组进行扩容，保持引用不变。</p><p><img src="https://img-blog.csdnimg.cn/20210219174920704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>StringBuffer 的常用方法，StringBuffer 是线程安全的，但是效率较低，StringBuilder 是线程不安全的，但是效率较高。</p><p>HashMap：线程不安全，效率高</p><p>Hashtable：线程安全，效率低</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public StringBuffer()</td><td>创建一个空的 StringBuffer对象</td></tr><tr><td>public StringBuffer(String str)</td><td>创建一个值为 str 的 StringBuffer 对象</td></tr><tr><td>public synchronized int length()</td><td>返回 StringBuffer 的长度</td></tr><tr><td>public synchronized char charAt(int index)</td><td>返回指定位置的字符</td></tr><tr><td>public synchronized StringBuffer append(String str)</td><td>追加内容</td></tr><tr><td>public synchronized StringBuffer delete(int start,int end)</td><td>删除指定区间的值</td></tr><tr><td>public synchronized StringBuffer deleteCharAt(int index)</td><td>删除指定位置的字符</td></tr><tr><td>public synchronized StringBuffer replace(int start,int end,String str)</td><td>将指定区间的值替换成 str</td></tr><tr><td>public synchronized String substring(int start)</td><td>截取字符串从指定位置到结尾</td></tr><tr><td>public synchronized String substring(int start,int end)</td><td>截取字符串从start开始，到end结束</td></tr><tr><td>public synchronized StringBuffer insert(int offset,String str)</td><td>在指定位置插入 str</td></tr><tr><td>public int indexOf(String str)</td><td>从头开始查找指定字符的位置</td></tr><tr><td>public int indexOf(String str,int fromIndex)</td><td>从fromIndex开始查找指定字符的位置</td></tr><tr><td>public synchronized StringBuffer reverse()</td><td>进行反转</td></tr><tr><td>public synchronized String toString()</td><td>转为 String</td></tr></tbody></table><p>读取数据不需要考虑线程安全问题，因为这种操作不存在安全隐患。</p><h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><ul><li>java.util.Date</li></ul><p>Date 对象表示当前的系统时间</p><ul><li>java.util.Calendar</li></ul><p>Calendar 用来完成日期数据的逻辑运算</p><p>运算思路：（op+com+t）</p><p>1、将日期数据传给 Calendar（Calendar 提供了很多静态常量，专门用来记录日期数据）</p><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td>public static final int YEAR</td><td>年</td></tr><tr><td>public static final int MONTH</td><td>月</td></tr><tr><td>public static final int DAY_OF_MONTH</td><td>天，以月为单位</td></tr><tr><td>public static final int DAY_OF_YEAR</td><td>天，以年为单位</td></tr><tr><td>public static final int HOUR_OF_DAY</td><td>小时</td></tr><tr><td>public static final int MINUTE</td><td>分钟</td></tr><tr><td>public static final int SECOND</td><td>秒</td></tr><tr><td>public static final int MILLSECOND</td><td>毫秒</td></tr></tbody></table><p>2、调用相关方法进行运算</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public static Calendar getInstance()</td><td>获取Calendar实例化对象</td></tr><tr><td>public void set(int field,int value)</td><td>给静态常量赋值</td></tr><tr><td>public int get(int field)</td><td>获取静态常量的值</td></tr><tr><td>public final Date getTime()</td><td>将Calendar转为Date对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算今天所在的周是2020年的第几周</span></span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.set(Calendar.YEAR,<span class="number">2020</span>);</span><br><span class="line">        <span class="comment">//1月为0，4月为3</span></span><br><span class="line">        calendar.set(Calendar.MONTH,<span class="number">3</span>);</span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH,<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">int</span> week = calendar.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">        System.out.println(week);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//今天之后的63天是几月几号</span></span><br><span class="line">        <span class="keyword">int</span> days = calendar.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">        days += <span class="number">63</span>;</span><br><span class="line">        calendar.set(Calendar.DAY_OF_YEAR,days);</span><br><span class="line">        Date date = calendar.getTime();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        System.out.println(simpleDateFormat.format(date));</span><br><span class="line">        <span class="comment">//今天之前的63天是几月几号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//        calendar.set(Calendar.YEAR,2020);</span></span><br><span class="line">        <span class="comment">//        //1月为0，4月为3</span></span><br><span class="line">        <span class="comment">//        calendar.set(Calendar.MONTH,3);</span></span><br><span class="line">        <span class="comment">//        calendar.set(Calendar.DAY_OF_MONTH,9);</span></span><br><span class="line"></span><br><span class="line">        calendar.set(Calendar.DAY_OF_YEAR,<span class="number">100</span>);</span><br><span class="line">        calendar.set(Calendar.DAY_OF_YEAR,calendar.get(Calendar.DAY_OF_YEAR)-<span class="number">63</span>);</span><br><span class="line">        date = calendar.getTime();</span><br><span class="line">        System.out.println(simpleDateFormat.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><p>File 类</p><p>java.io.File，使用该类的构造函数就可以创建文件对象，将<code>硬盘</code>中的一个具体的<code>文件</code>以 Java 对象的形式来表示。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public File(String pathname)</td><td>根据路径创建对象</td></tr><tr><td>public String getName()</td><td>获取文件名</td></tr><tr><td>public String getParent()</td><td>获取文件所在的目录</td></tr><tr><td>public File getParentFile()</td><td>获取文件所在目录对应的File对象</td></tr><tr><td>public String getPath()</td><td>获取文件路径</td></tr><tr><td>public boolean exists()</td><td>判断文件是否存在</td></tr><tr><td>public boolean isDirectory()</td><td>判断对象是否为目录</td></tr><tr><td>public boolean isFile()</td><td>判断对象是否为文件</td></tr><tr><td>public long length()</td><td>获取文件的大小</td></tr><tr><td>public boolean createNewFile()</td><td>根据当前对象创建新文件</td></tr><tr><td>public boolean delete()</td><td>删除对象</td></tr><tr><td>public boolean mkdir()</td><td>根据当前对象创建目录</td></tr><tr><td>public boolean renameTo(File file)</td><td>为已存在的对象重命名</td></tr></tbody></table><p>IO</p><p>Input 输入流（将外部文件读入到 Java 程序中）</p><p>Output 输出流（将 Java 程序中的数据输出到外部）</p><p><img src="https://img-blog.csdnimg.cn/20210219174951576.png" alt="在这里插入图片描述"></p><p>Java 中的流有很多种不同的分类。</p><ul><li>按照方向分，<code>输入流</code>和<code>输出流</code></li><li>按照单位分，可以分为<code>字节流</code>和<code>字符流</code>（字节流是指每次处理数据以字节为单位，字符流是指每次处理数据以字符为单位）</li><li>按照功能分，可以分为<code>节点流</code>和<code>处理流</code>。</li></ul><p>方法定义时的异常如果直接继承自 Exception，实际调用的时候需要手动处理（捕获异常/丢给虚拟机去处理）</p><p>方法定义时的异常如果继承自 RuntimeException，调用的时候不需要处理。</p><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><ul><li>按照方向分，可以分为输入流和输出流。</li><li>按照单位分，可以分为字节流和字符流。</li><li>按照功能分，可以分为节点流和处理流。</li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>按照方向可以分为输入字节流和输出字节流。</p><p>InputStream、OutputStream</p><p>1 byte = 8 位二进制数 01010101</p><p>InputStream常用方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>int read()</td><td>以字节为单位读取数据</td></tr><tr><td>int read(byte b[])</td><td>将数据存入 byte 类型的数组中，返回数组中有效数据的长度</td></tr><tr><td>int read(byte b[],int off,int len)</td><td>将数据存入 byte 数组的指定区间内，返回数组长度</td></tr><tr><td>byte[] readAllBytes()</td><td>将所有数据存入 byte 数组并返回</td></tr><tr><td>int available()</td><td>返回当前数据流未读取的数据个数</td></tr><tr><td>void close()</td><td>关闭数据流</td></tr></tbody></table><p>OutputStream</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void write(int b)</td><td>以字节为单位输出数据</td></tr><tr><td>void write(byte b[])</td><td>将byte数组中的数据输出</td></tr><tr><td>void write(byte b[],int off,int len)</td><td>将byte数组中指定区间的数据输出</td></tr><tr><td>void close()</td><td>关闭数据流</td></tr><tr><td>void flush()</td><td>将缓冲流中的数据同步到输出流中</td></tr></tbody></table><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>字节流是单位时间内处理一个字节的数据（输入+输出）</p><p>字符流是单位时间内处理一个字符的数据（输入+输出）</p><p>字符流：</p><ul><li>输入字符流 Reader</li><li>输出字符流 Writer</li></ul><h3 id="5、Reader"><a href="#5、Reader" class="headerlink" title="5、Reader"></a>5、Reader</h3><p><img src="https://img-blog.csdnimg.cn/20210219175016583.png" alt="在这里插入图片描述"></p><p>是一个抽象类</p><p>Readable 接口的作用？</p><p>可以将数据以字符的形式读入到<code>缓冲区</code></p><p><img src="https://img-blog.csdnimg.cn/20210219175035490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>方向：输入+输出</li><li>单位：字节+字符</li><li>功能：节点流（字节流） + 处理流（对节点流进行处理，生成其他类型的流）</li></ul><p>InputStream(字节输入流) —&gt; Reader（字符输入流）</p><p>InputStreamReader 的功能是将<code>字节输入流</code>转换为<code>字符输入流</code><br><img src="https://img-blog.csdnimg.cn/20210219175049295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>英文、数字、符号</p></blockquote><p>1 个字节 = 1 个字符</p><p>如：a 1 个字符、1 个字节</p><blockquote><p>汉字</p></blockquote><p>1 个字符 = 3 个字节</p><p>如：好 1个字符、3 个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//字符流</span></span><br><span class="line">        Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;/Users/southwind/Desktop/test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;*******字符流读取********&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((temp = reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字节流</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/southwind/Desktop/test.txt&quot;</span>);</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;*******字节流读取********&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((temp = inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;/Users/southwind/Desktop/test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> length = reader.read(chars);</span><br><span class="line">        System.out.println(<span class="string">&quot;数据流的长度是&quot;</span>+length);</span><br><span class="line">        System.out.println(<span class="string">&quot;遍历数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">            System.out.println(aChar);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read() 返回的是 int ，直接将字符转成字节（1-1，1-3）</p><p>read(char[] chars) 返回的是char数组，直接就返回字符，不会转成字节的。</p><h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><p><img src="https://img-blog.csdnimg.cn/20210219175113437.png" alt="在这里插入图片描述"></p><p>Appendable 接口可以将 char 类型的数据读入到<code>数据缓冲区</code><br><img src="https://img-blog.csdnimg.cn/2021021917512837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>OutputStreamWriter 处理流</p><p>OutputStreamWriter 的功能是将<code>输出字节流</code>转成<code>输出字符流</code>，与 InputStreamReader 相对应的，将<code>输入字节流</code>转成<code>输入字符流</code><br><img src="https://img-blog.csdnimg.cn/20210219175142657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;/Users/southwind/Desktop/copy.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//writer.write(&quot;你好&quot;);</span></span><br><span class="line"><span class="comment">//        char[] chars = &#123;&#x27;你&#x27;,&#x27;好&#x27;,&#x27;世&#x27;,&#x27;界&#x27;&#125;;</span></span><br><span class="line"><span class="comment">//        writer.write(chars,2,2);</span></span><br><span class="line">        String str = <span class="string">&quot;Hello World,你好世界&quot;</span>;</span><br><span class="line">        writer.write(str,<span class="number">10</span>,<span class="number">6</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h3><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//基础管道</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/southwind/Desktop/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//处理流</span></span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> length = inputStreamReader.read(chars);</span><br><span class="line">        inputStreamReader.close();</span><br><span class="line">        String result = <span class="keyword">new</span> String(chars,<span class="number">0</span>,length);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;你好 世界&quot;</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/southwind/Desktop/copy.txt&quot;</span>);</span><br><span class="line">        OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(outputStream);</span><br><span class="line">        writer.write(str,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>无论是<code>字节流</code>还是<code>字符流</code>，使用的时候都会频繁访问硬盘，对硬盘是一种损伤，同时效率不高，如何解决？</p><p>可以使用<strong>缓冲流</strong>，缓冲流自带缓冲区，可以一次性从硬盘中读取部分数据存入缓冲区，再写入内存，这样就可以有效减少对硬盘的直接访问。</p><p>缓冲流属于<code>处理流</code>，如何来区分<strong>节点流</strong>和<strong>处理流</strong>？</p><p>1、节点流使用的时候可以直接对接到文件对象File</p><p>2、处理流使用的时候不可以直接对接到文件对象 File，必须要建立在<code>字节流</code>的基础上才能创建。</p><p><img src="https://img-blog.csdnimg.cn/20210219175157580.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WcNAcUew-1613726775807)(Java SE总结详细.assets/image-20210219161151429.png)]"></p><p>缓冲流又可以分为字节缓冲流和字符缓冲流，按照方向再细分，又可以分为字节输入缓冲流和字节输出缓冲流，以及字符输入缓冲流和字符输出缓冲流。</p><p><img src="https://img-blog.csdnimg.cn/20210219175212804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>字节输入缓冲流</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建节点流</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/southwind/Desktop/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2、创建缓冲流</span></span><br><span class="line">        BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">        <span class="comment">//        int temp = 0;</span></span><br><span class="line">        <span class="comment">//        while ((temp = bufferedInputStream.read())!=-1)&#123;</span></span><br><span class="line">        <span class="comment">//            System.out.println(temp);</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> length = bufferedInputStream.read(bytes,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> aByte : bytes) &#123;</span><br><span class="line">            System.out.println(aByte);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字符输入缓冲流</p></blockquote><p>readLine 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建字符流（节点流）</span></span><br><span class="line">        Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;/Users/southwind/Desktop/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2、创建缓冲流（处理流）</span></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;***start***&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((str = bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;***end***,共读取了&quot;</span>+num+<span class="string">&quot;次&quot;</span>);</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字节输出缓冲流</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/southwind/Desktop/test2.txt&quot;</span>);</span><br><span class="line">        BufferedOutputStream bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(outputStream);</span><br><span class="line">        String str = <span class="string">&quot;由于在开发Oak语言时，尚且不存在运行字节码的硬件平台，所以为了在开发时可以对这种语言进行实验研究，他们就在已有的硬件和软件平台基础上，按照自己所指定的规范，用软件建设了一个运行平台，整个系统除了比C++更加简单之外，没有什么大的区别。&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line"><span class="comment">//        for (byte aByte : bytes) &#123;</span></span><br><span class="line"><span class="comment">//            bufferedOutputStream.write(aByte);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        bufferedOutputStream.write(bytes,<span class="number">9</span>,<span class="number">9</span>);</span><br><span class="line">        bufferedOutputStream.flush();</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字符输出缓冲流</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;/Users/southwind/Desktop/test2.txt&quot;</span>);</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(writer);</span><br><span class="line"><span class="comment">//        String str = &quot;由于在开发语言时尚且不存在运行字节码的硬件平台，所以为了在开发时可以对这种语言进行实验研究，他们就在已有的硬件和软件平台基础上，按照自己所指定的规范，用软件建设了一个运行平台，整个系统除了比C++更加简单之外，没有什么大的区别。&quot;;</span></span><br><span class="line"><span class="comment">//        bufferedWriter.write(str,5,10);</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//        bufferedWriter.write(chars,2,1);</span></span><br><span class="line">        bufferedWriter.write(<span class="number">22902</span>);</span><br><span class="line">        bufferedWriter.flush();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入流没有 flush 方法，但不代表它没有缓冲流，输出流是有 flush 方法的，实际开发中在关闭输出缓冲流之前，需要调用 flush 方法。</p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p>序列化就是将内存中的对象输出到硬盘文件中保存。</p><p>反序列化就是相反的操作，从文件中读取数据并还原成内存中的对象。</p><blockquote><p>序列化</p></blockquote><p>1、实体类需要实现序列化接口，Serializable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、实体类对象进行序列化处理，通过数据流写入到文件中，ObjectOutputStream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.southwind.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/southwind/Desktop/obj.txt&quot;</span>);</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">        objectOutputStream.writeObject(user);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>反序列化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/southwind/Desktop/obj.txt&quot;</span>);</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(inputStream);</span><br><span class="line">        User user = (User) objectInputStream.readObject();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        objectInputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IO-流的应用"><a href="#IO-流的应用" class="headerlink" title="IO 流的应用"></a>IO 流的应用</h3><p>IO 流就是完成文件传输（上传文件：发朋友圈、换头像，文件下载：CSDN 下载源代码、文档）</p><p>字符 a 你好</p><p>文本类型的数据（txt、word、Excel、MD）可以使用字符去读取（当然也可以用字节）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;/Users/southwind/Desktop/test.txt&quot;</span>);</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line"></span><br><span class="line">        Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;/Users/southwind/myjava/test.txt&quot;</span>);</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(writer);</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((str = bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            bufferedWriter.write(str);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;传输完毕，共读取了&quot;</span>+num+<span class="string">&quot;次&quot;</span>);</span><br><span class="line">        bufferedWriter.flush();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        writer.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        reader.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非文本类型的数据（图片、音频、视频）不能用字符去读取，只能用字节去读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1、通过输入流将文件读入到 Java</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/southwind/Desktop/1.png&quot;</span>);</span><br><span class="line">        <span class="comment">//2、通过输出流将文件从 Java 中写入到 myjava</span></span><br><span class="line">        OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/southwind/myjava/1.png&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span>((temp = inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            outputStream.write(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;传输完毕，共耗时&quot;</span>+(end-start));</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>地位：Java 中最核心的模块，Java 之所以称为动态语言的关键，大部分的类库、企业级框架底层都是通过反射来实现的，非常重要。</p><p>反射顾名思义就反转执行，生活中的反射就是通过虚像映射到具体的实物，可以获取到实物的某些形态特征。</p><p>程序中的反射，通过一个实例化对象映射到类。</p><p>一句话理解反射：常规情况下是通过类来创建对象的，反射就是将这一过程进行反转，通过对象来获取类的信息。</p><p><strong>通过对象来获取类的信息</strong></p><p>类的信息我们也同样使用对象来描述，Class 类专门用来描述其他类的类，每一个 Class 的实例化对象都是对某个类的描述。</p><p>Class 是反射的源头</p><p>如何来创建 Class 的对象？</p><p>1、调用 Class 的静态方法 forName(String name)，将目标类的全限定类名（全类名，带着包名的类名）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.southwind.demo2.User&quot;</span>);</span><br><span class="line">        System.out.println(clazz.getName());</span><br><span class="line">        System.out.println(clazz.getTypeName());</span><br><span class="line">        System.out.println(clazz.getSuperclass().getName());</span><br><span class="line">        Class[] array = clazz.getInterfaces();</span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Class aClass : array) &#123;</span><br><span class="line">            System.out.println(aClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210219175256643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjE5MDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2、通过目标类的 class 创建，Java 中的每一个类都可以调用类.class，class 不是属性也不是方法，叫做“类字面量”，作用是获取内存中目标类型对象的引用（类的结构）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz2 = User.class;</span><br><span class="line">System.out.println(clazz2.getName());</span><br></pre></td></tr></table></figure><p>3、通过目标类的实例化对象获取，getClass()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz3 = user.getClass();</span><br><span class="line">System.out.println(clazz3.getName());</span><br></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ol><li>成员内部类。</li><li>局部内部类。</li><li>匿名内部类</li><li>静态内部类</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[https://www.cnblogs.com/dolphin0520/p/3811445.html]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
