<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Netty 编解码器 | ahao</title><meta name="author" content="ahao"><meta name="copyright" content="ahao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Netty 编码和解码前言本节内容，主要是讲解 Netty 的编码和解码，前面我们讲解了 ByteBuf，Netty 是面向 ByteBuf 来编程的，发送的内容会被编码成 ByteBuf，从 Channel 接受的数据流则被封装成了 ByteBuf，需要把它解码成我们所熟悉的格式。 编码和解码的作用首先，我们先通过一个实例来进行说明。 实例： 12345678ch.pipeline().addL">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 编解码器">
<meta property="og:url" content="https://ahao.ink/posts/Netty%20%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/index.html">
<meta property="og:site_name" content="ahao">
<meta property="og:description" content="Netty 编码和解码前言本节内容，主要是讲解 Netty 的编码和解码，前面我们讲解了 ByteBuf，Netty 是面向 ByteBuf 来编程的，发送的内容会被编码成 ByteBuf，从 Channel 接受的数据流则被封装成了 ByteBuf，需要把它解码成我们所熟悉的格式。 编码和解码的作用首先，我们先通过一个实例来进行说明。 实例： 12345678ch.pipeline().addL">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/o3IOD9fHKYPRGvm.png">
<meta property="article:published_time" content="2021-09-30T05:36:41.000Z">
<meta property="article:modified_time" content="2021-12-24T09:45:06.008Z">
<meta property="article:author" content="ahao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2021/12/24/o3IOD9fHKYPRGvm.png"><link rel="shortcut icon" href="https://i.loli.net/2021/11/12/NAU53jI9mGOJlDC.png"><link rel="canonical" href="https://ahao.ink/posts/Netty%20%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-24 17:45:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/11/12/Edhsr56wxfUbuFg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2021/12/24/o3IOD9fHKYPRGvm.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ahao</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Netty 编解码器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-30T05:36:41.000Z" title="发表于 2021-09-30 13:36:41">2021-09-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-24T09:45:06.008Z" title="更新于 2021-12-24 17:45:06">2021-12-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Netty/">Netty</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Netty 编解码器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Netty-编码和解码"><a href="#Netty-编码和解码" class="headerlink" title="Netty 编码和解码"></a>Netty 编码和解码</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节内容，主要是讲解 Netty 的编码和解码，前面我们讲解了 ByteBuf，Netty 是面向 ByteBuf 来编程的，发送的内容会被编码成 ByteBuf，从 Channel 接受的数据流则被封装成了 ByteBuf，需要把它解码成我们所熟悉的格式。</p>
<h2 id="编码和解码的作用"><a href="#编码和解码的作用" class="headerlink" title="编码和解码的作用"></a>编码和解码的作用</h2><p>首先，我们先通过一个实例来进行说明。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> CodecHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodecHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接受：&quot;</span>+msg.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端发送数据：<br><img src="http://img.mukewang.com/wiki/5f377c1a0929f60112000325.jpg" alt="图片描述"></p>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接受：PooledUnsafeDirectByteBuf(ridx: <span class="number">0</span>, widx: <span class="number">5</span>, cap: <span class="number">1024</span>)</span><br></pre></td></tr></table></figure>

<p>通过以上测试，发现客户端往服务端发送普通的字符串，服务端接受的时候并不是正常字符串，而是把 ByteBuf 类型打印出来。</p>
<p>主要原因是，Netty 的数据类型是 ByteBuf，无法直接强转，需要通过解码的方式去转换才能得到正常的数据，编码也是同样道理。</p>
<p>因此，本节学编码和解码的知识可以了解 Netty 如何去接受和发送参数。</p>
<h2 id="解码示例"><a href="#解码示例" class="headerlink" title="解码示例"></a>解码示例</h2><p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLoginHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.读取客户端发送过来的数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.转换ByteBuf</span></span><br><span class="line">        ByteBuf buffer=(ByteBuf)msg;</span><br><span class="line">        <span class="comment">//2.定义一个byte数组，长度是ByteBuf的可读字节数</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[buffer.readableBytes()];</span><br><span class="line">        <span class="comment">//3.往自定义的byte[]读取数据</span></span><br><span class="line">        buffer.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.字节流-&gt;字符串</span></span><br><span class="line">       	String str=<span class="keyword">new</span> String(bytes);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上代码，我们发现能正常接收并且打印客户端发送过来的字符串数据。但是如果是其它的类型数据（比如：Map，实体，List 等）那么还得手工写另外的转换方法，相对比较麻烦。</p>
<h2 id="编码解码流程"><a href="#编码解码流程" class="headerlink" title="编码解码流程"></a>编码解码流程</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>无论是使用 Netty 还是原始的 Socket 编程，基于 TCP 通信的数据包格式均为二进制，但是我们平时开发不可能基于二进制去开发，而是封装一个一个的实体。这样的话，我们就需要实现实体和二进制之间的编码和解码了。</p>
<ol>
<li>客户端往服务端发送消息，手写需要把实体转换成 byte []，并且把 byte [] 写入到 ByteBuf 容器里面，最终转换二进制。其实，整个过程就是一个编码的过程；</li>
<li>服务端接受到消息，二进制是给机器去识别的，人眼无法快速去识别它，然而实体是我们所熟悉并且一看就能看出有哪些属性，因此需要把二进制转换我们所熟悉的实体，整个过程就是一个解码的过程。</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/24/lvOYjcKByhIe5oP.png" alt="图片描述"></p>
<h3 id="编码流程"><a href="#编码流程" class="headerlink" title="编码流程"></a>编码流程</h3><p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装编码方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">encode</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 ByteBuf 对象</span></span><br><span class="line">    ByteBuf byteBuf = ByteBufAllocator.DEFAULT.ioBuffer();</span><br><span class="line">    <span class="comment">// 2. 序列化 Java 对象</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = SerializeUtils.serialize(obj);</span><br><span class="line">    <span class="comment">// 3. 实际编码过程</span></span><br><span class="line">    byteBuf.writeBytes(bytes);</span><br><span class="line">    <span class="keyword">return</span> byteBuf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeUtils</span></span>&#123;</span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialize(Object obj)&#123;</span><br><span class="line">        <span class="comment">//省略序列化过程</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码说明：</strong></p>
<ol>
<li>创建一个 ByteBuf（前面章节详细讲解过）；</li>
<li>把内容序列化成字节数组；</li>
<li>把字节数组写入到 ByteBuf。</li>
</ol>
<h3 id="解码流程"><a href="#解码流程" class="headerlink" title="解码流程"></a>解码流程</h3><p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">decode</span><span class="params">(ByteBuf byteBuf,Class clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据包长度</span></span><br><span class="line">    <span class="keyword">int</span> length = byteBuf.readableBytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    byteBuf.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SerializeUtils.desrialize(bytes,clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeUtils</span></span>&#123;</span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">desrialize</span><span class="params">(<span class="keyword">byte</span>[] bytes,Class clazz)</span></span>&#123;</span><br><span class="line">        <span class="comment">//省略反序列化过程</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码说明：</strong></p>
<ol>
<li>根据 ByteBuf 获取可读的数据长度；</li>
<li>根据数据长度创建相应的字节数组；</li>
<li>把 ByteBuf 里面的内容读取到自定义的字节数组里面；</li>
<li>通过反序列化的手段，把字节数组反序列化成对象。</li>
</ol>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>上面讲编码和解码的时候，涉及两个空方法没有实现，分别是 <code>serialize()</code> 序列化和 <code>desrialize()</code> 反序列化，其实序列化和反序列化技术选择很多，常见的解决方案大概如下：</p>
<ol>
<li>通过对象流来手工实现序列化，但是实体必须实现 <code>Serializeable</code> 序列化接口，否则无法被正常序列化和反序列化；</li>
<li>对象 -&gt; 转换 json 格式的字符串，Java 里面 String 类型字符串可以自动转换字节数组，常见的开源框架分别有 Fastjson、Jackjson 等；</li>
<li>对象 - 转存 xml 格式的字符串，常见框架有 XStream 等；</li>
<li>其他技术，如：Hessian 序列化、Kryo 序列化等。</li>
</ol>
<p>这里就不详细展开展示序列化和反序列化的说明，如果有兴趣，可以参考我写的另外一篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.imooc.com/article/303099">https://www.imooc.com/article/303099</a></p>
<p>接下来，主要说明的是，为了灵活扩展，我们最好不要写死某种序列化技术，为了方便后期更改技术框架，因为每种序列化技术的差距比较大，主要体现两点：</p>
<ol>
<li><strong>消耗时间：</strong> 序列化和反序列化的消耗时间长度；</li>
<li><strong>数据长度：</strong> 序列化过后的字节数组长度，这个是会影响网络传输性能的。</li>
</ol>
<p>一般情况下，通过面向接口 + 策略模式的方式去解耦，底层可以灵活的切换序列化技术。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerializeService</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(T t);</span><br><span class="line">    <span class="comment">//反序列化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes,Class&lt;T&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体序列化实现列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonSerializeService</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">SerializeService</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(T t)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反序列化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//序列化使用</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SerializeService serializeService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">encode</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 ByteBuf 对象</span></span><br><span class="line">        ByteBuf byteBuf = ByteBufAllocator.DEFAULT.ioBuffer();</span><br><span class="line">        <span class="comment">// 2. 序列化 Java 对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializeService.serialize(obj);</span><br><span class="line">        <span class="comment">// 3. 实际编码过程</span></span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line">        <span class="keyword">return</span> byteBuf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节内容大家掌握好以下内容：</p>
<ol>
<li>编码和解码的概念是什么？为什么需要编码和解码？</li>
<li>Netty 如何去进行编码和解码，以及大体流程是什么？</li>
<li>编码和解码需要依赖序列化和反序列化技术，要了解序列化方面的技术有哪些。</li>
</ol>
<blockquote>
<p>思考题：能否把我们的编码和解码封装成独立的 Handler 呢？那么应该如何去封装呢？</p>
</blockquote>
<h1 id="如何自定义编解码器"><a href="#如何自定义编解码器" class="headerlink" title="如何自定义编解码器"></a>如何自定义编解码器</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>上一节我们一节了解了什么是编码解码、序列化和反序列化了，并且留有一道思考题，本节内容主要是深入解析该思考题。</p>
<blockquote>
<p>思考题：能否把我们的编码和解码封装成独立的 Handler 呢？那么应该如何去封装呢？</p>
</blockquote>
<h2 id="为什么要封装独立-Handler？"><a href="#为什么要封装独立-Handler？" class="headerlink" title="为什么要封装独立 Handler？"></a>为什么要封装独立 Handler？</h2><p>即使我们把编码和解码封装成了方法，但是还是需要在 Handler 业务逻辑里面进行手工调用，虽然看似不怎么影响，但是业务 Handler 不够纯粹，应该让 Handler 只是专心的负责处理业务逻辑就好。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyEncoderHandler());<span class="comment">//解码Handler</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyDecoderHandler());<span class="comment">//编码Handler</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyBusiHandler());<span class="comment">//业务Handler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBusiHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.接受参数，可以直接强转</span></span><br><span class="line">        UserReq userReq=(UserReq)msg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.相应数据，直接写对象</span></span><br><span class="line">        UserRes res=<span class="keyword">new</span> UserRes();</span><br><span class="line">        res.setCode(<span class="number">0</span>);</span><br><span class="line">        res.setMsg(<span class="string">&quot;接受成功&quot;</span>);</span><br><span class="line">        ctx.writeAndFlush(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的代码，我们把编码和解码封装成两个独立的 Handler，并且加入到 ChannelPipeline 里面进行管理。在我们的业务 Handler 里面就可以直接操作实体数据，无需手工转换成字节数组了。</p>
<blockquote>
<p>思考：那么如何进行封装 Handler 呢？</p>
</blockquote>
<h2 id="StringDecoder-和-StringEncoder"><a href="#StringDecoder-和-StringEncoder" class="headerlink" title="StringDecoder 和 StringEncoder"></a>StringDecoder 和 StringEncoder</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>StringDecoder 和 StringEncoder 是 Netty 为我们提供的专门针对普通字符串的解码和编码器，使用起来非常的简单。</p>
<p>客户端直接发送字符串。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ClientTestHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//客户端直接写字符串，没有任何的数据加工</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码块<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>服务端直接强转字符串。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ServerTestHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//直接把msg转换成String类型</span></span><br><span class="line">        String str=msg.toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;str=&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码块<span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>总结，这种模式开发起来实在太方便了，无需做数据的加工，我们还是按照我们熟悉的方式去写代码，非常的方便。</p>
<p>但是，它只是支持普通的字符串类型进行编码和解码而已，对于复杂的引用类型则无效。</p>
<h3 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h3><p>其实原理是非常的简单的，请看下图。</p>
<p><img src="https://s2.loli.net/2021/12/24/NZbspkQWJAvSqKE.png" alt="图片描述"><br><strong>执行流程说明：</strong></p>
<ol>
<li>StringDecoder 必须放在业务 Handler 之前，因为都是 InboundHandler，需要按顺序执行；</li>
<li>StringEncoder 放在业务 Handler 之前，则可以使用 ctx.writeAndFlush () 输出数据，也可以使用 ctx.channel ().writeAndFlus () 输出数据（ChannelHandler 已经讲过原理了）；</li>
<li>StringEncoder 放在业务 Handler 之后，则只能使用 <code>ctx.channel().writeAndFlush()</code> 输出数据。</li>
</ol>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><blockquote>
<p>思考：StringDecoder 和 StringEncoder 到底怎么实现的呢？</p>
</blockquote>
<p>StringDecoder 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//直接msg.toString()</span></span><br><span class="line">        out.add(msg.toString(<span class="keyword">this</span>.charset));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现 StringDecoder 的源码非常的简单，直接<code>.toString()</code> 转换即可。</p>
<p>StringEncoder 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">CharSequence</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, CharSequence msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//继续跟进源码</span></span><br><span class="line">            out.add(ByteBufUtil.encodeString(ctx.alloc(), CharBuffer.wrap(msg), <span class="keyword">this</span>.charset));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">encodeString</span><span class="params">(ByteBufAllocator alloc, CharBuffer src, Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续跟进源码</span></span><br><span class="line">    <span class="keyword">return</span> encodeString0(alloc, <span class="keyword">false</span>, src, charset, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保留核心源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteBuf <span class="title">encodeString0</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">boolean</span> enforceHeap, CharBuffer src, Charset charset, <span class="keyword">int</span> extraCapacity)</span> </span>&#123;</span><br><span class="line">    CharsetEncoder encoder = CharsetUtil.encoder(charset);</span><br><span class="line">    <span class="keyword">int</span> length = (<span class="keyword">int</span>)((<span class="keyword">double</span>)src.remaining() * (<span class="keyword">double</span>)encoder.maxBytesPerChar()) + extraCapacity;</span><br><span class="line">    <span class="keyword">boolean</span> release = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建ByteBuf分配器</span></span><br><span class="line">    ByteBuf dst;</span><br><span class="line">    <span class="keyword">if</span> (enforceHeap) &#123;</span><br><span class="line">        dst = alloc.heapBuffer(length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dst = alloc.buffer(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBuf var12;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.得到NIO的ByteBuffer【跟进Netty的ByteBuf基本上一样】</span></span><br><span class="line">        ByteBuffer dstBuf = dst.internalNioBuffer(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> pos = dstBuf.position();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.把内容写得NIO的ByteBuffer</span></span><br><span class="line">        CoderResult cr = encoder.encode(src, dstBuf, <span class="keyword">true</span>);</span><br><span class="line">        cr = encoder.flush(dstBuf);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//4.更新ByteBuf的写指针writeIndex</span></span><br><span class="line">        dst.writerIndex(dst.writerIndex() + dstBuf.position() - pos);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.给var12赋值</span></span><br><span class="line">        var12 = dst;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CharacterCodingException var16) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var16);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致流程就是把字符串内容转换成 NIO 的 ByteBuffer，这里大致知道整个流程即可，不用深究每行代码的意思，其实 Netty 的 ByteBuf 底层就是基于 ByteBuffer 进行封装的。</p>
<h2 id="自定义编解码器"><a href="#自定义编解码器" class="headerlink" title="自定义编解码器"></a>自定义编解码器</h2><p>通过上面 Demo 的学习，以及 StringDecoder 和 StringEncoder 两个类的学习，相信大家更加能理解编解码器了，毕竟 StringDecoder 和 StringEncoder 从字面意思也能理解它们是针对字符串格式的，如果我们想要传递一个实体那么怎么办呢？</p>
<p>主要解决方案有两种：</p>
<p><strong>方案一：</strong> 把实体转换成 json 格式字符串，然后依然使用 StringDecoder 和 StringEncoder 编解码器，但是每次手工转换和解析，非常的麻烦；<br><strong>方案二：</strong> 自定义针对实体的编解码器，并且加入到双向链表里面，这样就可以传递自定义实体了。</p>
<p>下面主要讲解如何实现针对实体的编解码器：</p>
<h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p><strong>核心步骤：</strong></p>
<ol>
<li>继承 MessageToByteEncoder，重写 encode 方法；</li>
<li>把 User 对象转换成 byte []；</li>
<li>把 byte [] 写到 ByteBuf。</li>
</ol>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                          User user, </span></span></span><br><span class="line"><span class="function"><span class="params">                          ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.对象流</span></span><br><span class="line">        ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes=os.toByteArray();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//2.关闭流</span></span><br><span class="line">        oos.close();</span><br><span class="line">        os.close();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//3.写到ByteBuf容器</span></span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p><strong>核心步骤：</strong></p>
<ol>
<li>继承 ByteToMessageDecoder，重写 decode 方法；</li>
<li>自定义一个 byte [] 数组，长度是 ByteBuf 的可读长度；</li>
<li>把 ByteBuf 转换成 User 实体。</li>
</ol>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                          ByteBuf byteBuf, </span></span></span><br><span class="line"><span class="function"><span class="params">                          List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.定义byte[]，长度为ByteBuf可读长度</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">        <span class="comment">//2.往byte[]读取数据</span></span><br><span class="line">        byteBuf.readBytes(bytes);</span><br><span class="line">		<span class="comment">//3.对象流</span></span><br><span class="line">        ByteArrayInputStream is=<span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream iss=<span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">        User user=(User)iss.readObject();</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        is.close();</span><br><span class="line">        iss.close();</span><br><span class="line">		<span class="comment">//5.添加到集合</span></span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="添加到-Pipeline"><a href="#添加到-Pipeline" class="headerlink" title="添加到 Pipeline"></a>添加到 Pipeline</h3><p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.解码器</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> MyDecoder());</span><br><span class="line">        <span class="comment">//2.编码器</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> MyEncoder());</span><br><span class="line">        <span class="comment">//3.业务Handler</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> ServerTestHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>通常情况下，需要把编解码器分别独立封装成 Handler，并且加入到 ChannelPipeline 进行管理，主要目的是简化繁琐的编码和解码的步骤，让业务 Handler 更加专注去处理业务逻辑，更加的符合开发人员的习惯。</p>
<p>本节主要掌握以下两点内容</p>
<ol>
<li>如果针对字符串，那么可以使用 Netty 内置的编解码器，分别是 StringEncoder 和 StringDecoder；</li>
<li>如果是其它引用类型，主要有两种方式，①转换成字符串格式；②自定义编解码器。</li>
</ol>
<h1 id="Netty-内置编解码器"><a href="#Netty-内置编解码器" class="headerlink" title="Netty 内置编解码器"></a>Netty 内置编解码器</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>上节我们讲解了 Netty 的内置编码器以及自定义编码器，本节主要讲解 Netty 提供的几个核心编解码器的抽象类，主要是 <code>MessageToByteEncoder</code>、<code>ByteToMessageDecoder</code>、<code>SimpleChannelInboundHandler</code>。</p>
<h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><p>Netty 官方也是考虑到了如何减轻开发人员的繁琐、重复性的工作，因此，它内置了一些好用的编解码器抽象，让我们更加便捷的自定义自己想要的编解码器。</p>
<p>通过本节学习，我们需要掌握以下几点</p>
<ol>
<li>有哪些编解码器的抽象；</li>
<li>它们的核心原理是什么。</li>
</ol>
<h2 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h2><p><img src="https://s2.loli.net/2021/12/24/8G2Ve4fpBmjlDXn.png" alt="图片描述"></p>
<h2 id="MessageToByteEncoder"><a href="#MessageToByteEncoder" class="headerlink" title="MessageToByteEncoder"></a>MessageToByteEncoder</h2><p>从字面意思上可知，它主要是把消息内容转换成 Byte，也就是说是编码。使用非常的简单，继承 <code>MessageToByteEncoder</code> 可以很容易的开发一个 Handler。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">BaseBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                          BaseBean baseBean, </span></span></span><br><span class="line"><span class="function"><span class="params">                          ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.把“数据”转换成字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes= JSON.toJSONBytes(baseBean);</span><br><span class="line">		<span class="comment">//2.把字节数组往ByteBuf容器写</span></span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyEncoder());</span><br></pre></td></tr></table></figure>

<p>源码：保留核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">I</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类型匹配器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeParameterMatcher matcher;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MessageToByteEncoder</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">this</span>.matcher = TypeParameterMatcher.find(<span class="keyword">this</span>, MessageToByteEncoder.class, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.preferDirect = preferDirect;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.acceptOutboundMessage(msg)) &#123;</span><br><span class="line">            <span class="comment">//类型判断通过，则处理</span></span><br><span class="line">            </span><br><span class="line">            I cast = msg;</span><br><span class="line">            <span class="comment">//创建ByteBuf</span></span><br><span class="line">            buf = <span class="keyword">this</span>.allocateBuffer(ctx, msg, <span class="keyword">this</span>.preferDirect);</span><br><span class="line">			<span class="comment">//调用抽象方法（由子类实现）</span></span><br><span class="line">            <span class="keyword">this</span>.encode(ctx, cast, buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//类型判断不通过，则往下流转</span></span><br><span class="line">            ctx.write(msg, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext var1, I var2, ByteBuf var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ByteToMessageDecoder"><a href="#ByteToMessageDecoder" class="headerlink" title="ByteToMessageDecoder"></a>ByteToMessageDecoder</h2><p>从字面上我们也很容易猜到它的作用，主要是把 Byte 类型的数据转换成对应实体，也称之为解码。使用非常的简单。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把ByteBuf反序列化，并且添加到List里面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List out)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//1.定义byte[]，长度为ByteBuf可读长度</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">        <span class="comment">//2.往byte[]读取数据</span></span><br><span class="line">        byteBuf.readBytes(bytes);</span><br><span class="line">		<span class="comment">//3.对象流</span></span><br><span class="line">        ByteArrayInputStream is=<span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream iss=<span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">        User user=(User)iss.readObject();</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        is.close();</span><br><span class="line">        iss.close();</span><br><span class="line">		<span class="comment">//5.添加到集合</span></span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承了 <code>ByteToMessageDecoder</code> 这个类之后，我们只需要实现一下 decode () 方法，这里的 in 大家可以看到，传递进来的时候就已经是 ByteBuf 类型，所以我们不再需要强转，第三个参数是 List 类型，我们通过往这个 List 里面添加解码后的结果对象，就可以自动实现结果往下一个 handler 进行传递，我们就实现了解码的逻辑 handler。</p>
<h2 id="SimpleChannelInboundHandler"><a href="#SimpleChannelInboundHandler" class="headerlink" title="SimpleChannelInboundHandler"></a>SimpleChannelInboundHandler</h2><p>前面讲解 ChannelHandler 多业务情况下的时候，我们讲解到了 <code>SimpleChannelInboundHandler</code>，它的核心作用是自动判断数据格式类型，并且转发给对应的 Handler 来处理。</p>
<p>一般来说，Netty 开发的应用如果很复杂的时候，那么应该如何处理呢？通常有三种方案。</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>对反序列化后的结果进行类型判断，不同的类型做不同的业务处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//对反序列化后的结果进行类型判断，不同的类型做不同的业务处理</span></span><br><span class="line">    <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> LoginReqBean)&#123;</span><br><span class="line">        login((LoginReqBean) msg,ctx.channel());</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> MsgReqBean)&#123;</span><br><span class="line">        sendMsg((MsgReqBean)msg,ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式比较简单，但是通过 <code>if else</code> 逻辑进行逻辑的处理，当我们要处理的指令越来越多的时候，代码会显得越来越臃肿。</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>判断是否是自己应该处理，如果不是，则手工往下流转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> LoginReqBean)&#123;</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//往下流转</span></span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>使用 <code>SimpleChannelInboundHandler</code> 来简化我们的指令处理逻辑。</p>
<p><code>SimpleChannelInboundHandler</code> 使用非常简单，我们在继承这个类的时候，给他传递一个泛型参数，然后在 channelRead0 () 方法里面，我们不用再通过 if 逻辑来判断当前对象是否是本 handler 可以处理的对象，也不用强转，不用往下传递本 handler 处理不了的对象，这一切都已经交给父类 <code>SimpleChannelInboundHandler</code> 来实现了，我们只需要专注于我们要处理的业务逻辑即可。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginReqHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LoginReqBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginReqBean loginReqBean)</span></span>&#123;</span><br><span class="line">        <span class="comment">//登录逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgReqHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MsgReqBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MsgReqBean msgReqBean)</span></span>&#123;</span><br><span class="line">        <span class="comment">//消息发送逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码：只保留核心部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">I</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类型匹配器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeParameterMatcher matcher;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SimpleChannelInboundHandler</span><span class="params">(<span class="keyword">boolean</span> autoRelease)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化类型匹配器</span></span><br><span class="line">        <span class="keyword">this</span>.matcher = TypeParameterMatcher.find(<span class="keyword">this</span>, SimpleChannelInboundHandler.class, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.acceptInboundMessage(msg)) &#123;</span><br><span class="line">            <span class="comment">//类型校验通过通过，则调用抽象方法（子类去实现）</span></span><br><span class="line">            <span class="keyword">this</span>.channelRead0(ctx, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//类型校验不通过，则往下流转</span></span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象方法，由自定义业务类去实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext var1, I var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>本节学习主要掌握以下知识点</p>
<ol>
<li>基于 MessageToByteEncoder，我们可以实现自定义编码，而不用关心 ByteBuf 的创建，不用每次向写数据的时候，都手工进行编码；</li>
<li>基于 ByteToMessageDecoder，我们可以实现自定义解码，而不用关心 ByteBuf 的强转和 解码结果的传递；</li>
<li>基于 SimpleChannelInboundHandler，我们可以实现根据数据格式来判断由哪个 Handler 去处理，不需要手工 <code>if else</code> 判断，不需要手动传递对象，做到了真正关心业务逻辑的处理；</li>
<li>其实，这三种 Handler 也是有各自的应用场景，<code>ByteToMessageDecoder</code> 和 <code>MessageToByteEncoder</code> 是用来封装解码器和编码器，<code>SimpleChannelInboundHandler</code> 则是用于业务逻辑的简化开发。</li>
</ol>
<h1 id="Netty-粘包和拆包"><a href="#Netty-粘包和拆包" class="headerlink" title="Netty 粘包和拆包"></a>Netty 粘包和拆包</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>前面几个章节主要解析了 Netty 的编码、解码问题，那么是否有了编解码器，我们的 Netty 通信就能正常了呢？</p>
<p>TCP 协议在传输数据时没有办法判断数据是什么时候结束的，它无法识别一段完整的信息，因此可能会导致接受到的数据和发送时的数据不一致的情况。因此需要人为的指定一种规范的协议，从而保证数据的安全性，比如：我们所熟悉的 HTTP 协议。</p>
<p>本节内容，我们主要需要以下两点知识</p>
<ol>
<li>TCP 拆包、粘包的原因；</li>
<li>TCP 拆包、粘包的解决方案。</li>
</ol>
<h2 id="学习目的-1"><a href="#学习目的-1" class="headerlink" title="学习目的"></a>学习目的</h2><p>拆包、粘包在 TCP 协议当中，或者说 Netty 开发当中必须需要去解决的问题。在开发当中，你会发现你不需要解决拆包、粘包问题，数据也是能正常发送和接受，那么为什么需要去解决呢？</p>
<p>原因是，数据量比较小，TCP 发送之前它是有个缓冲池的，根据缓冲池的大小来把数据包拆分成多个小包进行发送。在高并发的情况下，拆包、粘包问题是经常会发生的，因此需要去 解决，否则接收方将获取不到正确的数据。</p>
<h2 id="粘包和拆包问题解析"><a href="#粘包和拆包问题解析" class="headerlink" title="粘包和拆包问题解析"></a>粘包和拆包问题解析</h2><h3 id="模拟拆包粘包问题"><a href="#模拟拆包粘包问题" class="headerlink" title="模拟拆包粘包问题"></a>模拟拆包粘包问题</h3><p>开始，之前我们先看一个简单的案例，具体如下所示：</p>
<p><strong>客户端：</strong> 客户端使用 for 循环，连续向服务端发送 <code>hello world</code>1000 遍（使用 StringEncoder 编码器）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            ctx.channel().writeAndFlush(</span><br><span class="line">                Unpooled.copiedBuffer(<span class="string">&quot;hello world 世界你好,Netty技术学习&quot;</span>.getBytes())</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务端：</strong> 正常输出客户端的信息（使用 StringDecoder 解码器）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str=msg.toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong><br><img src="http://img.mukewang.com/wiki/5f377f3e09006aa606330241.jpg" alt="图片描述"></p>
<p><strong>总结：</strong><br>通过以上的输出结果，我们发现，客户端发送过来的数据，有时候能正确打印，有时候数据粘在了一起。以上输出结果有乱码想象、有多个信息输出到一行，就是 ByteBuf 粘包和 ByteBuf 半包。</p>
<p>通过上面的简单案例，我们发现 TCP 协议下会产生数据安全性问题，其实在 TCP 中粘包和拆包是不可避免的，因为在 TCP 协议中，数据流向水流一样，根本不知道应该从哪里截取才是完整的数据包。TCP 并不了解上层业务的数据含义，它会根据 TCP 缓冲区的实际情况进行包的划分，因此一个完整的业务包可能会被 TCP 拆分成多个包进行发送，也可能会把多个小包封装成一个大包进行发送，这就是 TCP 粘包和拆包问题。</p>
<h3 id="常见的原因分析"><a href="#常见的原因分析" class="headerlink" title="常见的原因分析"></a>常见的原因分析</h3><p>粘包和拆包其实是客户端和服务端之间都会发生的事情，并不是说只是在客户端产生或者服务端产生，具体分析如下：</p>
<p><strong>发送方的粘包和拆包问题</strong></p>
<ol>
<li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包，也就是拆分几次发送；</li>
<li>要发送数据大于最大报文长度，TCP 在传输前将进行拆包，也就是拆分几次发送；</li>
<li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li>
</ol>
<p><strong>接收方的粘包和拆包问题</strong></p>
<ol>
<li>服务端分两次读取到独立的数据包，那么解析出来的数据正常，没有粘包和拆包问题；</li>
<li>服务端一次读取两个数据包，那么这些数据包就会粘合在一起，因此称为粘包；</li>
<li>服务端分两次读取两个数据包，第一次读到数据 1 和数据 2 部分内容，第二次读取数据 2 剩余内容，这被成为 TCP 拆包。</li>
</ol>
<p><strong>粘包和拆包的示意图</strong></p>
<p><img src="https://s2.loli.net/2021/12/24/5A32DCsbLkRyQj1.png" alt="图片描述"></p>
<p>总结，拆包和粘包问题并不是某一方的问题，可能是发送的粘包和拆包导致接收方读取数据出错，也可能是发送方正常，但是接收方读取出错。但是我们只需要了解，发送方和接收方什么情况下会拆包和粘包。</p>
<h2 id="Netty-提供的粘包拆包解决方案"><a href="#Netty-提供的粘包拆包解决方案" class="headerlink" title="Netty 提供的粘包拆包解决方案"></a>Netty 提供的粘包拆包解决方案</h2><p>虽然，在 Netty 当中是基于 ByteBuf 字节容器去编程，但是底层还是会被转换成字节流进行传输， 数据到了服务端，也是按照字节流的方式读入，然后到了 Netty 应用层面，重新拼装成 ByteBuf。如果为了数据的完整性，通常的解决方案如下：</p>
<ol>
<li>每次读取完都需要判断是否是一个完整数据包 ；</li>
<li>如果当前读取的数据不足以拼接成一个完整数据包，那就保留该数据，继续从 TCP 缓冲器读取，直到拼接成一个完整数据包为止；</li>
<li>如果拼接成了完整的数据包，但是有多余的数据，则仍然保留，以便和下次读取的数据进行拼接。</li>
</ol>
<blockquote>
<p>思考：那么应该如何去判断一个业务数据的完整结束呢？</p>
</blockquote>
<p><strong>方案一：</strong> 固定数据长度，客户端在发送数据的时候，每个数据包的长度固定（比如：1024 个字节），如果发送数据不足 1024 字节时，以空格补齐；服务端则每次读取固定长度是数据；<br><strong>方案二：</strong> 分隔符，每个数据包的结尾加一个特殊分隔符，服务端则读取到特殊分隔符则认为数据包结束；如果一次读取的数据没有结束符，则保留当前数据，等待下次读取；<br><strong>方案三：</strong> 将数据分为消息头和消息体，在头部保存了消息的数据长度，只有读取指定长度的数据就算完整数据包；<br><strong>方案四：</strong> 自定义协议，通过协议的规范进行发送和接受数据。</p>
<p>当然，以上的方案 Netty 官方也考虑到了，并且为了简化开发人员的工作量，Netty 内置了常见的拆包器，具体如下：</p>
<p><strong>1. 固定长度的拆包器 FixedLengthFrameDecoder</strong></p>
<p>每个数据包的长度都是固定的，比如 1024，那么只需要把这个拆包器加到 pipeline 中，Netty 会把一个个长度为 1024 的数据包 (ByteBuf) 传递到下一个 channelHandler。</p>
<p><strong>2. 行拆包器 LineBasedFrameDecoder</strong></p>
<p>它是一个特殊的分隔符拆包器，以换行符作为结束符。</p>
<p><strong>3. 分隔符拆包器 DelimiterBasedFrameDecoder</strong></p>
<p>可以自定义自己的分隔符。</p>
<p><strong>4. 基于长度域拆包器 LengthFieldBasedFrameDecoder</strong></p>
<p>是最通用的一种拆包器，有一个存放数据长度的字段，读到该字段之后，往后面的数据读取一定长度的数据即可，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。</p>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>本节内容需要掌握的知识点</p>
<ol>
<li>什么是拆包、粘包问题，以及它的产生原因是什么？</li>
<li>解决拆包、粘包问题的思路以及常见解决方案是什么？</li>
</ol>
<h1 id="Netty-通讯协议设计概要"><a href="#Netty-通讯协议设计概要" class="headerlink" title="Netty 通讯协议设计概要"></a>Netty 通讯协议设计概要</h1><h2 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h2><p>上节内容，我们主要介绍了 Netty 的粘包和拆包问题，并且大致介绍了 Netty 提供的常见拆包器，分别是固定长度拆包器、行拆包器、分隔符拆包器、基于长度域拆包器，但是它们只是相对简单的协议，也就是说无法满足复杂的业务场景，因此，我们可以通过自定义协议的方式去解决 TCP 的粘包和拆包问题。</p>
<h2 id="了解什么是协议"><a href="#了解什么是协议" class="headerlink" title="了解什么是协议"></a>了解什么是协议</h2><p>首先，我们大概了解什么是协议，协议可以把它认为是一种规则而不是技术，约束客户端和服务端之间通讯，数据组装和拆分的一种规范。客户端安装某种规范去组装数据，把数据传输给服务端，服务端再安装这种规范拆解数据，那么这就是一种协议，可以根据实际业务区指定符合自身的协议，其实基于 Netty 去制定的私有协议，我个人接触过的是传输车辆 GPS 数据的 809 协议，在和 GPS 服务器通讯时，必须按照该协议去进行封装和解析数据，否则通讯异常。</p>
<p>其实，类似的规则还有很多，从开发的角度来说，都是各种规则和约束，比如说：前面提到的序列化技术，序列化其实就是把数据按照某种规则去转换成 byte 数字，而反序列化就是按照这种规则再去把字节流转换成对应的类型数据。这些都是基于某种规则的基础上，使用技术的手段去封装的结果。</p>
<h2 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h2><h3 id="协议架构"><a href="#协议架构" class="headerlink" title="协议架构"></a>协议架构</h3><p><strong>思路架构图：</strong></p>
<p>首先，我们先来了解协议在整个通讯当中的扮演的角色，如下图所示：</p>
<p><img src="http://img.mukewang.com/wiki/5f433dea09162d1709640621.jpg" alt="图片描述"><br>如上图所示，客户端和服务端之间的通讯流程：</p>
<p><strong>客户端发送数据</strong></p>
<ol>
<li>客户端先把一个对象序列化成字节流；</li>
<li>然后把字节流根据协议把字节流组装好；</li>
<li>最后转换成二进制传输到网络。</li>
</ol>
<p><strong>服务端接受数据</strong></p>
<ol>
<li>从网络中读取二进制数据到本地的缓冲区；</li>
<li>根据协议的规则读取指定数据，并且识别是否是完整的数据包；</li>
<li>如果是完整的数据包，则转换成实体对象。</li>
</ol>
<p>由此可见，协议主要是管理字节流格式的一种规则，如果把协议环节去掉，那么服务端就无法知道字节流的结束位置。</p>
<h3 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h3><p><img src="https://s2.loli.net/2021/12/24/ykl69CtuwjhPdWi.png" alt="图片描述"></p>
<p><strong>协议介绍：</strong></p>
<ol>
<li>协议标识符，以一个固定数作为标识符，占用 4 个字节，主要目的是用来识别协议的开头，只要是以该标识开头的协议则进行处理，否则不处理。主要目的是提高处理性能问题，如果随便一个请求都需要进行处理，但是最终处理起来发现协议格式不对，抛异常，肯定会影响系统性能；</li>
<li>数据长度，占用 4 个字节，标识数据的真实长度，获取到该值后，往后读取指定长度的数据即可。主要目的是防止粘包和拆包安全性问题；</li>
<li>指令，协议是某个应用所有的业务公用的一种规则，那么应该如何区分是哪种业务呢？这里主要通过指令来进行区分；</li>
<li>数据，这部分存储的是真实的数据。</li>
</ol>
<p>这算是比较简单，并且常用的设计思路，主要和 Netty 内置的基于长度域拆包器类似，基本上都是有一个字段是用来存储真实的数据长度，这样才能准确的读取数据的完整内容。当然，还可以在该设计基础上加上更多的字段，比如：使用的序列号技术、协议版本号等等。</p>
<h3 id="技术栈说明"><a href="#技术栈说明" class="headerlink" title="技术栈说明"></a>技术栈说明</h3><p>相信到这里，大家对协议基本上有一个简单的认识了，其实协议并不难，它只是一个约束而已，那么我们如何通过技术的实现，让协议生效呢？主要的核心思想如下：</p>
<ol>
<li>序列化和发序列话技术，这个在 Netty 的编解码的时候已经讲过，序列化可以把对象转化成字节流，反序列化可以把字节流转换成对象；</li>
<li>字节容器（字节缓冲区），必须按照协议的字段顺序往字节容器里面存放对应的字节内容，然后把整个容器写到网络当中。这样数据才能按照顺序进行传输，服务端才能按照顺序进行数据的读取和处理。</li>
</ol>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>本节主要介绍协议的思想，它就是一种规则，客户端和服务端必须需要遵守的规则，才能保证数据的安全性。其次，讲解了协议在客户端和服务端通讯当中所扮演的角色，如果没有协议，那么服务端一直读取字节流，根本无法知道数据的完整性。最后，大概介绍了协议设计的大概思想，主要核心字段有四个，分别是协议标识符、数据长度、指令、数据，这四个字段是满足协议的基本元素，可以根据实际业务再进行扩展字段。</p>
<h1 id="Netty-通讯协议功能实现"><a href="#Netty-通讯协议功能实现" class="headerlink" title="Netty 通讯协议功能实现"></a>Netty 通讯协议功能实现</h1><h2 id="前言-5"><a href="#前言-5" class="headerlink" title="前言"></a>前言</h2><p>上节内容，我们主要讲解了 Netty 通讯协议设计，其实思路很简单就是核心的四个字段，分别是协议标识符、数据长度、指令、数据。还有其中涉及的技术主要是序列化和反序列化技术以及字节容器。那么本节主要是基于这个思想去实现我们的自定义协议，并且测试客户端循环 1000 遍发送数据是否还会出现粘包和拆包问题。</p>
<p><strong>技术栈说明</strong></p>
<ol>
<li>主要是使用对象流进行序列化和反序列化（ObjectInputStream 和 ObjectOutputStream）；</li>
<li>字节容器主要是以 Netty 的 ByteBuf 来管理字节。</li>
</ol>
<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p><img src="https://s2.loli.net/2021/12/24/lI6uiZhqYw938AT.png" alt="图片描述"></p>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                          User user, </span></span></span><br><span class="line"><span class="function"><span class="params">                          ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建一个内存输出流</span></span><br><span class="line">        ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">//2.创建一个对象输出流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">        <span class="comment">//3.把user对象写到内存流里面</span></span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        <span class="comment">//4.通过内存流获取user对象转换后的字节数字</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=os.toByteArray();</span><br><span class="line">        <span class="comment">//5.关闭流</span></span><br><span class="line">        oos.close();</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.根据协议组装数据</span></span><br><span class="line">        byteBuf.writeInt(<span class="number">1</span>);<span class="comment">//标识</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">1</span>);<span class="comment">//指令</span></span><br><span class="line">        byteBuf.writeInt(bytes.length);<span class="comment">//长度</span></span><br><span class="line">        byteBuf.writeBytes(bytes);<span class="comment">//数据内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码说明：</strong></p>
<ol>
<li>自定义一个编码器，把客户端向服务端发送的数据进行加工，主要是转换字节流，然后根据自定义协议来组装数据；</li>
<li>标识占用四个字节，使用 writeInt ()，一个 int 表示四个字节；</li>
<li>指令占用一个字节，因此使用 writeByte () 即可；</li>
<li>数据长度占用四个字节，因此使用 writeByte ()，int 表示的最大值一般来说足够表示数据的内容了，除非特别特别大的数据（比如：超级大文件的传输）则可以使用 writeLong () 来表示数据长度。</li>
</ol>
<h3 id="解码实现"><a href="#解码实现" class="headerlink" title="解码实现"></a>解码实现</h3><p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ChannelHandlerContext channelHandlerContext, </span></span></span><br><span class="line"><span class="function"><span class="params">        ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.根据协议分别取出对应的数据</span></span><br><span class="line">        <span class="keyword">int</span> tag=byteBuf.readInt();<span class="comment">//标识符</span></span><br><span class="line">        <span class="keyword">byte</span> code=byteBuf.readByte();<span class="comment">//指令</span></span><br><span class="line">        <span class="keyword">int</span> len=byteBuf.readInt();<span class="comment">//长度</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[len];<span class="comment">//定义一个字节数据，长度是数据的长度</span></span><br><span class="line">        byteBuf.readBytes(bytes);<span class="comment">//往字节数组读取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过对象流来转换字节流，转换成User对象</span></span><br><span class="line">        ByteArrayInputStream is=<span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream iss=<span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">        User user=(User)iss.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        iss.close();</span><br><span class="line"></span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码说明：</strong><br>这里主要是实现了解码器，主要目的是通过自定义协议来分别读取对应的数据，并且通过对象流来反序列化字节流。</p>
<h3 id="发送方-Handler"><a href="#发送方-Handler" class="headerlink" title="发送方 Handler"></a>发送方 Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            User user=<span class="keyword">new</span> User();</span><br><span class="line">            user.setName(i+<span class="string">&quot;-&gt;zwy&quot;</span>);</span><br><span class="line">            user.setAge(<span class="number">18</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注意，这里直接写user对象，无需再手工转换字节流了，编码器会自动帮忙处理。</span></span><br><span class="line">            ctx.channel().writeAndFlush(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码说明：</strong><br>客户端在链接就绪时，使用 for 循环给服务端发送数据，主要目的是检测是否会产生数据粘包和拆包问题。</p>
<h3 id="接受方-Handler"><a href="#接受方-Handler" class="headerlink" title="接受方 Handler"></a>接受方 Handler</h3><p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user=(User)msg;</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="加入-Pipeline"><a href="#加入-Pipeline" class="headerlink" title="加入 Pipeline"></a>加入 Pipeline</h3><p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.拆包器</span></span><br><span class="line">ch.pipeline().addLast(</span><br><span class="line">    <span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//2.自定义编码器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyEncoder());</span><br><span class="line"><span class="comment">//3.业务处理Handler</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ClientTestHandler());</span><br></pre></td></tr></table></figure>

<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Netty内置拆包器</span></span><br><span class="line">ch.pipeline().addLast(</span><br><span class="line">    <span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//2.自定义解码器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyEncoder());</span><br><span class="line"><span class="comment">//3.业务Handler</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ServerTestHandler());</span><br></pre></td></tr></table></figure>

<p><strong>代码说明：</strong></p>
<ol>
<li>需要往双向链表里面加入三个特殊的 Handler，分别是 <code>LengthFieldBasedFrameDecoder</code> 和自定义的编码器、解码器；</li>
<li><code>LengthFieldBasedFrameDecoder</code> 拆包器的构造函数字段说明，分别如下所示：<br>2.1 第一个参数，maxFrameLength：解码时，处理每个帧数据的最大长度，一般来说直接赋予 <code>Integer.MAX_VALUE</code> 即可；<br>2.2 第二个参数，lengthFieldOffset ：存放帧数据的长度数据的起始位（偏移位），通俗点说，就是表示数据长度的字段在整个协议里面所处的位置，由于协议的结果是：协议标识（4 个字节）、指令（1 个字节）、数据长度（4 个字节），因此数据长度处于第 5 个位置；<br>2.3 第三个参数，lengthFieldLength：长度属性的长度，即存放整个大数据包长度的字节所占的长度，这里是 4 个字节。</li>
</ol>
<blockquote>
<p>疑问：为什么需要加 <code>LengthFieldBasedFrameDecoder</code> 呢？</p>
<p>回答：自定义协议它是无法知道数据包是什么时候应该结束，需要依赖 Netty 提供的拆包器。</p>
</blockquote>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>先启动服务端，然后启动客户端，打印结果没有出现粘包和拆包问题，证明我们自定义的协议有效，最终运行效果如下所示：<br><img src="http://img.mukewang.com/wiki/5f377ffb0939934103360608.jpg" alt="图片描述"></p>
<h2 id="LengthFieldBaseFrameDecoder"><a href="#LengthFieldBaseFrameDecoder" class="headerlink" title="LengthFieldBaseFrameDecoder"></a>LengthFieldBaseFrameDecoder</h2><p>这里，主要简单的介绍该拆包器，因为它是我们平时开发当中最常用的拆包器， 几乎所有和长度相关的二进制协议都可以通过它来实现，因此在这里简单的介绍一下它的原理。</p>
<blockquote>
<p>思考：如果让我们简单实现一个自己的拆包器，那么我们应该如何去实现呢？</p>
</blockquote>
<p>其实原理很简单，就是不断从 TCP 缓冲区中读取数据，每次读取完都需要判断是否是一个完整的数据包。</p>
<ol>
<li>如果当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从 tcp 缓冲区中读取，直到得到一个完整的数据包；</li>
<li>如果当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，够成一个完整的业务数据包传递到下一个节点进行处理。如果拼接完一个数据包时还有多余的数据仍然保留，以便和下次读到的数据进行拼接；</li>
<li>Netty 中的拆包也是如上这个原理，内部会有一个累加器，每次读取到数据都会不断累加，然后尝试对累加到的数据进行拆包，拆成一个完整的业务数据包，这个基类叫做 <code>ByteToMessageDecoder</code> 。</li>
</ol>
<h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>本节，主要是根据上节设计的通讯协议来具体的实现效果，主要掌握的核心步骤是：</p>
<ol>
<li>需要依赖 <code>LengthFieldBaseFrameDecoder</code> 拆包器，并且需要了解该拆包器的参数定义和大概原理；</li>
<li>掌握编码器和解码器的实现，主要是在编码器和解码器里面实现协议的数据粘包和数据拆包。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ahao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ahao.ink/posts/Netty%20%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/">https://ahao.ink/posts/Netty%20%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ahao.ink" target="_blank">ahao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2021/12/24/o3IOD9fHKYPRGvm.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://i.loli.net/2021/11/12/6zSDdqXlvjMakgC.jpg" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/11/12/6zSDdqXlvjMakgC.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://i.loli.net/2021/11/12/Xa5GvktA3qi7VYN.jpg" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/11/12/Xa5GvktA3qi7VYN.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/ChannelHandler%20%E5%92%8C%20ChannelPipeline/"><img class="prev-cover" src="https://s2.loli.net/2021/12/24/DJ4coNMTRzG3xFj.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ChannelHandler 和 ChannelPipeline</div></div></a></div><div class="next-post pull-right"><a href="/posts/Netty%20%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE/"><img class="next-cover" src="https://s2.loli.net/2021/12/24/rBWnxc1ZRTyb3Gd.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty 常用协议</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/11/12/Edhsr56wxfUbuFg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">ahao</div><div class="author-info__description">如有一味绝境，非历十方生死</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://ahao.ink"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">好 记 性 不 如 烂 笔 头</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty-%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">Netty 编码和解码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">编码和解码的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">解码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">编码解码流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">整体流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">编码流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">解码流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">如何自定义编解码器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-1"><span class="toc-number">2.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%8B%AC%E7%AB%8B-Handler%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">为什么要封装独立 Handler？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringDecoder-%E5%92%8C-StringEncoder"><span class="toc-number">2.3.</span> <span class="toc-text">StringDecoder 和 StringEncoder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">大体流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB"><span class="toc-number">2.4.</span> <span class="toc-text">源码阅读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">自定义编解码器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93"><span class="toc-number">2.5.1.</span> <span class="toc-text">实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">编码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">2.5.3.</span> <span class="toc-text">解码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%88%B0-Pipeline"><span class="toc-number">2.5.4.</span> <span class="toc-text">添加到 Pipeline</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">2.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty-%E5%86%85%E7%BD%AE%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">Netty 内置编解码器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-2"><span class="toc-number">3.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E7%9A%84"><span class="toc-number">3.2.</span> <span class="toc-text">学习目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">3.3.</span> <span class="toc-text">类关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MessageToByteEncoder"><span class="toc-number">3.4.</span> <span class="toc-text">MessageToByteEncoder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteToMessageDecoder"><span class="toc-number">3.5.</span> <span class="toc-text">ByteToMessageDecoder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SimpleChannelInboundHandler"><span class="toc-number">3.6.</span> <span class="toc-text">SimpleChannelInboundHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-number">3.6.1.</span> <span class="toc-text">方案一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="toc-number">3.6.2.</span> <span class="toc-text">方案二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89"><span class="toc-number">3.6.3.</span> <span class="toc-text">方案三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">3.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85"><span class="toc-number">4.</span> <span class="toc-text">Netty 粘包和拆包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-3"><span class="toc-number">4.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E7%9A%84-1"><span class="toc-number">4.2.</span> <span class="toc-text">学习目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90"><span class="toc-number">4.3.</span> <span class="toc-text">粘包和拆包问题解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%8B%86%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.1.</span> <span class="toc-text">模拟拆包粘包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-number">4.3.2.</span> <span class="toc-text">常见的原因分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty-%E6%8F%90%E4%BE%9B%E7%9A%84%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.4.</span> <span class="toc-text">Netty 提供的粘包拆包解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">4.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81"><span class="toc-number">5.</span> <span class="toc-text">Netty 通讯协议设计概要</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-4"><span class="toc-number">5.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.2.</span> <span class="toc-text">了解什么是协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.3.</span> <span class="toc-text">通讯协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E6%9E%B6%E6%9E%84"><span class="toc-number">5.3.1.</span> <span class="toc-text">协议架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.3.2.</span> <span class="toc-text">协议设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%A0%88%E8%AF%B4%E6%98%8E"><span class="toc-number">5.3.3.</span> <span class="toc-text">技术栈说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">5.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">Netty 通讯协议功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-5"><span class="toc-number">6.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">实现流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.</span> <span class="toc-text">功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">编码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.2.</span> <span class="toc-text">解码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9-Handler"><span class="toc-number">6.3.3.</span> <span class="toc-text">发送方 Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E6%96%B9-Handler"><span class="toc-number">6.3.4.</span> <span class="toc-text">接受方 Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%85%A5-Pipeline"><span class="toc-number">6.3.5.</span> <span class="toc-text">加入 Pipeline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C"><span class="toc-number">6.3.6.</span> <span class="toc-text">运行效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LengthFieldBaseFrameDecoder"><span class="toc-number">6.4.</span> <span class="toc-text">LengthFieldBaseFrameDecoder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">6.5.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="EventLoop和线程模型"><img src="https://s2.loli.net/2021/12/24/oU8bJKuwTrD4pN3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EventLoop和线程模型"/></a><div class="content"><a class="title" href="/posts/EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="EventLoop和线程模型">EventLoop和线程模型</a><time datetime="2021-10-06T05:36:41.000Z" title="发表于 2021-10-06 13:36:41">2021-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Netty%20%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/" title="Netty 心跳检测"><img src="https://s2.loli.net/2021/12/24/gYjCcwFdvQypA4b.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty 心跳检测"/></a><div class="content"><a class="title" href="/posts/Netty%20%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/" title="Netty 心跳检测">Netty 心跳检测</a><time datetime="2021-09-30T05:36:41.000Z" title="发表于 2021-09-30 13:36:41">2021-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="序列化和反序列化到底有什么用呢？"><img src="https://s2.loli.net/2021/12/24/V7zmByD8F6fj3As.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="序列化和反序列化到底有什么用呢？"/></a><div class="content"><a class="title" href="/posts/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="序列化和反序列化到底有什么用呢？">序列化和反序列化到底有什么用呢？</a><time datetime="2021-09-30T05:36:41.000Z" title="发表于 2021-09-30 13:36:41">2021-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98/" title="Netty 数据缓存"><img src="https://s2.loli.net/2021/12/24/V7zmByD8F6fj3As.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty 数据缓存"/></a><div class="content"><a class="title" href="/posts/%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98/" title="Netty 数据缓存">Netty 数据缓存</a><time datetime="2021-09-30T05:36:41.000Z" title="发表于 2021-09-30 13:36:41">2021-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ChannelHandler%20%E5%92%8C%20ChannelPipeline/" title="ChannelHandler 和 ChannelPipeline"><img src="https://s2.loli.net/2021/12/24/DJ4coNMTRzG3xFj.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ChannelHandler 和 ChannelPipeline"/></a><div class="content"><a class="title" href="/posts/ChannelHandler%20%E5%92%8C%20ChannelPipeline/" title="ChannelHandler 和 ChannelPipeline">ChannelHandler 和 ChannelPipeline</a><time datetime="2021-09-30T05:36:41.000Z" title="发表于 2021-09-30 13:36:41">2021-09-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2021/12/24/o3IOD9fHKYPRGvm.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By ahao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://ahao.ink" target="_self">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'oKBwwKX9hp2tpOKDPE3PVQpL-gzGzoHsz',
      appKey: '3QBBKGzgsE11VOcVl1RElhgu',
      placeholder: '说点什么吧~',
      avatar: 'retro',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '//i0.hdslb.com/bfs/emote/',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>