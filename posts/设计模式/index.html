<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>设计模式 | ahao</title><meta name="author" content="ahao"><meta name="copyright" content="ahao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="设计模式简介所谓设计模式，是为解决特定问题，一套通用的、可重用的软件设计方案。我们通常所说的设计模式，是针对面向对象语言而言。对于每一位使用面向对象语言的从业者，在学习完该语言的基础知识后，也一定了解如何编写面向对象的程序。但是，面向对象究竟有什么好处，我们又应该如何灵活运用面向对象来设计程序呢？ 面向对象面向对象出现之前，程序是面向过程的。两者在软件设计上有着很大的不同。面向过程，我们首要思考逻">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="https://ahao.ink/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="ahao">
<meta property="og:description" content="设计模式简介所谓设计模式，是为解决特定问题，一套通用的、可重用的软件设计方案。我们通常所说的设计模式，是针对面向对象语言而言。对于每一位使用面向对象语言的从业者，在学习完该语言的基础知识后，也一定了解如何编写面向对象的程序。但是，面向对象究竟有什么好处，我们又应该如何灵活运用面向对象来设计程序呢？ 面向对象面向对象出现之前，程序是面向过程的。两者在软件设计上有着很大的不同。面向过程，我们首要思考逻">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/ydiAZTkanzuLY7P.png">
<meta property="article:published_time" content="2021-09-02T05:36:41.000Z">
<meta property="article:modified_time" content="2021-12-26T14:47:56.525Z">
<meta property="article:author" content="ahao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2021/12/26/ydiAZTkanzuLY7P.png"><link rel="shortcut icon" href="https://i.loli.net/2021/11/12/NAU53jI9mGOJlDC.png"><link rel="canonical" href="https://ahao.ink/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-26 22:47:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/11/12/Edhsr56wxfUbuFg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2021/12/26/ydiAZTkanzuLY7P.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ahao</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-02T05:36:41.000Z" title="发表于 2021-09-02 13:36:41">2021-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-26T14:47:56.525Z" title="更新于 2021-12-26 22:47:56">2021-12-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>所谓设计模式，是为解决特定问题，一套通用的、可重用的软件设计方案。我们通常所说的设计模式，是针对面向对象语言而言。对于每一位使用面向对象语言的从业者，在学习完该语言的基础知识后，也一定了解如何编写面向对象的程序。但是，面向对象究竟有什么好处，我们又应该如何灵活运用面向对象来设计程序呢？</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象出现之前，程序是面向过程的。两者在软件设计上有着很大的不同。<br>面向过程，我们首要思考逻辑过程是什么，如何设计这个过程。<br>面向对象，首先要考虑的是有哪些对象，对象有什么行为，最后才是行为的逻辑。</p>
<p>面向对象的可以让你程序的设计和真实世界更为契合。这会带来如下优点：</p>
<ol>
<li>现实世界有千百年积累下来数以万亿计的优秀设计，无论是具体的机械设备，还是方法论，或者工程理论。我们都可以拿来作为软件设计的参考。</li>
<li>面向对象开发出的软件，让其他开发者更容易理解。我们每个人都熟知我们所生活的世界。面向对象可以让枯燥的代码更加鲜活，甚至凭你的经验，也能猜出对象的某个行为应该是怎样的逻辑。</li>
</ol>
<p>夸了半天面向对象，你可能会想，面向对象确实不错，我所使用的语言也是面向对象的，那我编写的程序天然也就拥有了面向对象的优点。这种想法是错误的。语言仅仅是个工具，而面向对象编程是一种思维。如果对面向对象编程没有深入理解，那么你写出的程序，也只是披着面向对象的外衣而已。此外，即使你充分理解了面向对象的思维，也不一定能够灵活运用面向对象解决问题。那么，此时就轮到设计模式出场了！</p>
<h2 id="设计模式来自哪里"><a href="#设计模式来自哪里" class="headerlink" title="设计模式来自哪里"></a>设计模式来自哪里</h2><p>设计模式不是凭空想出来的。作为通用的设计方式，设计模式是跨语言的。要想做到跨语言，那么它的根基一定是万物都要遵守的规律。设计模式来源于真实世界，前辈们通过不断地归纳总结、实践，将一些已经存在的设计理论运用于软件领域，并很好地解决了软件设计上的问题。最终呈现给我们这些丰富的设计模式。<br>当我们学习设计模式之后，就可以深刻体会到为什么设计模式来源于真实世界。这里我先举个例子，比如订阅者模式。一听名字你一定可以映射到现实生活中某些类似的方式，比如订报纸，订牛奶。订的人就是订阅者，送的人就是发布者。发布订阅的核心思想，再加上软件的特性，就构成了订阅者模式。</p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>那么使用设计模式能为软件开发带来什么好处呢？这要从设计模式的设计原则说起，一般来说有6大原则，如下：</p>
<ol>
<li>单一职责原则<br>顾名思义，一个类最好只有一个职责。这样的好处是引起类发生变化的原因会很少。我们开发新需求的时候，就会很少去修改这个类。而且职责越单一也越容易被复用。</li>
<li>开闭原则<br>软件应该对扩展开放，对修改关闭。通俗易懂的说，就是你的软件不能因为加功能，就不断地修改已有的类。而是应该通过增加类，以插拔的方式来实现。举个例子，Macbook的变压器插头是可以替换的，如果说某一天插口的标准换了，那么苹果只需要开发一个新的插头就好了，而不需要重新开发整个变压器。开闭原则确保了代码最大程度的可复用性。并且确保了成熟代码的稳定性。</li>
<li>里氏代换原则<br>子类型可以替换掉自己的父类。这意味着我们编写的软件，所有使用父类的地方，都可以替换为子类对象，而程序的行为不会发生改变。通过里氏代换原则，我们可以实现开闭原则，通过增加子类实现新的功能，而不是不断地修改父类。在需要的地方则用子类代替父类。如何实现里氏代换原则呢？首先子类不能重写父类的非抽象方法，一旦重写了非抽象方法，就会改变父类的行为。但是子类可以增加自己的方法和属性，以此达到扩展的目的。</li>
<li>依赖倒转原则<br>简单说就是应该依赖接口，而不是实现。也就是我们常说的面向接口编程。这样类和类之间就不会直接依赖，从而能够实现开闭原则。类依赖接口，当需要扩展的时候我们可以替换实现。</li>
<li>迪米特法则<br>也称为最少知道原则。如果两个类没有必要直接通信，那么两个类就没有必要相互作用。可以通过第三方来间接调用。类之间的耦合度越弱，越容易被复用。在弱耦合的关系中，一个类的修改，造成的影响会很小。所以我们在做设计的时候需要考虑哪些应该对外暴露，哪些应该封装起来。不同功能模块间的调用，应该由更为高层的类来实现，从而屏蔽掉底层的实现。</li>
<li>接口隔离原则<br>接口隔离原则指导你如何设计接口。不要让接口变得臃肿，而是应该把接口按照行为不同细拆。比如你要生产一把可以拼刺刀的步枪，那它应该实现两个接口，刀的接口和枪的接口。而不是使用一个接口覆盖所有刀和枪的所有行为。这样不同的接口可以组合使用。而且如果你只需要刀或者枪的行为，可以单独实现需要的接口， 不需要实现一个大而全的接口，从而去实现很多用不到的方法。</li>
</ol>
<p>如果你的代码满足以上设计原则，就会更为健壮、灵活和优雅。那么如何做到上面这些原则呢？很简单，学习好设计模式，灵活运用设计模式解决你的问题。</p>
<h2 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h2><p>前面已经给出了设计模式的定义—-为解决特定的问题，一套通用的、可重用的软件设计方案。我们面对的问题不一样，需要选择不同的设计模式来解决问题。</p>
<p>这就好比木匠有 20 种工具，分别用于做不同的事情。而设计模式就是软件设计的工具，根据你遇到的问题不同，供你选择使用。而学习设计模式的目的，就是让你熟知工具的样子，工具能够做什么事情，解决什么样的问题。当你再遇到设计问题时，自然就会想到采用什么设计模式来解决。</p>
<p>设计模式有多厉害呢？我可以讲一个亲身经历，曾经我有一位同事写了一段代码来完成一个功能。code review时，我和他说你可以看一下设计模式，这段代码使用XX模式来实现会更为的优雅。两天后他找到我说：“设计模式太厉害了！感觉我前几年代码都白写了！” 你不要觉得夸张，他的这个感觉，也是我初学设计模式后的感觉—-原来程序还可以这么写！以前我们解决问题的工具是锤子、斧子，而现在全都是机械化工具。设计模式就是这么神奇的东西。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节从面向对象讲起，讲解了什么是设计模式，程序设计的原则有哪些，为什么要学习设计模式。设计模式是写好程序的根基。我们常常提到代码要高内聚、松耦合，代码要健壮等等。这些优秀代码的特性，全都来自于设计模式。足以见得设计模式的重要性。本小结内容比较多，总结如下：</p>
<p><img src="https://s2.loli.net/2021/12/25/svGoXZECp8F6b9H.jpg" alt="图片描述"></p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式是平时开发过程中最常见的设计模式。工厂模式解决类的实例化问题，它属于创建型模式。工厂模式也经常会和其他设计模式组合使用。</p>
<p>试想你去麦当劳买一个汉堡。你只需要告诉收银员要一个xx汉堡。过一会就会有一个此类型的汉堡被制作出来。而你完全不需要知道这个汉堡是怎么被制作出来的。这个例子中你就是客户端代码，麦当劳就是工厂，负责生产汉堡。汉堡是接口，而具体的某一种汉堡，比如说香辣鸡腿堡，就是实现了汉堡接口的类。</p>
<p>我们继续通过另外一个例子，深入理解工厂模式。现在我们给某款音乐软件开发一个推荐功能。需求是能够根据用户选择的音乐风格，推荐不同风格的歌曲清单。那么你打算怎么实现呢？</p>
<h2 id="音乐推荐器1-0版本"><a href="#音乐推荐器1-0版本" class="headerlink" title="音乐推荐器1.0版本"></a>音乐推荐器1.0版本</h2><p>如果之前没有学习过设计模式，很可能你的实现会是这样。编写 <code>RecommendMusicService</code> 类，里面有一个 Recommend方法。根据输入的风格不同，执行不同的推荐逻辑。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecommendMusicService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">recommend</span><span class="params">(String style)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; recommendMusicList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;metal&quot;</span>.equals(style)) &#123;</span><br><span class="line">            recommendMusicList.add(<span class="string">&quot;Don&#x27;t cry&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;country&quot;</span>.equals(style)) &#123;</span><br><span class="line">            recommendMusicList.add(<span class="string">&quot;Hotel california&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;grunge&quot;</span>.equals(style)) &#123;</span><br><span class="line">            recommendMusicList.add(<span class="string">&quot;About a girl&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            recommendMusicList.add(<span class="string">&quot;My heart will go on&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recommendMusicList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是觉得 recommed 方法太长了? OK，我们重构下，把每种音乐风格的推荐逻辑封装到相应的方法中。这样推荐方法就可以复用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecommendMusicService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">recommend</span><span class="params">(String style)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; recommendMusicList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;metal&quot;</span>.equals(style)) &#123;</span><br><span class="line">            recommendMetal(recommendMusicList);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;country&quot;</span>.equals(style)) &#123;</span><br><span class="line">            recommendCountry(recommendMusicList);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;grunge&quot;</span>.equals(style)) &#123;</span><br><span class="line">            recommendGrunge(recommendMusicList);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            recommendPop(recommendMusicList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recommendMusicList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recommendPop</span><span class="params">(List&lt;String&gt; recommendMusicList)</span> </span>&#123;</span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;My heart will go on&quot;</span>);</span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;Beat it&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recommendGrunge</span><span class="params">(List&lt;String&gt; recommendMusicList)</span> </span>&#123;</span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;About a girl&quot;</span>);</span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;Smells like teen spirit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recommendCountry</span><span class="params">(List&lt;String&gt; recommendMusicList)</span> </span>&#123;</span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;Hotel california&quot;</span>);</span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;Take Me Home Country Roads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recommendMetal</span><span class="params">(List&lt;String&gt; recommendMusicList)</span> </span>&#123;</span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;Don&#x27;t cry&quot;</span>);</span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;Fade to black&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样是不是很完美了！recommend 方法精简了很多，而且每种不同的推荐逻辑都被封装到相应的方法中了。那么，如果再加一种风格推荐怎么办？这有什么难，recommed 方法中加分支就好啦。然后在 <code>RecommendMusicService</code> 中增加一个对应的推荐方法。<br>等等，是不是哪里不太对？回想一下设计模式6大原则的开闭原则—-<strong>对扩展开放，对修改关闭</strong>。面对新风格推荐的需求，我们一直都在修改 <code>RecommendMusicService</code> 这个类。以后每次有新风格推荐要添加，都会导致修改 <code>RecommendMusicService</code> ，显然这不可取。</p>
<p>那么如何做到实现新的风格推荐需求时，满足开闭原则呢？</p>
<h2 id="音乐推荐器2-0版本"><a href="#音乐推荐器2-0版本" class="headerlink" title="音乐推荐器2.0版本"></a>音乐推荐器2.0版本</h2><p>添加新需求时，如何做到不修改，去扩展？是不是想到了单一职责？是的，类的职责越单一，那么它就越稳定。<code>RecommendMusicService</code> 类的职责太多了，负责n种风格的推荐。OK，那么我们第一件事就是要减少 <code>RecommendMusicService</code> 类的职责，把每种不同风格的推荐提取到不同的类当中。<br>比如<code>MetalMusicRecommendService</code>、<code>PopMusicRecommendService</code>、<code>CountryMusicRecommendService</code>。这些类都可以通过 recommed 方法生成推荐的歌曲清单。而 <code>RecommendMusicService</code> 类只是通过调用不同 <code>MusicRecommendService</code> 的 recommed 方法来实现推荐。代码如下：</p>
<p>MetalMusicRecommendService 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetalMusicRecommendService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">recommend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; recommendMusicList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;Don&#x27;t cry&quot;</span>);</span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;Fade to black&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recommendMusicList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码块<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>同类型的还有 <code>GrungeMusicRecommendService</code>、<code>PopMusicRecommendService</code>、<code>CountryMusicRecommendService</code> 类</p>
<p>现在我们来改造 <code>MusicRecommendService</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecommendMusicService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MetalMusicRecommendService metalMusicRecommendService = <span class="keyword">new</span> MetalMusicRecommendService();</span><br><span class="line">    <span class="keyword">private</span> GrungeMusicRecommendService grungeMusicRecommendService = <span class="keyword">new</span> GrungeMusicRecommendService();</span><br><span class="line">    <span class="keyword">private</span> CountryMusicRecommendService countryMusicRecommendService = <span class="keyword">new</span> CountryMusicRecommendService();</span><br><span class="line">    <span class="keyword">private</span> PopMusicRecommendService popMusicRecommendService = <span class="keyword">new</span> PopMusicRecommendService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">recommend</span><span class="params">(String style)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; recommendMusicList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;metal&quot;</span>.equals(style)) &#123;</span><br><span class="line">            metalMusicRecommendService.recommend();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;country&quot;</span>.equals(style)) &#123;</span><br><span class="line">            countryMusicRecommendService.recommend();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;grunge&quot;</span>.equals(style)) &#123;</span><br><span class="line">            grungeMusicRecommendService.recommend();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            popMusicRecommendService.recommend();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recommendMusicList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造后，如果有了新音乐风格推荐的需求，只需要增加相应的 <code>xxxMusicRecommendService</code> 类。然后在 <code>RecommendMusicService</code> 中增加相应分支即可。这样就做到了开闭原则。那么还有什么违背设计原则的地方吗？<code>RecommendMusicService</code> 是不是依赖的 <code>xxMusicRecommendService</code> 类太多了？</p>
<p>没错，而且这么多类，实际上都是做推荐的事情，且都是通过 recommend 方法提供推荐结果。这完全可以抽象出接口，比如 <code>MusicRecommendInterface</code>。那么 <code>RecommendMusicService</code> 依赖 <code>MusicRecommendInterface</code> 就可以了。这解决了依赖反转问题—-<strong>应该依赖接口，而不是依赖具体实现</strong>。</p>
<p>我们又复习了单一职责和依赖反转原则。不愧是指导设计模式的原则，真的是无处不在。依赖 <code>MusicRecommendInterface</code> 没问题，但是不同的音乐风格，怎么能实例化 <code>MusicRecommendInterface</code> 的某个具体实现呢？工厂模式于是就应运而生了！</p>
<h2 id="音乐推荐器3-0版本"><a href="#音乐推荐器3-0版本" class="headerlink" title="音乐推荐器3.0版本"></a>音乐推荐器3.0版本</h2><p>我们回顾一下文章开头说到，工厂模式解决的是类的实例化。无论你需要哪种风格的 <code>MusicRecommendService</code>，只需要告诉工厂，工厂会给你实例化好你需要的具体实现。而工厂能做到这些是基于继承和多态。<br><code>RecommendMusicService</code> 只需要依赖 <code>MusicRecommendInterface</code>，具体需要哪个<code>MusicRecommendService</code> 的实现，只需要告诉 <code>RecommendServiceFactory</code> 即可。<code>MusicRecommendService</code> 拿到具体的实现后调用它的 recommand 方法，就可以得到相应风格的推荐歌曲清单。</p>
<p>首先我们需要定义所有 <code>MusicRecommendService</code> 要实现的接口，很简单，只有一个 recommend 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MusicRecommendInterface</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">recommend</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们2.0版本中的 <code>xxxMusicRecommendService</code> 都需要实现此接口，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrungeMusicRecommendService</span> <span class="keyword">implements</span> <span class="title">MusicRecommendInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">recommend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; recommendMusicList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;About a girl&quot;</span>);</span><br><span class="line">        recommendMusicList.add(<span class="string">&quot;Smells like teen spirit&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recommendMusicList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同音乐风格的推荐逻辑在各自实现的 recommend() 方法中。<br>下面就是工厂模式中的工厂代码了，其实很简单，只是根据不同的参数实例化不同的实现并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicRecommendServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">MusicRecommendInterface <span class="title">createMusicRecommend</span><span class="params">(String style)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;metal&quot;</span>.equals(style)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MetalMusicRecommendService();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;country&quot;</span>.equals(style)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CountryMusicRecommendService();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;grunge&quot;</span>.equals(style)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GrungeMusicRecommendService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PopMusicRecommendService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看看 <code>RecommendMusicService</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecommendMusicService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MusicRecommendServiceFactory recommendMusicServiceFactory = <span class="keyword">new</span> MusicRecommendServiceFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">recommend</span><span class="params">(String style)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MusicRecommendInterface musicRecommend = recommendMusicServiceFactory.createMusicRecommend(style);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> musicRecommend.recommend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是简单多了，已经不再依赖那么多的 <code>MusicRecommendInterface</code> 的实现了。它要做的事情仅仅是通过工厂得到想要的 <code>RecommendMusicService</code> 实现，然后调用它的 recommend() 方法，就可以得到你想要的推荐结果。<br>类图如下：</p>
<p><img src="https://s2.loli.net/2021/12/25/4olBiGEr7UXgvmL.jpg" alt="图片描述"><br>以上三种实现方式总结如下：</p>
<p><img src="https://s2.loli.net/2021/12/25/f4cmZ8i7JGBK6ez.jpg" alt="图片描述"></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本节我们通过音乐推荐器的例子，实践了如何找到程序中违反设计原则的地方，并通过工厂模式来解决这些问题。使用设计模式可以让程序更符合程序设计原则，从而写出更为健壮的代码。我们应牢记工厂模式解决的是类的实例化问题。这个例子很简单，不过涉及到的知识点却很多。有封装、多态、单一职责和依赖反转等。可见要想把程序设计好，必须熟练掌握这些基本概念和原则。</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>大家一定都使用过电子地图。在地图中输入出发地和目的地，然后再选取你的出行方式，就可以计算出最优线路以及预估的时长。出行方式有驾车、公交、步行、骑行等。出行方式不同，计算的线路和时间当然也不同。<br>其实出行方式换个词就是出行策略。而策略模式就是针对此类问题的设计模式。生活中这种例子太多了，比如购物促销打折的策略、计算税费的策略等等。相应的策略模式也是一种常用的设计模式。本节我们会以电子地图为例，比较工厂模式和策略模式，讲解策略模式的原理。最后结合工厂模式改造策略模式的代码实现，以达到更高的设计目标。</p>
<h2 id="实现策略模式"><a href="#实现策略模式" class="headerlink" title="实现策略模式"></a>实现策略模式</h2><p>接下来我们就以电子地图为例，讲解如何用策略模式实现。不过先别着急，上一节我们学习了工厂模式，看起来电子地图也可以用工厂模式来实现。所以我们先来看看用工厂模式如何实现。下面的例子为了方便展示，接口入参只有出行方式，省略了出发地和目的地。计算结果是预估时长。</p>
<h3 id="工厂模式实现电子地图"><a href="#工厂模式实现电子地图" class="headerlink" title="工厂模式实现电子地图"></a>工厂模式实现电子地图</h3><p>首先我们需要一个策略接口，不同策略实现该接口。再搭配一个策略工厂。客户端代码只需要根据用户的出行方式，让工厂返回具体实现即可，由具体的实现来提供算法计算。以工厂模式实现的电子地图代码如下。<br><code>TravelStrategy</code>接口代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TravelStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinCost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TravelStrategy</code>接口的实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfDrivingStrategy</span> <span class="keyword">implements</span> <span class="title">TravelStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinCost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TravelStrategyFactory</code>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TravelStrategyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TravelStrategy <span class="title">createTravelStrategy</span><span class="params">(String travelWay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;selfDriving&quot;</span>.equals(travelWay)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SelfDrivingStrategy();</span><br><span class="line">        &#125; <span class="keyword">if</span> (<span class="string">&quot;bicycle&quot;</span>.equals(travelWay)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BicycleStrategy();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PublicTransportStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TravelService</code>对外提供计算方法，通过工厂生成所需要的 strategy。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TravelService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TravelStrategyFactory travelStrategyFactory = <span class="keyword">new</span> TravelStrategyFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinCost</span><span class="params">(String travelWay)</span> </span>&#123;</span><br><span class="line">        TravelStrategy travelStrategy = travelStrategyFactory.createTravelStrategy(travelWay);</span><br><span class="line">        <span class="keyword">return</span> travelStrategy.calculateMinCost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码结构和我们上一节讲解的音乐推荐器几乎一模一样。看似也很好地解决了我们的设计问题。接下来我们看看如何用策略模式解决这个问题，然后我们再对两种模式做对比。</p>
<h3 id="策略模式实现电子地图"><a href="#策略模式实现电子地图" class="headerlink" title="策略模式实现电子地图"></a>策略模式实现电子地图</h3><p>使用策略模式，需要增加一个策略上下文类（<code>Context</code>）。<code>Context</code>类持有策略实现的引用，并且对外提供计算方法。<code>Context</code>类根据持有策略的不同，实现不同的计算逻辑。客户端代码只需要调用 <code>Context</code> 类的计算方法即可。如果想切换策略实现，那么只需要改变<code>Context</code>类持有的策略实现即可。<br><code>TravelStrategy</code> 接口和实现的代码不变，请参照上面工厂模式中给出的代码。其他代码如下：<br><code>StrategyContext</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TravelStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrategyContext</span><span class="params">(TravelStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.calculateMinCost();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>StrategyContext</code> 持有某种 <code>TravelStrategy</code> 的实现，它对外提供的calculateMinCost 方法，实际是对 <code>TravelStrategy</code> 做了一层代理。想切换不同算法的时候，只需更改 <code>StrategyContext</code> 持有的 <code>TravelStrategy</code> 实现。</p>
<p><code>TravelService</code> 对外提供计算方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TravelService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StrategyContext strategyContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinCost</span><span class="params">(String travelWay)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;selfDriving&quot;</span>.equals(travelWay)) &#123;</span><br><span class="line">            strategyContext = <span class="keyword">new</span> StrategyContext(<span class="keyword">new</span> SelfDrivingStrategy());</span><br><span class="line">        &#125; <span class="keyword">if</span> (<span class="string">&quot;bicycle&quot;</span>.equals(travelWay)) &#123;</span><br><span class="line">            strategyContext = <span class="keyword">new</span> StrategyContext(<span class="keyword">new</span> BicycleStrategy());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            strategyContext = <span class="keyword">new</span> StrategyContext(<span class="keyword">new</span> PublicTransportStrategy());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strategyContext.calculateMinCost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>TravelService</code> 中只会和 <code>Context</code> 打交道，初始化 <code>Context</code> 时，根据不同的出行方式，设置不同的策略。看到这里你是不是会有疑问，使用工厂模式消除了客户端代码的条件语句。怎么使用策略模式，条件语句又回来了？别急，我们继续向下看。</p>
<p>最后我们看一下策略模式的类图：</p>
<p><img src="https://s2.loli.net/2021/12/25/vwGqLMtXSf7PYse.jpg" alt="图片描述"></p>
<h2 id="策略模式优缺点"><a href="#策略模式优缺点" class="headerlink" title="策略模式优缺点"></a>策略模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>使用策略模式，可以根据策略接口，定义一系列可供复用的算法或者行为；</li>
<li>调用方只需要持有<code>Context</code>的引用即可。而无需知道具体的策略实现。满足迪米特法则；</li>
<li><code>Context</code> 在策略的方法之外可以做一些通用的切面逻辑。</li>
</ol>
<p>GOF的《设计模式》著作中认为策略模式可以消除一些条件语句，我对此持怀疑态度。正如上面的例子，虽然由于Context在初始化的时候已经指定了策略实现，在计算逻辑中不需要根据条件选择逻辑分支。但是，客户端代码在初始化Context的时候，如何判断应该传入哪个策略实现呢？其实在客户端代码或者别的地方还是缺少不了条件判断。所以这里消除条件语句，只是针对算法逻辑的条件判断。</p>
<p>第一个优点是策略模式解决的核心问题。但其实工厂模式也是可以做到的。第二点，我认为很重要，客户端代码只需要和 <code>Context</code> 打交道即可，避免了和不同策略类、工厂类的接触。工厂模式中，客户端代码需要知道工厂类和产品类，两个类。正好复习一下迪米特法则，如果两个类没有必要直接通信，那么两个类就没有必要相互作用。可以通过第三方来间接调用。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>客户端代码需要知道不同的策略以及如何选择策略。因此可以看到上面的客户端代码有着丑陋的条件判断；</li>
<li>由于策略类实现同样的接口，所以参数列表要保持一致，但可能并不是所有的策略都需要全部参数。</li>
</ol>
<h2 id="策略模式与工厂模式结合使用"><a href="#策略模式与工厂模式结合使用" class="headerlink" title="策略模式与工厂模式结合使用"></a>策略模式与工厂模式结合使用</h2><p>针对第一个缺点。我们可以通过策略模式与工厂模式结合使用来改进。通过进一步封装，消除客户端代码的条件选择。</p>
<p>我们修改一下StrategyContext类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TravelStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrategyContext</span><span class="params">(String travelWay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;selfDriving&quot;</span>.equals(travelWay)) &#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> SelfDrivingStrategy();</span><br><span class="line">        &#125; <span class="keyword">if</span> (<span class="string">&quot;bicycle&quot;</span>.equals(travelWay)) &#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> BicycleStrategy();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> PublicTransportStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.calculateMinCost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们初始化的逻辑和工厂的逻辑很相似。这样条件判断就提炼到 <code>Context</code> 类中了。而客户端代码将会简洁很多，只需要在初始化 <code>StrategyContext</code> 时，传入相应的出行方式即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TravelService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StrategyContext strategyContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinCost</span><span class="params">(String travelWay)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        strategyContext = <span class="keyword">new</span> StrategyContext(travelWay);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strategyContext.calculateMinCost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后，客户端代码现在已经完全不知道策略对象的存在了。条件判断也被消除了。其实很多时候我们都是通过搭配不同设计模式来达到我们的设计目标的。</p>
<p>策略+工厂模式类图如下：</p>
<p><img src="https://s2.loli.net/2021/12/25/JUNA1hgKBYbVztc.jpg" alt="图片描述"></p>
<h2 id="策略模式适用场景"><a href="#策略模式适用场景" class="headerlink" title="策略模式适用场景"></a>策略模式适用场景</h2><p>当存在多种逻辑不同，但属于同一类型的行为或者算法时，可以考虑使用策略模式。以此来消除你算法代码中的条件判断。同时让你的代码满足多种设计原则。</p>
<p>很多时候，工厂模式和策略模式都可以为你解决同类问题。但你要想清楚，你想要的是一个对象，还是仅仅想要一个计算结果。如果你需要的是一个对象，并且想用它做很多事情。那么请使用工厂模式。而你仅仅想要一个特定算法的计算结果，那么请使用策略模式。</p>
<p>策略模式属于对象行为模式，而工厂属于创建型模式。策略模式和工厂模式对比如下：</p>
<p><img src="https://s2.loli.net/2021/12/25/PcQ2CgKi7pqLUkO.jpg" alt="图片描述"></p>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>策略模式解决的问题是如何封装可供复用的算法或者行为。策略模式满足了单一职责、开闭、迪米特法则、依赖倒转等原则。我们一定想清楚策略模式的适用场景，否则某些时候你会搞不清到底用工厂模式还是策略模式。最后提醒大家，设计模式很多时候都是混合使用，我们不应该局限于使用某一种设计模式来解决问题。</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式是设计模式中最简单的设计模式之一。他和工厂模式同属于创建型模式，都用于类的实例化。不过两者的区别很大，要解决的问题也不一样。</p>
<p>单例模式保证一个类只会被实例化一次，使用的时候通过单例提供的方法来获取实例。在确保线程安全的前提下，很多时候我们只需要同一个类的一个实例即可，而不是在任何使用的地方都实例化一个新对象。新对象创建是有成本的，不但要花时间，而且占用内存。另外有的时候我们需要一个全局唯一的实例，比如计数器，全局多个计数器就会计数混乱不准确，如下图所示。单例模式就是为了实现全局一个实例的需求。</p>
<p><img src="https://s2.loli.net/2021/12/25/PFapAnr6TwbJSlv.jpg" alt="图片描述"></p>
<h2 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h2><p>实现单例模式，其实我们需要实现如下需求：</p>
<ol>
<li>提供获取实例的方法。此方法会控制全局仅有一个实例，而不会重复创建实例；</li>
<li>全局唯一的实例要有地方能存放起来；</li>
<li>不能随意通过new关键字创建实例。这样才能控制调用方只能用受控的方法来创建对象。</li>
</ol>
<p>针对以上三点需求我们需要做如下事情：</p>
<ol>
<li>编写一个获取实例的公有方法，已经创建过实例就直接返回实例，否则进行实例化；</li>
<li>实例化好的对象存哪里呢？存在类当中是最好的。这样不用引入新的类，而且也符合就近原则；</li>
<li>禁止通过new关键字初始化，只需要把无参构造方法私有化。此外不要添加任何有参数的构造方法。</li>
</ol>
<p>我们按照上面的思路实现第一版单例模式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonOne</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonOne singletonOne;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonOne <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonOne == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singletonOne = <span class="keyword">new</span> SingletonOne();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonOne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中使用静态变量，也称之为类变量保存<code>SingletonOne</code>的实例。无参构造方法私有化，并且不提供其他构造方法。getInstance() 对外提供获取实例的方法。方法内部也符合我们的需求，已经实例化，直接返回实例，如果还是null，去创建这个实例。<strong>这种方式称之为懒汉式，是因为类的实例化延迟到第一次getInstance的时候。</strong></p>
<p>看起来上面的代码实现了我们提到的三点需求，无懈可击。没错，一般的场景采用上面的代码足以应付。但是在并发的时候，上面的代码是有问题的。并发时，两个线程对于 singletonOne == null 的判断可能都满足，那么接下来每个线程各自都创建了一个实例。这和单例模式的目标是相违背的。我们需要改造一下。</p>
<h3 id="线程安全的懒汉单例模式"><a href="#线程安全的懒汉单例模式" class="headerlink" title="线程安全的懒汉单例模式"></a>线程安全的懒汉单例模式</h3><p>想要线程安全还不好说，加上 Synchronized 关键字就可以了。修改后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTwo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonTwo singletonTwo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTwo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonTwo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonTwo.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singletonTwo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonTwo = <span class="keyword">new</span> SingletonTwo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonTwo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化之前为了确保线程安全，我们加上了 synchronized 关键字。你肯定注意到 synchronized 代码块中，又判断了一次 singletonTwo 是否为 null。这是因为你在等待锁的这段时间，可能其他线程已经完成了实例化。所以此处加上 null 的判断，才能确保全局唯一！</p>
<p>看到这里你一定赞叹，这是多么严谨的程序，一定不会有错了！但是事实却不是这样。</p>
<p>如果你学习过多线程，一定对重排序有印象。CPU 为了提高运行效率，可能会对编译后代码的指令做优化，这些优化不能保证代码执行完全符合编写的顺序。但是一定能保证代码执行的结果和按照编写顺序执行的结果是一致的。重排序在单线程下没有任何问题，不过多线程就会出问题了。其实解决方法也很简单，只需要为</p>
<p>singletonTwo 声明时加上 volatile 关键字即可。volatile 修饰的变量是会保证读操作一定能读到写完的值。这种单例也叫做双重检查模式。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTwo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonTwo singletonTwo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTwo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonTwo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonTwo.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singletonTwo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonTwo = <span class="keyword">new</span> SingletonTwo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonTwo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><p>有懒汉就有饿汉。饿汉式单例模式在类初实话的时候就会进行实例化。好处是不会有线程安全的问题。问题就是不管程序用不用，实例都早以创建好，这对内存是种浪费。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonThree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonThree singletonOne = <span class="keyword">new</span> SingletonThree();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonThree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonThree <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singletonOne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="内部静态类方式"><a href="#内部静态类方式" class="headerlink" title="内部静态类方式"></a>内部静态类方式</h3><p>这次我们先看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFour</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonFour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonFour <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singletonFour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonFour singletonFour = <span class="keyword">new</span> SingletonFour();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中增加了内部静态类 <code>SingletonHolder</code>，内部有一个<code>SingletonFour</code>的实例，并且也是类级别的。那这种方式是饿汉式还是懒汉式？看起来像是饿汉式，因为实例化也是在类初实话的时候进行的。但如果是饿汉式，为什么还要兜这个圈？</p>
<p>其实这是懒汉式。因为内部静态类是现在第一次使用的时候才会去初始化。所以<code>SingletonHolder</code>最初并未被初始化。当第一次执行 return SingletonHolder.singletonFour 时，才会去初始化<code>SingletonHolder</code>类，从而实例化<code>SingletonFour</code>。这种方式利用类加载的机制达到了双重检查模式的效果，而代码更为简洁。</p>
<h2 id="单例模式适用场景"><a href="#单例模式适用场景" class="headerlink" title="单例模式适用场景"></a>单例模式适用场景</h2><ol>
<li>必须保证全局一个实例。如计数器，多个实例计数就不准确了。再比如线程池，多个实例的话，管理就乱套了。</li>
<li>一个实例就能满足程序不同地方的使用，并且是线程安全的。比如我们使用 Spring 开发的 bean，绝大多数都可以用单例模式。例如某个 service 类，因为自己不维护状态，线程安全，其实全局只需要一个实例。</li>
<li>对象被频繁创建和销毁，可以考虑使用单例。</li>
<li>对象创建比较消耗资源。</li>
</ol>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>我们本节学习了四种单例的实现方式：</p>
<ol>
<li>饿汉式非线程安全；</li>
<li>懒汉式线程安全（双重检查模式）；</li>
<li>饿汉式单例模式；</li>
<li>内部静态类方式。</li>
</ol>
<p>单例模式虽然简单，但是想写的严谨，还是需要考虑周全。实际使用中，推荐使用双重检查模式和内部静态类方式。如果实例在你的程序初始化阶段就会被使用，也可以使用饿汉式。非线程安全的懒汉式只能用于非并发的场景，局限性比较大，并不推荐使用。</p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式又称为委托模式。代理模式从字面上很好理解，有些事情你可以不必亲自去做，而是通过更为专业的人或者机构去做。比如你开公司需要工商注册。你可以选择自己去了解相关的规章制度，亲自跑腿去办理。也可以通过专业机构办理。这样你就不需要去了解办理的细节，只需把材料交给机构。机构会为你完成注册工作。在这个过程中，机构不但会为你完成机构注册，而且还有可能为你办理一些你并不知道的增值服务。这就是典型的代理模式。</p>
<h2 id="实现代理模式"><a href="#实现代理模式" class="headerlink" title="实现代理模式"></a>实现代理模式</h2><p>我们再看一个生活中的例子。房屋买卖中经常会出现代理的情况。当卖家不在房屋所在地时，可能会委托自己的亲人或者朋友进行交易。而买方会和代理人直接进行交易。交易中间的问题代理人会回答，手续代理人会办理。如下图：</p>
<p><img src="https://s2.loli.net/2021/12/25/Cmk27jEQHARZByK.jpg" alt="图片描述"><br>这个代理人不太老实，私自加了20万，想赚差价。所以不要以为代理人真的只是代理，在这个过程中他可以加入自己的逻辑处理。而客户和被代理人并不知道。</p>
<p>我们看看采用代理模式如何实现这个场景。</p>
<p>首先真正卖掉房子的还是房主，只不过和买房人直接进行买卖的是代理人。那么房主和代理人有一个公共的行为都是卖房。那么我们可以抽象出一个接口定义卖房的行为。房主和代理人都需要实现这个接口。真正的卖房逻辑在房主的实现中，代理人的卖房实现只是调用房主的实现而已。要达到这个目的，代理人需要持有房主的引用。而买方进行买卖的时候，仅和代理人打交道。不用知道房主是谁，也不用让房主到现场过户。甚至连房主身在何处都不知道。</p>
<p>上面其实就是这个例子的程序设计。代码如下：</p>
<p>房屋交易接口代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RealEstate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>房主代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Seller</span> <span class="keyword">implements</span> <span class="title">RealEstate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;卖了房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理人代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellerProxy</span> <span class="keyword">implements</span> <span class="title">RealEstate</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Seller seller;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(seller==<span class="keyword">null</span>)&#123;</span><br><span class="line">            seller = <span class="keyword">new</span> Seller();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seller.sell();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;退税办理完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类图：</p>
<p><img src="https://s2.loli.net/2021/12/25/Ac3kMvyqCsYUraW.jpg" alt="图片描述"><br>代理人在这里有什么用处呢？没有代理人，直接和房主买就好了啊？试想下，假如现在有了新的买房政策，交易完成后可以退税，那么在不修改房主代码的前提下，我们只需要修改此代理人的代码即可。如果在其他地方卖房没有此政策，只需要定义另外一个地区的代理人即可，这里实现了开闭原则。其实代理模式还有很多好处和适用的场景。我们下面详细来看。</p>
<h2 id="代理模式优缺点"><a href="#代理模式优缺点" class="headerlink" title="代理模式优缺点"></a>代理模式优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>代理模式在客户端代码和真正的逻辑代码中引入了一层代理，这样做有很多好处：代理模式</p>
<ol>
<li>隐藏逻辑的真正实现对象。上面的例子中，如果卖房人身份特殊，那么通过代理人来卖房，可以不让买房人接触到自己；</li>
<li>隐藏委托类的某些行为，在代理类认为应该触发时再触发；</li>
<li>代理类可以为委托类的行为附加一些逻辑处理，例如上例中的退税。</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>代理类和委托类实现同一个接口，因此只能面向接口代理；</li>
<li>代理类和委托类实现同一个接口。即使代理类只想代理某个行为，也需要实现接口所有方法；</li>
<li>代理类和委托类需要一一对应。如果你有段逻辑需要对所有的方法都附加上，静态代理是无法实现的。</li>
</ol>
<h2 id="代理模式适用场景"><a href="#代理模式适用场景" class="headerlink" title="代理模式适用场景"></a>代理模式适用场景</h2><p>针对代理模式的三个优点，我们来看看有哪些适用场景。</p>
<ol>
<li><strong>远程调用代理</strong>：在分布式系统中，我们经常会调用其他系统的服务。通过代理模式，可以对客户端代码隐藏远程调用的细节；</li>
<li><strong>虚代理</strong>：有一个典型的场景，加载一个包含大量大 size 图片的页面时，为了更好的用户体验，可以通过图片代理类先把图片的位置占好，保证排版的正确。当滚动到某个图片位置的时候才去加载图片；</li>
<li><strong>保护代理</strong>：当委托对象需要访问权限控制时，可以通过代理类来控制权限进行保护；</li>
<li><strong>智能指引</strong>：为委托对象增加一层控制。比如记录访问次数，当为 0 的时候，可以释放掉。第一次引用一个对对象时，把它装入内存。访问委托对象前，检查是否已经有其他访问已经锁定了它，以确保其他对象不能改变它。</li>
</ol>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>代理模式由 <code>Suject</code> 接口，<code>RealSubject</code> 实现和 <code>Proxy</code> 类构成。<code>Proxy</code> 类同样要实现 <code>Suject</code> 接口。同时 <code>Proxy</code> 类依赖 <code>RealSubject</code> 类。代理模式对方的调用增加了间接性。利用间接性，可以加入额外的逻辑。这也是我们常说的 AOP，即面向切面编程。</p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器在生活中无处不在，比如电脑的转接头、读卡器、电源转接头。他们的共同点就是接口标准不一样，需要通过适配器转换后才能使用。就拿读卡器来说，存储卡的接口只能适配相机或者手机的卡槽。而电脑普遍为 USB 接口。那么如何在电脑上使用存储卡呢？我们可以用读卡器，一头卡槽能够插入存储卡，另一头 USB 可以插在电脑上。通过适配器可以解决接口不兼容的问题。还有个例子就是电脑的变压器，电脑一般接收20V电压，但是我国电压是220V，因此就需要变压器做转换，如下图所示，进来是220V，出来被转为20V。变压器其实就是适配器。<br><img src="https://s2.loli.net/2021/12/25/iEYMwD6auF7JvgU.jpg" alt="图片描述"></p>
<h2 id="实现适配器模式"><a href="#实现适配器模式" class="headerlink" title="实现适配器模式"></a>实现适配器模式</h2><p>我们通过如下例子，来看看如何实现适配器模式。假如我们的电视机屏幕输出为 4K 画质，但播放器只能输出 2K 的画质，此时就需要一个适配器完成 2K 到 4K 的转换。代码如下：</p>
<p>只能输出 2k 信号的 <code>player</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TwoThousandSignal <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TwoThousandSignal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义一个更为现代的播放器的接口，输出 4K 信号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ModernPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function">FourThousandSignal <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口的实现就是一个适配器（ adapter ），通过复用 Player 输出的 2K 信号，转化为 4K 信号，让支持 <code>ModernPlayer</code> 的设备来播放 2K 信号源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModernPlayerAdapter</span> <span class="keyword">implements</span> <span class="title">ModernPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Player player = <span class="keyword">new</span> Player();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FourThousandSignal <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TwoThousandSignal twoThousandSignal = player.play();</span><br><span class="line">        <span class="keyword">return</span> convertToFourThousandSignal(twoThousandSignal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> FourThousandSignal <span class="title">convertToFourThousandSignal</span><span class="params">(TwoThousandSignal twoThousandSignal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//4k信号通过算法计算，从2k转换而来。省略转换逻辑，</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FourThousandSignal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>电视机作为调用方，只需要使用 <code>ModernPlayerAdapter</code> 的实例就可以播放 2K 信号，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ModernPlayer modernPlayer = <span class="keyword">new</span> ModernPlayerAdapter();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        modernPlayer.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看代码是不是很像代理模式？<code>ModernPlayerAdapter</code> 只是调用了Adaptee的方法，获得 2k 信号后转换为 4K 信号。区别在于 <code>Player</code> 并没有实现 <code>ModernPlayer</code> 接口。而代理模式，<code>Proxy</code> 和 <code>RealSubject</code> 是都需要实现同一个接口的。<code>Adapter</code> 的作用是适配不同接口，两个接口的返回值是不同的，<code>Adapter</code> 中需要实现转换逻辑。</p>
<p>类图：</p>
<p><img src="https://s2.loli.net/2021/12/25/kqEy18UDmpBYKHW.jpg" alt="图片描述"></p>
<h2 id="适配器模式优点"><a href="#适配器模式优点" class="headerlink" title="适配器模式优点"></a>适配器模式优点</h2><ol>
<li>不需要修改现有的接口和实现，就能复用已有的类；</li>
<li>灵活度高，可以在接口不变的情况下，兼容多种不同的类。</li>
</ol>
<h2 id="适配器模式适用场景"><a href="#适配器模式适用场景" class="headerlink" title="适配器模式适用场景"></a>适配器模式适用场景</h2><ol>
<li>想要使用一个已有的类，但是此类的接口并不符合使用方要；</li>
<li>多个类做的事情相同或者类似，但是各自接口又不同。调用方希望统一接口。</li>
</ol>
<p>第一个场景可以认为是亡羊补牢。由于种种原因造成系统接口不同，但功能却类似。此时很可能我们不能直接修改已经存在的接口，我们只能通过适配器模式去适配这个接口。</p>
<p>第二个场景其实也很常见。比如我们开发一个比价网站，需要从不同网站抓取同类商品的价格，然后按照自己系统的数据结构保存。不同网站抓取到的数据肯定是不同的，可能字段名不一样，也可能数据结构都不同。但是最终都要保存为同样的数据结构，此时就需要适配器来做转换。</p>
<h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>当我们面对难以改造，又想复用的对象时，可以考虑采用适配器模式。但切记一定不要滥用适配器。我们应该在最初设计程序的时候就考虑代码的可扩展性。而不是最后通过适配器来解决问题。能修改重构的，尽量去修改。实在不能修改的，比如外部系统的接口，我们就只能通过适配器模式来解决问题。</p>
<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>每天我们出门前，一定都会选择今天上衣穿什么，裤子穿什么，搭配什么鞋子，大衣穿什么。最后一定是做好选择，打扮好才会出门。这个过程其实就是装饰者模要做的事情 —- 对一个对象增加额外的功能。</p>
<p>我们再看一个例子。我们都吃过煎饼，除了面饼之外，我们还要加鸡蛋、加葱花、香菜、面酱、辣酱。现在还有新花样，加辣条、加鸡柳。一切都始于一张面饼，摊煎饼的过程就是在不断对这张面饼添加新特性。</p>
<p><img src="https://s2.loli.net/2021/12/25/NmQ6PKh3LjCuqGF.jpg" alt="图片描述"></p>
<p>我们通过继承也可以为对象增加功能，比如我们有个煎饼的父类，默认已经有面饼、面酱、鸡蛋啊。那么我们可以派生出 全都放的普通煎饼、不辣的普通煎饼、不辣不放香菜的普通煎饼、不辣不放葱的普通煎饼、全都放的辣条煎饼、全都放的鸡柳煎饼…… 这只是很小一部分。通过继承的话，由于情况太多，会造成对象爆炸。</p>
<p>那我们还可以通过组合的方式来扩展类啊，比如煎饼对象中，我们可以设置不同属性，比如是否有葱、是否有香菜、是否有辣条、是否有鸡柳等等。这样看起来也能很好的解决摊煎饼的问题。但如果想要加肠、加油条怎么办？想要加两个鸡蛋怎么办？我们只能修改煎饼对象。这就违反了开闭原则。显然这样也是不够灵活的。</p>
<p>装饰者模式能够很好的解决对象的动态扩展，不管你想穿什么，都可以随便搭配。不过这个煎饼要怎么做，也都能随意的扩展支持，而不需要改已有的代码。接下来我们就来看看如何通过装饰者模式来摊煎饼的。</p>
<h2 id="实现装饰者模式"><a href="#实现装饰者模式" class="headerlink" title="实现装饰者模式"></a>实现装饰者模式</h2><p>对于摊煎饼来说，我们都是对于一个基础的煎饼对象做装饰，比如我想要一套两个鸡蛋、有辣椒、葱、辣条的煎饼，那么我只需要先声明一个基本的煎饼对象，然后用加鸡蛋装饰类装饰它，然后再用加辣酱装饰类装饰它，再用加葱的装饰类装饰它，最后再用加辣条的装饰类装饰它。最终就得到了我想要的煎饼。不过请注意，不管你怎么装饰，最终得到的还是煎饼，并不是其他东西。</p>
<p>装饰者模式的核心思想是<strong>对已有的对象，一层一层的用装饰类去装饰它，扩展它的特性</strong>。这样做可以更为动态的为对象增加功能。我们看看代码如何实现：</p>
<p>先定义煎饼接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pancake</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口里只定义了一个制作方法。</p>
<p>煎饼接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicPancake</span> <span class="keyword">implements</span> <span class="title">Pancake</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加一勺面&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;加一个鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为一个最基本的煎饼，总得有面，有鸡蛋吧。其他的材料留给装饰类来实现。</p>
<p>接下来我们定义装饰抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PancakeDecorator</span> <span class="keyword">implements</span> <span class="title">Pancake</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Pancake pancake;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPancake</span><span class="params">(Pancake pancake)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pancake = pancake;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pancake != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pancake.cook();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>PancakeDecorator</code> 同样要实现 <code>Pancke</code> 接口。并且持有 <code>Pancke</code> 类型的引用，自己实现的 cook 方法实际调用了持有的 <code>Pancake</code> 对象的 cook 方法。</p>
<p>加辣酱的装饰类代码如下，其他装饰实现类是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddSpicyDecorator</span> <span class="keyword">extends</span> <span class="title">PancakeDecorator</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.cook();</span><br><span class="line">        System.out.println(<span class="string">&quot;加辣酱&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cook 方法首先调父类的 cook 方法，然后再加入自己的特性。</p>
<p>客户端代码如下，我们看看如何利用装饰类来生成你想要的煎饼。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pancake pancake = <span class="keyword">new</span> BasicPancake();</span><br><span class="line">        PancakeDecorator addEggPancake = <span class="keyword">new</span> AddEggDecorator();</span><br><span class="line">        addEggPancake.setPancake(pancake);</span><br><span class="line"></span><br><span class="line">        PancakeDecorator addSaucePancake = <span class="keyword">new</span> AddSauceDecorator();</span><br><span class="line">        addSaucePancake.setPancake(addEggPancake);</span><br><span class="line"></span><br><span class="line">        PancakeDecorator addLaTiaoPancake = <span class="keyword">new</span> AddLaTiaoDecorator();</span><br><span class="line">        addLaTiaoPancake.setPancake(addSaucePancake);</span><br><span class="line"></span><br><span class="line">        addLaTiaoPancake.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们声明了三个包装类，对 <code>BasicPancake</code> 层层包装，最后得到一套两个鸡蛋、加辣酱、加辣条的煎饼。运行后输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加一勺面</span><br><span class="line">加一个鸡蛋</span><br><span class="line">加一个鸡蛋</span><br><span class="line">加面酱</span><br><span class="line">加辣条</span><br></pre></td></tr></table></figure>

<p>如果你研发了新煎饼，要加新的辅料，比如香肠、榨菜之类，那么只需要增加装饰类的实现即可。从而实现了开闭原则。</p>
<p>类图如下：</p>
<p><img src="https://s2.loli.net/2021/12/25/tWRvOcPXqKAnSpH.jpg" alt="图片描述"></p>
<h2 id="装饰者模式优缺点"><a href="#装饰者模式优缺点" class="headerlink" title="装饰者模式优缺点"></a>装饰者模式优缺点</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>动态的为对象添加额外职责</strong>：通过组合不同装饰类，非常灵活的为对象增加额外的职责；</li>
<li><strong>避免子类爆炸</strong>：当不同的特性组合，构成不同的子类时，必然造成子类爆炸。但通过装饰者灵活组合，可以避免这个问；</li>
<li><strong>分离核心功能和装饰功能</strong>：核心业务保留在 <code>Component</code> 的子类中。而装饰特性在 <code>Decorator</code> 的实现类中去实现。面对装饰特性的变化，实现了开闭原则，只需要增加装饰实现类；</li>
<li><strong>很方便的重复添加特性</strong>：我想要一套两个鸡蛋，双份辣条的煎饼。是不是只需要多装饰一次就可以了？就是这么简单。</li>
</ol>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>由于不是通过继承实现添加职责，所以被装饰后的对象并不能通过对象本身就能了解其特性。而需要分析所有对其装饰过的对象；</li>
<li>装饰模式会造成有很多功能类似的小对象。通过组合不同的装饰实现，来达成不同的需求。这样对于不了解系统的人，比较难以学习。过多的装饰类进行装饰，也稍显繁琐。</li>
</ol>
<h2 id="装饰者模式适用场景"><a href="#装饰者模式适用场景" class="headerlink" title="装饰者模式适用场景"></a>装饰者模式适用场景</h2><p>使用装饰者模式，有以下几种情况：</p>
<ol>
<li>需要一个装饰的载体。不能将全部特性都放在装饰类中。换句话讲得有个装饰主体，核心特性在主体对象中实现。例如浏览器窗口，不管是加边框还是滚动条，都是基于窗口的；</li>
<li>有多种特性可以任意搭配，对主体进行扩展。并且你想以动态、透明的方式来实；</li>
<li>不能以生成子类的方式扩展。可能有两种情况，一是对大量子类带来的类爆炸有所顾虑。二是类定义被隐藏，或者不能用于生成子类。</li>
</ol>
<h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>装饰者模式的优势在于动态、透明的添加特性。要记住装饰者装饰完的对象还是之前的对象类型。通过分离核心特性和装饰特性，客户端代码可以灵活的搭配使用包装对象，从而得到具有想要行为的对象。不过要注意，有些时候装饰的顺序是要保证的。比如先放鸡蛋，再放芝麻，芝麻就不会掉下去了。最好的做法是保证装饰类的独立。</p>
<h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><p>我先问个问题，把大象放冰箱，总共分几步？你一定脱口而出：三步！第一步把冰箱门打开，第二步把大象放进去，第三部把冰箱门关上。这道题是不是太简单了？但当我们考虑细节的时候就没这么简单了。</p>
<p>假如你的冰箱门加了锁，那么第一步开门时就需要开锁。第二步把大象放进去也有细节要考虑。如果你的冰箱是卧式的，那么大象需要躺在里面。如果你的冰箱是立式的，那么大象可以站在里面。像这种<strong>主体逻辑一样，细节实现不同的场景，我们可以考虑使用模版方法模式</strong>。</p>
<p><img src="https://s2.loli.net/2021/12/25/r4uTlRdz7eg2tmw.jpg" alt="图片描述"></p>
<p>在软件建模中，把大象放冰箱是一个算法，我们将其定义为一个模版方法。<strong>模版方法用一系列抽象的操作定义一个算法</strong>。就像我们例子中的三步，打开冰箱、大象放进去、关上冰箱门。具体如何开门和关门，如何放大象进去，则在子类中实现。冰箱不同，采用的方式自然也不同。</p>
<p>模版方法中定义操作的方法和先后步骤。而真正的操作方法实现则在子类中。</p>
<h2 id="实现模版方法"><a href="#实现模版方法" class="headerlink" title="实现模版方法"></a>实现模版方法</h2><p>我们看看用代码如何实现把大象放冰箱。为了便于理解，我们尽量少引入类，我们假设冰箱自身有个行为是把大象放进来</p>
<p>冰箱抽象类 <code>Fridge</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fridge</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeElephant</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始装大象&quot;</span>);</span><br><span class="line">        openDoor();</span><br><span class="line">        putElephant();</span><br><span class="line">        closeDoor();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">openDoor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">putElephant</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">closeDoor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Fridge</code> 类中定义了一个模版方法 placeELephan， 里面按照顺序调用 openDoor、putELephant、closeDoor。这三个方法留待子类实现。</p>
<p>下面是两个具体的冰箱实现类代码。</p>
<p>立式冰箱类 <code>VerticalFridge</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerticalFridge</span> <span class="keyword">extends</span> <span class="title">Fridge</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开立式冰箱门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putElephant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;将大象站着放进去&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关上立式冰箱门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>卧式冰箱 <code>HorizontalFridge</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorizontalFridge</span> <span class="keyword">extends</span> <span class="title">Fridge</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开卧式冰箱门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putElephant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;将大象躺着放进去&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关上卧式冰箱门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个冰箱子类各自实现三个抽象方法。</p>
<p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fridge fridge;</span><br><span class="line"></span><br><span class="line">        fridge = <span class="keyword">new</span> HorizontalFridge();</span><br><span class="line">        fridge.placeElephant();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------I&#x27;m a line-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fridge = <span class="keyword">new</span> VerticalFridge();</span><br><span class="line">        fridge.placeElephant();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码中，两个不同的子类分表调用了placeElephant 方法，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">开始装大象</span><br><span class="line">打开卧式冰箱门</span><br><span class="line">将大象躺着放进去</span><br><span class="line">关上卧式冰箱门</span><br><span class="line">结束</span><br><span class="line">---------I&#39;m a line-----------</span><br><span class="line">开始装大象</span><br><span class="line">打开立式冰箱门</span><br><span class="line">将大象站着放进去</span><br><span class="line">关上立式冰箱门</span><br><span class="line">结束</span><br></pre></td></tr></table></figure>

<p>两个子类开始和结束的步骤一样，中间步骤的顺序也一样。这些逻辑在父类中实现。每个步骤具体的逻辑则在子类中各自实现。</p>
<p>类图：</p>
<p><img src="https://s2.loli.net/2021/12/25/l5BUH36VihFzsrK.jpg" alt="图片描述"></p>
<h2 id="模版方法优缺点"><a href="#模版方法优缺点" class="headerlink" title="模版方法优缺点"></a>模版方法优缺点</h2><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>分离了算法中变和不变的部分。不变的部分定义在父类的模版方法中。变的部分通过子类实现。不变的算法部分可以被充分复用。当变的部分有新需求时，可以定义新的子类。从而实现了开闭原则。</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>模版意味着死板，我们设定好模版就必须按照模版的一、二、三步来执行。如果我们想调换顺序，或者增加几步就很难做到。除非定义新的模版。或者很小心的改动已有模版，避免影响现有程序逻辑。但这已经违反了开闭原则。</p>
<h2 id="模版方法适用场景"><a href="#模版方法适用场景" class="headerlink" title="模版方法适用场景"></a>模版方法适用场景</h2><p>如果我们发现一系列的算法，主干一样，只是在局部的实现上有区别。此时我们可以考虑使用模版方法。把算法主干及不变的部分提炼出来，在父类中实现。抽象出变化部分的方法，交由不同的子类自己去实现。</p>
<h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><p>一般来说我们都是在子类中调用父类的方法。而模版方法恰恰相反，是父类的方法中调用子类的实现。正是因为这样，我们才能把不变的行为抽象到父类中，变化的部分留给子类实现。此外还有一类方法叫做钩子方法，它不是抽象的方法，父类有其缺省实现，一般是空方法。但是子类也可以通过重写去覆盖。</p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式也称为订阅者模式，实际上我觉得订阅者更容易理解。这种设计模式在生活中很常见。比如订阅期刊杂志、定牛奶等等。我们使用的软件中也很常见。比如说微博，你关注了某位明星，其实你就是他的观察者。每当你关注的明星发了新的动态，你就会接收到通知。观察者模式基于发布订阅的方式。订阅者订阅目标对象，目标对象维护订阅者的集合。一旦目标对象状态变化，需要通知所有订阅者，从而触发订阅者的某个行为。</p>
<h2 id="实现观察者模式"><a href="#实现观察者模式" class="headerlink" title="实现观察者模式"></a>实现观察者模式</h2><p>实现观察者模式，在目标对象中需要维护所有他的观察者引用。观察者可以观察多个不同目标对象的，所以需要让观察者知道是哪个目标对象发送的通知。下面我们通过一个简单的例子来看看如何实现观察者模式。</p>
<p>这个例子叫老师点名了。上大学时候，经常有同学旷课在宿舍打游戏，并且嘱咐去上课的同学，老师要是点名了给我打电话。还好宿舍离教学楼近，接到通知的同学赶紧跑去教室也能赶上。有的胆子大点的同学，接到通知后也不去上课，而是找个关系好的同学帮忙喊声到。</p>
<p>去上课的同学是通知者（目标对象），他持有所有需要他通知老师点名的同学（观察者）的引用，才能在老师点名的时候通知到每个人。程序中我们一般用容器存储观察者。当通知的时候循环调用所有观察者暴露出的更新方法。</p>
<p>“老师点名了” 目标对象代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherRollCallSubject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        observers.forEach(Observer::update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察者只需要实现一个方法，供通知者做通知的时候调用。我们先定义观察者的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义第一类观察者的实现，他接到通知后，会马上去教室。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GotoClassObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师点名了！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;我要马上赶到教室去！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二类观察者，接到通知后，会通知自己的好朋友帮自己答到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AskForHelpObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师点名了！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;赶紧给XX发信息，让他替我答到！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码中，分别声明两个不同的观察者，然后让这两个观察者都观察老师点名了目标对象。最后出发目标对象的通知方法。客户端代码如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observer studentOne = <span class="keyword">new</span> GotoClassObserver();</span><br><span class="line">        Observer studentTwo = <span class="keyword">new</span> AskForHelpObserver();</span><br><span class="line"></span><br><span class="line">        TeacherRollCallSubject subject = <span class="keyword">new</span> TeacherRollCallSubject();</span><br><span class="line">        subject.addObserver(studentOne);</span><br><span class="line">        subject.addObserver(studentTwo);</span><br><span class="line"></span><br><span class="line">        subject.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">老师点名了！</span><br><span class="line">我要马上赶到教室去！</span><br><span class="line">老师点名了！</span><br><span class="line">赶紧给XX发信息，让他替我答到！</span><br></pre></td></tr></table></figure>

<p>可以看到每个观察者都接到了通知，并且按照自己实现的响应方式作出不同的逻辑处理。第一个同学会赶到教室。第二个同学则是给好朋友发信息，让其替他答到。</p>
<h2 id="观察者模式优缺点"><a href="#观察者模式优缺点" class="headerlink" title="观察者模式优缺点"></a>观察者模式优缺点</h2><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><p>1、目标对象状态的变化，不需要观察者真的一直观察。当存在大量观察者时，如果所有的观察者都去轮询状态，那么系统资源的消耗极大。而观察者模式避免了这种情况；</p>
<p>2、观察者模式支持广播，状态变化时，目标对象的所有观察者都会得到通知；</p>
<p>3、符合开闭原则，目标对象依赖的是观察者的接口，可以很方便的对观察者进行扩展，而不需要修改已有观察者。反过来观察者也是依赖的目标接口。</p>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>观察者模式中，观察者接口限定了方法签名。有一定的局限性。</p>
<h2 id="观察者模式适用场景"><a href="#观察者模式适用场景" class="headerlink" title="观察者模式适用场景"></a>观察者模式适用场景</h2><p>1、抽象模型可以分为两个部分，一部分行为取决于另外一部分状态的变化。并且你想让这两部分各自独立。每部分都可以独自使用和复用；<br>2、一个对象的变化，需要通知其他对象，并且有多少对象需要通知并不清楚<br>3、你想让通知与被通知双方松耦合。</p>
<h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>观察者模式最大的优点就是把目标和观察者解耦，观察者根据目标对象状态的变化作出响应。而目标者可以把自己状态变化广播给所有注册的观察者。实际使用中有推/拉两种模型。</p>
<ul>
<li>在推模型中，目标对象会把状态改变相关的所有信息推送出去，信息的量有可能会很大。</li>
<li>在拉模型中，目标对象只推送出最核心的信息，比如变化的数据 id。</li>
</ul>
<p>观察者收到消息后再决定如何处理，比如查询与变化相关的自己感兴趣的数据。推模型，目标对象需要知道所有观察者对数据的需求。而拉模型效率会比较差，观察者收到消息后，还需要自己再去获取改变的内容。关于推拉模型总结如下：</p>
<p><img src="https://s2.loli.net/2021/12/25/6p8e2sYS7CAgXFd.jpg" alt="图片描述"></p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式用来解决产品族的实例化问题。比如说现在有个家居设计软件，通过软件模拟房间，摆放各种虚拟的家具，看效果如何。我们可以放入电视柜、茶几、餐桌、床等等。这一系列的家具就叫做产品族。产品族面临的问题是，当一个产品族切换到另外一个产品族时，如何让代码的修改最小。也就是说如何做到开闭原则。</p>
<p>想把设计好的方案从简约现代切换到欧式风格家具，怎么才能做到修改最小？如果采用简单工厂，那么每种产品都对应一个工厂，工厂负责产出不同风格的产品。设计方案中用到 n 种产品就要修改 n 处代码。这显然不是最佳的方法。此时，我们需要抽象工厂模式来解决这个问题。抽象工厂模式中，每个工厂的实现负责生产自己产品族的产品。示意图如下：</p>
<p><img src="https://s2.loli.net/2021/12/25/oKI5FBfbXTkEmGv.jpg" alt="图片描述"></p>
<h2 id="实现抽象工厂"><a href="#实现抽象工厂" class="headerlink" title="实现抽象工厂"></a>实现抽象工厂</h2><p>为了便于理解和展示，我们假设只有两种家具—-椅子和桌子。</p>
<p>首先定义每种家具的接口，只有一个方法用来获取家具说明。</p>
<p>椅子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Chair</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getChairIntroduction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>桌子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Desk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getDeskIntroduction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以椅子为例，我们分别实现简约现代和欧式两种风格。<br>简约现代风格椅子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModernStyleChair</span> <span class="keyword">implements</span> <span class="title">Chair</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChairIntroduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个现代简约风格的椅子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>欧式风格椅子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EuropeanStyleChair</span> <span class="keyword">implements</span> <span class="title">Chair</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChairIntroduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个欧式风格的椅子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>桌子也有两种实现，代码这里省略。</p>
<p>产品我们已经编写完成。接下来我们来看看工厂的代码。</p>
<p>首先我们定义一个家具工厂接口，可以生产椅子和桌子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FurnitureFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Chair <span class="title">createChair</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Desk <span class="title">createDesk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们支持两种不同的风格，所以我们编写两个实现类。</p>
<p>简约风格家具工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModernFurnitureFactory</span> <span class="keyword">implements</span> <span class="title">FurnitureFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Chair <span class="title">createChair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModernStyleChair();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Desk <span class="title">createDesk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModernStyleDesk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>欧式风格家具工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EuropeanFurnitureFactory</span> <span class="keyword">implements</span> <span class="title">FurnitureFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Chair <span class="title">createChair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EuropeanStyleChair();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Desk <span class="title">createDesk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EuropeanStyleDesk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，每种工厂各自实现如何生产两种不同的家具。</p>
<p>客户端代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FurnitureFactory furnitureFactory = <span class="keyword">new</span> EuropeanFurnitureFactory();</span><br><span class="line">        Chair chair = furnitureFactory.createChair();</span><br><span class="line">        Desk desk = furnitureFactory.createDesk();</span><br><span class="line"></span><br><span class="line">        chair.getChairIntroduction();</span><br><span class="line">        desk.getDeskIntroduction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码中，我们实例化的是欧式家具工厂，那么所生产的椅子和桌子应该是欧式风格。执行后输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个欧式风格的椅子</span><br><span class="line">这是一个欧式风格的桌子</span><br></pre></td></tr></table></figure>

<p>和我们的预期相符。如果想要更换产品族，从现代简约切换到欧式，我们只需要修改一处代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FurnitureFactory furnitureFactory = <span class="keyword">new</span> ModernFurnitureFactory();</span><br></pre></td></tr></table></figure>

<p>仅通过更换抽象工厂的实现即可实现。修改后执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个现代简约风格的椅子</span><br><span class="line">这是一个现代简约风格的桌子</span><br></pre></td></tr></table></figure>

<p>可以看到已经切换到简约风格的产品族。这个过程中并不需要改任何产品使用的代码。</p>
<p>如果增加别的风格产品族，只需要新建新风格的产品族产品，增加新风格产品族的工厂实现即可。<br>类图：</p>
<p><img src="https://s2.loli.net/2021/12/25/feVnaM4d2zNA65X.jpg" alt="图片描述"></p>
<h2 id="抽象工厂优缺点"><a href="#抽象工厂优缺点" class="headerlink" title="抽象工厂优缺点"></a>抽象工厂优缺点</h2><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>分离了产品类和客户端类</strong>：客户端只依赖抽象的产品接口。此外，如何生产产品被封装在工厂内部；</li>
<li><strong>方便切换产品族</strong>：客户端代码只需要初始化一次工厂实现。这意味着在切换产品族的时候，只需要修改一行代码，换一个工厂实现即可；</li>
<li><strong>保证产品的一致性</strong>：使用抽象工厂，可以保证你从相同工厂生产的产品都属于同一个产品族。不会出现椅子是现代简约风格，而桌子是欧式风格的情况。</li>
</ol>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><p>添加新的产品时，改动较多。例子从两个维度定义产品，一是不同产品，比如桌子、椅子。另外是不同族，例如现代简约和欧式。使用抽象工厂，优化了产品族，也就是第二个维度变化的难度。但是当添加新的产品时改动就会比较多。比如我们要添加一个新的产品是电视柜。那么需要修改抽象工厂，添加生产电视柜的方法。此外，有几种工厂的实现，我们就需要修改几个类，添加具体的生产实现。</p>
<h2 id="抽象工厂适用场景"><a href="#抽象工厂适用场景" class="headerlink" title="抽象工厂适用场景"></a>抽象工厂适用场景</h2><ol>
<li><strong>你的系统中，需要使用不同产品族中的某一个产品族来操作。</strong> 比如说DB源。如果想切换DB，只需要切换DB源即可，其他代码基本上不需要改动；</li>
<li><strong>你的系统中，需要保证某些产品的一致性。</strong> 比如操作系统的外观，当切换到夜间模式时，所有的组件都会换为夜间模式风格。</li>
</ol>
<h2 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h2><p>抽象工厂可以做到一组产品的使用和生产相分离。通过抽象工厂模式，我们切换一组产品族的，只需要更换抽象工厂实现即可。由于产品生产被分离出去，所以添加新的产品族完全通过扩展来实现的。很好的实现了开闭原则。如果你要生产的产品很多，而且是一个产品族。并且面临不同产品族切换的情况。那么可以考虑通过抽象工厂来实现。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ahao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ahao.ink/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">https://ahao.ink/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ahao.ink" target="_blank">ahao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2021/12/26/ydiAZTkanzuLY7P.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://i.loli.net/2021/11/12/6zSDdqXlvjMakgC.jpg" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/11/12/6zSDdqXlvjMakgC.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://i.loli.net/2021/11/12/Xa5GvktA3qi7VYN.jpg" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/11/12/Xa5GvktA3qi7VYN.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/Redis%20%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"><img class="prev-cover" src="https://s2.loli.net/2021/12/27/7iM8ayJxTXpUsFo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis常用数据类型</div></div></a></div><div class="next-post pull-right"><a href="/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/"><img class="next-cover" src="https://s2.loli.net/2021/12/16/x1FKPEYde2a5RgW.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入浅出索引</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/11/12/Edhsr56wxfUbuFg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">ahao</div><div class="author-info__description">如有一味绝境，非历十方生死</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://ahao.ink"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">好 记 性 不 如 烂 笔 头</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">设计模式简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%A5%E8%87%AA%E5%93%AA%E9%87%8C"><span class="toc-number">1.2.</span> <span class="toc-text">设计模式来自哪里</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">为什么要学习设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E5%99%A81-0%E7%89%88%E6%9C%AC"><span class="toc-number">2.1.</span> <span class="toc-text">音乐推荐器1.0版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E5%99%A82-0%E7%89%88%E6%9C%AC"><span class="toc-number">2.2.</span> <span class="toc-text">音乐推荐器2.0版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E5%99%A83-0%E7%89%88%E6%9C%AC"><span class="toc-number">2.3.</span> <span class="toc-text">音乐推荐器3.0版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">实现策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%94%B5%E5%AD%90%E5%9C%B0%E5%9B%BE"><span class="toc-number">3.1.1.</span> <span class="toc-text">工厂模式实现电子地图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%94%B5%E5%AD%90%E5%9C%B0%E5%9B%BE"><span class="toc-number">3.1.2.</span> <span class="toc-text">策略模式实现电子地图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">策略模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">3.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">策略模式与工厂模式结合使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.4.</span> <span class="toc-text">策略模式适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">3.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">实现单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">线程安全的懒汉单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">饿汉式单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E9%9D%99%E6%80%81%E7%B1%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">内部静态类方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.2.</span> <span class="toc-text">单例模式适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">4.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">实现代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.2.</span> <span class="toc-text">代理模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.3.</span> <span class="toc-text">代理模式适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">5.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">实现适配器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9"><span class="toc-number">6.2.</span> <span class="toc-text">适配器模式优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.3.</span> <span class="toc-text">适配器模式适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">6.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">装饰者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">实现装饰者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">7.2.</span> <span class="toc-text">装饰者模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">7.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">7.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.3.</span> <span class="toc-text">装饰者模式适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-number">7.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">模版方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">实现模版方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.2.</span> <span class="toc-text">模版方法优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">8.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">8.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.3.</span> <span class="toc-text">模版方法适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="toc-number">8.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.1.</span> <span class="toc-text">实现观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.2.</span> <span class="toc-text">观察者模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-4"><span class="toc-number">9.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-4"><span class="toc-number">9.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.3.</span> <span class="toc-text">观察者模式适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-8"><span class="toc-number">9.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="toc-number">10.1.</span> <span class="toc-text">实现抽象工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">10.2.</span> <span class="toc-text">抽象工厂优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-5"><span class="toc-number">10.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-5"><span class="toc-number">10.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.3.</span> <span class="toc-text">抽象工厂适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-9"><span class="toc-number">10.4.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="面试常见问题"><img src="https://i.loli.net/2021/11/16/XIRUktNscboKLJz.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试常见问题"/></a><div class="content"><a class="title" href="/posts/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="面试常见问题">面试常见问题</a><time datetime="2021-12-27T05:36:41.000Z" title="发表于 2021-12-27 13:36:41">2021-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="EventLoop和线程模型"><img src="https://s2.loli.net/2021/12/24/oU8bJKuwTrD4pN3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EventLoop和线程模型"/></a><div class="content"><a class="title" href="/posts/EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="EventLoop和线程模型">EventLoop和线程模型</a><time datetime="2021-10-06T05:36:41.000Z" title="发表于 2021-10-06 13:36:41">2021-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Netty%20%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/" title="Netty 心跳检测"><img src="https://s2.loli.net/2021/12/24/gYjCcwFdvQypA4b.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty 心跳检测"/></a><div class="content"><a class="title" href="/posts/Netty%20%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/" title="Netty 心跳检测">Netty 心跳检测</a><time datetime="2021-09-30T05:36:41.000Z" title="发表于 2021-09-30 13:36:41">2021-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="序列化和反序列化到底有什么用呢？"><img src="https://s2.loli.net/2021/12/24/V7zmByD8F6fj3As.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="序列化和反序列化到底有什么用呢？"/></a><div class="content"><a class="title" href="/posts/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="序列化和反序列化到底有什么用呢？">序列化和反序列化到底有什么用呢？</a><time datetime="2021-09-30T05:36:41.000Z" title="发表于 2021-09-30 13:36:41">2021-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Netty%20%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE/" title="Netty 常用协议"><img src="https://s2.loli.net/2021/12/26/s2KLVFPdw18MxmN.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty 常用协议"/></a><div class="content"><a class="title" href="/posts/Netty%20%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE/" title="Netty 常用协议">Netty 常用协议</a><time datetime="2021-09-30T05:36:41.000Z" title="发表于 2021-09-30 13:36:41">2021-09-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2021/12/26/ydiAZTkanzuLY7P.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By ahao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://ahao.ink" target="_self">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'oKBwwKX9hp2tpOKDPE3PVQpL-gzGzoHsz',
      appKey: '3QBBKGzgsE11VOcVl1RElhgu',
      placeholder: '说点什么吧~',
      avatar: 'retro',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '//i0.hdslb.com/bfs/emote/',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>